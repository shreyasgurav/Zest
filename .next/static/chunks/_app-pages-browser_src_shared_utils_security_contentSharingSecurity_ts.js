"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_shared_utils_security_contentSharingSecurity_ts"],{

/***/ "(app-pages-browser)/./src/shared/utils/security/contentSharingSecurity.ts":
/*!*************************************************************!*\
  !*** ./src/shared/utils/security/contentSharingSecurity.ts ***!
  \*************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentSharingSecurity: function() { return /* binding */ ContentSharingSecurity; }\n/* harmony export */ });\n/* harmony import */ var _infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/infrastructure/firebase */ \"(app-pages-browser)/./src/infrastructure/firebase/index.ts\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/auth */ \"(app-pages-browser)/./node_modules/firebase/auth/dist/esm/index.esm.js\");\n\n\n\n// Security Constants\nconst SECURITY_LIMITS = {\n    maxSharesPerContent: 100,\n    maxSharesPerUser: 1000,\n    maxInvitationsPerHour: 10,\n    maxInvitationsPerDay: 50,\n    maxMessageLength: 500,\n    maxPhoneLength: 20,\n    // Add new security limits\n    maxConcurrentSessions: 5,\n    accessTokenExpiry: 3600,\n    maxFailedAttempts: 5,\n    lockoutDuration: 900,\n    minPasswordLength: 8\n};\n// Rate limiting storage\nconst invitationRateLimit = new Map();\n// Add session tracking\nconst activeSessions = new Map();\nconst failedAttempts = new Map();\nclass ContentSharingSecurity {\n    /**\n   * Enhanced phone number validation with international format support\n   */ static validatePhoneNumber(phone) {\n        if (!phone || typeof phone !== \"string\") {\n            return {\n                isValid: false,\n                error: \"Phone number is required\"\n            };\n        }\n        // Remove all non-digit characters except +\n        const cleaned = phone.replace(/[^\\d+]/g, \"\");\n        // Check length limits\n        if (cleaned.length > SECURITY_LIMITS.maxPhoneLength) {\n            return {\n                isValid: false,\n                error: \"Phone number too long\"\n            };\n        }\n        // Must start with + and have 10-15 digits\n        const phoneRegex = /^\\+[1-9]\\d{9,14}$/;\n        if (!phoneRegex.test(cleaned)) {\n            return {\n                isValid: false,\n                error: \"Invalid phone number format. Use +[country code][number]\"\n            };\n        }\n        return {\n            isValid: true\n        };\n    }\n    /**\n   * Input sanitization for messages and text inputs\n   */ static sanitizeInput(input) {\n        if (!input || typeof input !== \"string\") return \"\";\n        return input.trim().replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, \"\") // Remove scripts\n        .replace(/[<>'\"]/g, \"\") // Remove HTML/XML chars\n        .replace(/javascript:/gi, \"\") // Remove javascript: urls\n        .replace(/data:/gi, \"\") // Remove data: urls\n        .substring(0, SECURITY_LIMITS.maxMessageLength); // Limit length\n    }\n    /**\n   * Validate invitation message for suspicious content\n   */ static validateMessage(message) {\n        if (!message || message.trim() === \"\") return {\n            isValid: true\n        }; // Empty message is okay\n        const sanitized = this.sanitizeInput(message);\n        // Check for suspicious patterns\n        const suspiciousPatterns = [\n            /vbscript:/i,\n            /<iframe/i,\n            /<object/i,\n            /<embed/i,\n            /eval\\(/i,\n            /document\\./i,\n            /window\\./i\n        ];\n        if (suspiciousPatterns.some((pattern)=>pattern.test(sanitized))) {\n            return {\n                isValid: false,\n                error: \"Message contains suspicious content\"\n            };\n        }\n        return {\n            isValid: true\n        };\n    }\n    /**\n   * Check rate limits for invitations\n   */ static checkInvitationRateLimit(userId) {\n        const now = Date.now();\n        const hourMs = 60 * 60 * 1000;\n        const dayMs = 24 * hourMs;\n        const userLimits = invitationRateLimit.get(userId) || {\n            count: 0,\n            lastReset: now,\n            dailyCount: 0,\n            dailyReset: now\n        };\n        // Reset hourly counter if needed\n        if (now - userLimits.lastReset > hourMs) {\n            userLimits.count = 0;\n            userLimits.lastReset = now;\n        }\n        // Reset daily counter if needed\n        if (now - userLimits.dailyReset > dayMs) {\n            userLimits.dailyCount = 0;\n            userLimits.dailyReset = now;\n        }\n        // Check limits\n        if (userLimits.count >= SECURITY_LIMITS.maxInvitationsPerHour) {\n            return {\n                allowed: false,\n                error: \"Too many invitations sent this hour. Please wait.\"\n            };\n        }\n        if (userLimits.dailyCount >= SECURITY_LIMITS.maxInvitationsPerDay) {\n            return {\n                allowed: false,\n                error: \"Daily invitation limit reached. Please try again tomorrow.\"\n            };\n        }\n        // Increment counters\n        userLimits.count++;\n        userLimits.dailyCount++;\n        invitationRateLimit.set(userId, userLimits);\n        return {\n            allowed: true\n        };\n    }\n    /**\n   * Check resource limits (max shares per user/content)\n   */ static async checkResourceLimits(userId, contentId) {\n        try {\n            const [userShares, contentShares] = await Promise.all([\n                (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentSharing\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"assignedBy\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"isActive\", \"==\", true))),\n                (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentSharing\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"contentId\", \"==\", contentId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"isActive\", \"==\", true)))\n            ]);\n            if (userShares.size >= SECURITY_LIMITS.maxSharesPerUser) {\n                return {\n                    allowed: false,\n                    error: \"Maximum shares per user exceeded\"\n                };\n            }\n            if (contentShares.size >= SECURITY_LIMITS.maxSharesPerContent) {\n                return {\n                    allowed: false,\n                    error: \"Maximum shares for this content exceeded\"\n                };\n            }\n            return {\n                allowed: true\n            };\n        } catch (error) {\n            console.error(\"Error checking resource limits:\", error);\n            return {\n                allowed: false,\n                error: \"Unable to verify resource limits\"\n            };\n        }\n    }\n    /**\n   * Enhanced permission validation\n   */ static validatePermissionChange(currentPermissions, newPermissions) {\n        // Only owners can grant admin permissions\n        if (newPermissions.role === \"admin\" && currentPermissions.role !== \"owner\") {\n            return {\n                isValid: false,\n                error: \"Only owners can grant admin permissions\"\n            };\n        }\n        // Only admins and owners can manage permissions\n        if (!currentPermissions.canManage && currentPermissions.role !== \"owner\") {\n            return {\n                isValid: false,\n                error: \"Insufficient permissions to manage access\"\n            };\n        }\n        // Prevent role escalation beyond current user's level\n        const roleHierarchy = {\n            viewer: 1,\n            editor: 2,\n            admin: 3,\n            owner: 4,\n            unauthorized: 0\n        };\n        const currentLevel = roleHierarchy[currentPermissions.role] || 0;\n        const newLevel = roleHierarchy[newPermissions.role] || 0;\n        if (newLevel > currentLevel) {\n            return {\n                isValid: false,\n                error: \"Cannot grant permissions higher than your own\"\n            };\n        }\n        return {\n            isValid: true\n        };\n    }\n    /**\n   * Log security events for monitoring\n   */ static async logSecurityEvent(event) {\n        try {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"securityLogs\"), {\n                ...event,\n                timestamp: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                userAgent: typeof navigator !== \"undefined\" ? navigator.userAgent : \"unknown\"\n            });\n        } catch (error) {\n            console.error(\"Failed to log security event:\", error);\n        }\n    }\n    /**\n   * Verify if a user has access to specific content\n   */ static async verifyContentAccess(contentType, contentId, userId) {\n        // Add brute force protection\n        if (!await this.validateAccessAttempt(userId)) {\n            await this.logSecurityEvent({\n                type: \"access_denied\",\n                userId,\n                contentType,\n                contentId,\n                details: {\n                    reason: \"Account temporarily locked due to too many failed attempts\"\n                }\n            });\n            return this.unauthorizedPermissions();\n        }\n        const currentUser = (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.getAuth)().currentUser;\n        if (!currentUser || currentUser.uid !== userId) {\n            this.recordFailedAttempt(userId);\n            return this.unauthorizedPermissions();\n        }\n        try {\n            // First check if user is the owner\n            const isOwner = await this.checkContentOwnership(contentType, contentId, userId);\n            if (isOwner) {\n                return this.ownerPermissions();\n            }\n            // Check for shared access permissions\n            const sharedPermissions = await this.getSharedPermissions(contentType, contentId, userId);\n            if (sharedPermissions) {\n                return sharedPermissions;\n            }\n            this.recordFailedAttempt(userId);\n            return this.unauthorizedPermissions();\n        } catch (error) {\n            console.error(\"Error verifying content access:\", error);\n            this.recordFailedAttempt(userId);\n            return this.unauthorizedPermissions();\n        }\n    }\n    /**\n   * Share content with another user\n   */ static async shareContent(contentType, contentId, targetUserPhone, targetUserName, permissions, sharedByUserId, sharedByName, expiresInHours, message) {\n        try {\n            // 1. Validate phone number\n            const phoneValidation = this.validatePhoneNumber(targetUserPhone);\n            if (!phoneValidation.isValid) {\n                await this.logSecurityEvent({\n                    type: \"suspicious_activity\",\n                    userId: sharedByUserId,\n                    contentType,\n                    contentId,\n                    details: {\n                        reason: \"Invalid phone number\",\n                        phone: targetUserPhone\n                    }\n                });\n                return {\n                    success: false,\n                    error: phoneValidation.error\n                };\n            }\n            // 2. Validate message content\n            if (message) {\n                const messageValidation = this.validateMessage(message);\n                if (!messageValidation.isValid) {\n                    await this.logSecurityEvent({\n                        type: \"suspicious_activity\",\n                        userId: sharedByUserId,\n                        contentType,\n                        contentId,\n                        details: {\n                            reason: \"Suspicious message content\",\n                            message\n                        }\n                    });\n                    return {\n                        success: false,\n                        error: messageValidation.error\n                    };\n                }\n            }\n            // 3. Check rate limits\n            const rateLimitCheck = this.checkInvitationRateLimit(sharedByUserId);\n            if (!rateLimitCheck.allowed) {\n                return {\n                    success: false,\n                    error: rateLimitCheck.error\n                };\n            }\n            // 4. Check resource limits\n            const resourceCheck = await this.checkResourceLimits(sharedByUserId, contentId);\n            if (!resourceCheck.allowed) {\n                return {\n                    success: false,\n                    error: resourceCheck.error\n                };\n            }\n            // 5. Verify the sharer has permission to share - ONLY OWNERS CAN SHARE\n            const sharerPermissions = await this.verifyContentAccess(contentType, contentId, sharedByUserId);\n            // 🚨 ENHANCED: Only page owners can grant access to others\n            if (sharerPermissions.role !== \"owner\") {\n                await this.logSecurityEvent({\n                    type: \"access_denied\",\n                    userId: sharedByUserId,\n                    contentType,\n                    contentId,\n                    details: {\n                        reason: \"Only page owners can grant access to others\",\n                        userRole: sharerPermissions.role,\n                        requiredRole: \"owner\"\n                    }\n                });\n                return {\n                    success: false,\n                    error: \"Only page owners can grant access to others. You have \" + sharerPermissions.role + \" access.\"\n                };\n            }\n            // 6. Validate permission level\n            const permissionValidation = this.validatePermissionChange(sharerPermissions, permissions);\n            if (!permissionValidation.isValid) {\n                return {\n                    success: false,\n                    error: permissionValidation.error\n                };\n            }\n            // 7. Sanitize inputs\n            const sanitizedMessage = message ? this.sanitizeInput(message) : \"\";\n            const sanitizedTargetName = this.sanitizeInput(targetUserName);\n            const sanitizedPhone = targetUserPhone.replace(/[^\\d+]/g, \"\"); // Clean phone number\n            // 8. Check if target user exists\n            const targetUser = await this.findUserByPhone(sanitizedPhone);\n            const expiresAt = expiresInHours ? new Date(Date.now() + expiresInHours * 60 * 60 * 1000).toISOString() : undefined;\n            if (targetUser) {\n                // User exists, create direct assignment\n                const assignment = {\n                    contentType,\n                    contentId,\n                    userId: targetUser.uid,\n                    userPhone: sanitizedPhone,\n                    userName: sanitizedTargetName || targetUser.name || \"Editor\",\n                    permissions,\n                    assignedBy: sharedByUserId,\n                    assignedByName: sharedByName,\n                    assignedAt: new Date().toISOString(),\n                    expiresAt,\n                    isActive: true,\n                    status: \"active\",\n                    notes: sanitizedMessage,\n                    invitationMessage: sanitizedMessage\n                };\n                // Check if user already has access\n                const existingQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentSharing\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"contentType\", \"==\", contentType), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"contentId\", \"==\", contentId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"userId\", \"==\", targetUser.uid), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"isActive\", \"==\", true));\n                const existingSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(existingQuery);\n                if (!existingSnapshot.empty) {\n                    // Update existing assignment\n                    const existingDoc = existingSnapshot.docs[0];\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(existingDoc.ref, {\n                        permissions,\n                        assignedBy: sharedByUserId,\n                        assignedByName: sharedByName,\n                        assignedAt: assignment.assignedAt,\n                        expiresAt,\n                        notes: sanitizedMessage,\n                        updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                    });\n                    await this.logSecurityEvent({\n                        type: \"permission_change\",\n                        userId: sharedByUserId,\n                        contentType,\n                        contentId,\n                        details: {\n                            targetUserId: targetUser.uid,\n                            newRole: permissions.role,\n                            action: \"updated\"\n                        }\n                    });\n                    return {\n                        success: true,\n                        assignmentId: existingDoc.id\n                    };\n                } else {\n                    // Create new assignment\n                    const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentSharing\"), {\n                        ...assignment,\n                        createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                    });\n                    await this.logSecurityEvent({\n                        type: \"access_granted\",\n                        userId: sharedByUserId,\n                        contentType,\n                        contentId,\n                        details: {\n                            targetUserId: targetUser.uid,\n                            role: permissions.role,\n                            action: \"created\"\n                        }\n                    });\n                    return {\n                        success: true,\n                        assignmentId: docRef.id\n                    };\n                }\n            } else {\n                // User doesn't exist, create invitation\n                const contentName = await this.getContentName(contentType, contentId);\n                const invitation = {\n                    contentType,\n                    contentId,\n                    contentName,\n                    invitedPhone: sanitizedPhone,\n                    invitedByUserId: sharedByUserId,\n                    invitedByName: sharedByName,\n                    permissions,\n                    message: sanitizedMessage,\n                    status: \"pending\",\n                    createdAt: new Date().toISOString(),\n                    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() // 7 days\n                };\n                const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentInvitations\"), {\n                    ...invitation,\n                    createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n                });\n                await this.logSecurityEvent({\n                    type: \"access_granted\",\n                    userId: sharedByUserId,\n                    contentType,\n                    contentId,\n                    details: {\n                        invitedPhone: sanitizedPhone,\n                        role: permissions.role,\n                        action: \"invitation_created\"\n                    }\n                });\n                return {\n                    success: true,\n                    invitationId: docRef.id\n                };\n            }\n        } catch (error) {\n            console.error(\"Error sharing content:\", error);\n            return {\n                success: false,\n                error: \"Failed to share content\"\n            };\n        }\n    }\n    /**\n   * Remove shared access\n   */ static async removeSharedAccess(contentType, contentId, targetUserId, removedByUserId) {\n        try {\n            // Verify remover has permission\n            const removerPermissions = await this.verifyContentAccess(contentType, contentId, removedByUserId);\n            if (!removerPermissions.canManage && removerPermissions.role !== \"owner\") {\n                return {\n                    success: false,\n                    error: \"You do not have permission to remove access\"\n                };\n            }\n            // Find and remove the assignment\n            const assignmentQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentSharing\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"contentType\", \"==\", contentType), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"contentId\", \"==\", contentId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"userId\", \"==\", targetUserId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"isActive\", \"==\", true));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(assignmentQuery);\n            if (snapshot.empty) {\n                return {\n                    success: false,\n                    error: \"No shared access found for this user\"\n                };\n            }\n            const batch = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.writeBatch)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)());\n            snapshot.docs.forEach((doc)=>{\n                batch.update(doc.ref, {\n                    isActive: false,\n                    removedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                    removedBy: removedByUserId\n                });\n            });\n            await batch.commit();\n            return {\n                success: true\n            };\n        } catch (error) {\n            console.error(\"Error removing shared access:\", error);\n            return {\n                success: false,\n                error: \"Failed to remove shared access\"\n            };\n        }\n    }\n    /**\n   * Get all users who have access to content\n   */ static async getContentCollaborators(contentType, contentId) {\n        try {\n            const collaboratorsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentSharing\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"contentType\", \"==\", contentType), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"contentId\", \"==\", contentId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"isActive\", \"==\", true));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(collaboratorsQuery);\n            const assignments = snapshot.docs.map((doc)=>({\n                    id: doc.id,\n                    ...doc.data()\n                }));\n            // Deduplicate by userId - keep only the most recent assignment for each user\n            const userAssignmentMap = new Map();\n            for (const assignment of assignments){\n                // Skip expired assignments\n                if (assignment.expiresAt && new Date(assignment.expiresAt) < new Date()) {\n                    continue;\n                }\n                const existingAssignment = userAssignmentMap.get(assignment.userId);\n                if (!existingAssignment || new Date(assignment.assignedAt) > new Date(existingAssignment.assignedAt)) {\n                    userAssignmentMap.set(assignment.userId, assignment);\n                }\n            }\n            return Array.from(userAssignmentMap.values());\n        } catch (error) {\n            console.error(\"Error fetching content collaborators:\", error);\n            return [];\n        }\n    }\n    /**\n   * Get shared content for a user (content they have access to but don't own)\n   */ static async getUserSharedContent(userId) {\n        try {\n            const sharedQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentSharing\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"isActive\", \"==\", true));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(sharedQuery);\n            const sharedContent = {\n                artists: [],\n                organizations: [],\n                venues: [],\n                events: [],\n                activities: []\n            };\n            // Use Set to track already processed content to prevent duplicates\n            const processedContent = new Set();\n            for (const docSnap of snapshot.docs){\n                const assignment = docSnap.data();\n                // Check if assignment has expired\n                if (assignment.expiresAt && new Date(assignment.expiresAt) < new Date()) {\n                    continue;\n                }\n                // Create unique key for deduplication\n                const contentKey = \"\".concat(assignment.contentType, \"-\").concat(assignment.contentId);\n                // Skip if already processed to prevent duplicates\n                if (processedContent.has(contentKey)) {\n                    continue;\n                }\n                processedContent.add(contentKey);\n                // Get the content name\n                const contentName = await this.getContentName(assignment.contentType, assignment.contentId);\n                const sharedItem = {\n                    uid: assignment.contentId,\n                    name: contentName,\n                    role: assignment.permissions.role\n                };\n                switch(assignment.contentType){\n                    case \"artist\":\n                        sharedContent.artists.push(sharedItem);\n                        break;\n                    case \"organization\":\n                        sharedContent.organizations.push(sharedItem);\n                        break;\n                    case \"venue\":\n                        sharedContent.venues.push(sharedItem);\n                        break;\n                    case \"event\":\n                        sharedContent.events.push(sharedItem);\n                        break;\n                    case \"activity\":\n                        sharedContent.activities.push(sharedItem);\n                        break;\n                }\n            }\n            return sharedContent;\n        } catch (error) {\n            console.error(\"Error fetching shared content:\", error);\n            return {\n                artists: [],\n                organizations: [],\n                venues: [],\n                events: [],\n                activities: []\n            };\n        }\n    }\n    /**\n   * Get pending invitations for a user\n   */ static async getUserPendingInvitations(userPhone) {\n        try {\n            const invitationsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentInvitations\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"invitedPhone\", \"==\", userPhone), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"status\", \"==\", \"pending\"));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(invitationsQuery);\n            return snapshot.docs.map((doc)=>({\n                    id: doc.id,\n                    ...doc.data()\n                }));\n        } catch (error) {\n            console.error(\"Error fetching pending invitations:\", error);\n            return [];\n        }\n    }\n    /**\n   * Accept an invitation\n   */ static async acceptInvitation(invitationId, userId, userName) {\n        try {\n            const invitationDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentInvitations\", invitationId));\n            if (!invitationDoc.exists()) {\n                return {\n                    success: false,\n                    error: \"Invitation not found\"\n                };\n            }\n            const invitation = invitationDoc.data();\n            // Check if invitation is still valid\n            if (invitation.status !== \"pending\" || new Date(invitation.expiresAt) < new Date()) {\n                return {\n                    success: false,\n                    error: \"Invitation has expired or already been responded to\"\n                };\n            }\n            // Create content sharing assignment\n            const assignment = {\n                contentType: invitation.contentType,\n                contentId: invitation.contentId,\n                userId,\n                userPhone: invitation.invitedPhone,\n                userName,\n                permissions: invitation.permissions,\n                assignedBy: invitation.invitedByUserId,\n                assignedByName: invitation.invitedByName,\n                assignedAt: new Date().toISOString(),\n                isActive: true,\n                status: \"active\",\n                notes: \"Accepted invitation: \".concat(invitation.message || \"\"),\n                invitationMessage: invitation.message || \"\"\n            };\n            // Use batch to update invitation and create assignment\n            const batch = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.writeBatch)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)());\n            // Update invitation status\n            batch.update((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentInvitations\", invitationId), {\n                status: \"accepted\",\n                respondedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                invitedUserId: userId\n            });\n            // Create sharing assignment\n            const assignmentRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentSharing\"));\n            batch.set(assignmentRef, {\n                ...assignment,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n            });\n            await batch.commit();\n            await this.logContentSecurityEvent({\n                type: \"invitation_response\",\n                userId,\n                contentType: invitation.contentType,\n                contentId: invitation.contentId,\n                action: \"invitation_accepted\",\n                result: \"success\",\n                details: {\n                    invitationId,\n                    role: invitation.permissions.role\n                }\n            });\n            return {\n                success: true\n            };\n        } catch (error) {\n            console.error(\"Error accepting invitation:\", error);\n            return {\n                success: false,\n                error: \"Failed to accept invitation\"\n            };\n        }\n    }\n    /**\n   * Decline an invitation\n   */ static async declineInvitation(invitationId) {\n        try {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentInvitations\", invitationId), {\n                status: \"declined\",\n                respondedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n            });\n            return {\n                success: true\n            };\n        } catch (error) {\n            console.error(\"Error declining invitation:\", error);\n            return {\n                success: false,\n                error: \"Failed to decline invitation\"\n            };\n        }\n    }\n    /**\n   * Permission templates for different roles\n   */ static getPermissionTemplates() {\n        return {\n            viewer: {\n                canView: true,\n                canEdit: false,\n                canManage: false,\n                canInviteOthers: false,\n                canViewAnalytics: false,\n                canDelete: false,\n                role: \"viewer\"\n            },\n            editor: {\n                canView: true,\n                canEdit: true,\n                canManage: false,\n                canInviteOthers: false,\n                canViewAnalytics: true,\n                canDelete: false,\n                role: \"editor\"\n            },\n            admin: {\n                canView: true,\n                canEdit: true,\n                canManage: true,\n                canInviteOthers: true,\n                canViewAnalytics: true,\n                canDelete: false,\n                role: \"admin\"\n            }\n        };\n    }\n    // Private helper methods\n    static async checkContentOwnership(contentType, contentId, userId) {\n        try {\n            let collectionName = \"\";\n            let ownerField = \"ownerId\";\n            switch(contentType){\n                case \"artist\":\n                    collectionName = \"Artists\";\n                    break;\n                case \"organization\":\n                    collectionName = \"Organisations\";\n                    break;\n                case \"venue\":\n                    collectionName = \"Venues\";\n                    break;\n                case \"event\":\n                    collectionName = \"events\";\n                    ownerField = \"organizationId\";\n                    break;\n                case \"activity\":\n                    collectionName = \"activities\";\n                    ownerField = \"organizationId\";\n                    break;\n            }\n            const contentDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), collectionName, contentId));\n            if (!contentDoc.exists()) return false;\n            const contentData = contentDoc.data();\n            // For events, check both organizationId and creator.userId\n            if (contentType === \"event\") {\n                return contentData.organizationId === userId || contentData.creator && contentData.creator.userId === userId;\n            }\n            return contentData[ownerField] === userId;\n        } catch (error) {\n            console.error(\"Error checking content ownership:\", error);\n            return false;\n        }\n    }\n    static async getSharedPermissions(contentType, contentId, userId) {\n        try {\n            const sharingQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"contentSharing\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"contentType\", \"==\", contentType), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"contentId\", \"==\", contentId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"isActive\", \"==\", true));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(sharingQuery);\n            if (snapshot.empty) return null;\n            const assignment = snapshot.docs[0].data();\n            // Check if assignment has expired\n            if (assignment.expiresAt && new Date(assignment.expiresAt) < new Date()) {\n                // Mark as expired\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(snapshot.docs[0].ref, {\n                    isActive: false,\n                    status: \"expired\"\n                });\n                return null;\n            }\n            return assignment.permissions;\n        } catch (error) {\n            console.error(\"Error getting shared permissions:\", error);\n            return null;\n        }\n    }\n    static async findUserByPhone(phone) {\n        try {\n            const usersQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"Users\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"phoneNumber\", \"==\", phone));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(usersQuery);\n            if (snapshot.empty) return null;\n            const userData = snapshot.docs[0].data();\n            return {\n                uid: snapshot.docs[0].id,\n                name: userData.name || userData.displayName || \"Unknown User\"\n            };\n        } catch (error) {\n            console.error(\"Error finding user by phone:\", error);\n            return null;\n        }\n    }\n    static async getContentName(contentType, contentId) {\n        try {\n            let collectionName = \"\";\n            let nameField = \"name\";\n            switch(contentType){\n                case \"artist\":\n                    collectionName = \"Artists\";\n                    break;\n                case \"organization\":\n                    collectionName = \"Organisations\";\n                    break;\n                case \"venue\":\n                    collectionName = \"Venues\";\n                    break;\n                case \"event\":\n                    collectionName = \"events\";\n                    nameField = \"title\";\n                    break;\n                case \"activity\":\n                    collectionName = \"activities\";\n                    nameField = \"title\";\n                    break;\n            }\n            const contentDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), collectionName, contentId));\n            if (contentDoc.exists()) {\n                const data = contentDoc.data();\n                return data[nameField] || \"\".concat(contentType, \" \").concat(contentId);\n            }\n            return \"\".concat(contentType, \" \").concat(contentId);\n        } catch (error) {\n            console.error(\"Error getting content name:\", error);\n            return \"\".concat(contentType, \" \").concat(contentId);\n        }\n    }\n    static async logContentSecurityEvent(event) {\n        try {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_0__.db)(), \"securityEvents\"), {\n                ...event,\n                timestamp: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n                source: \"content_sharing_security\"\n            });\n        } catch (error) {\n            console.error(\"Error logging security event:\", error);\n        }\n    }\n    static ownerPermissions() {\n        return {\n            canView: true,\n            canEdit: true,\n            canManage: true,\n            canInviteOthers: true,\n            canViewAnalytics: true,\n            canDelete: true,\n            role: \"owner\"\n        };\n    }\n    static unauthorizedPermissions() {\n        return {\n            canView: false,\n            canEdit: false,\n            canManage: false,\n            canInviteOthers: false,\n            canViewAnalytics: false,\n            canDelete: false,\n            role: \"unauthorized\"\n        };\n    }\n    /**\n   * Track and limit concurrent sessions\n   */ static async trackSession(userId, sessionId) {\n        if (!activeSessions.has(userId)) {\n            activeSessions.set(userId, new Set());\n        }\n        const userSessions = activeSessions.get(userId);\n        if (userSessions.size >= SECURITY_LIMITS.maxConcurrentSessions) {\n            await this.logSecurityEvent({\n                type: \"session_limit_exceeded\",\n                userId,\n                contentType: \"system\",\n                contentId: \"global\",\n                details: {\n                    sessionId,\n                    activeCount: userSessions.size\n                }\n            });\n            return false;\n        }\n        userSessions.add(sessionId);\n        return true;\n    }\n    /**\n   * Enhanced permission validation with brute force protection\n   */ static async validateAccessAttempt(userId) {\n        if (!failedAttempts.has(userId)) {\n            failedAttempts.set(userId, {\n                count: 0,\n                lastAttempt: Date.now()\n            });\n            return true;\n        }\n        const attempts = failedAttempts.get(userId);\n        const now = Date.now();\n        // Reset if lockout duration has passed\n        if (now - attempts.lastAttempt > SECURITY_LIMITS.lockoutDuration * 1000) {\n            failedAttempts.set(userId, {\n                count: 0,\n                lastAttempt: now\n            });\n            return true;\n        }\n        if (attempts.count >= SECURITY_LIMITS.maxFailedAttempts) {\n            await this.logSecurityEvent({\n                type: \"account_lockout\",\n                userId,\n                contentType: \"system\",\n                contentId: \"global\",\n                details: {\n                    failedAttempts: attempts.count\n                }\n            });\n            return false;\n        }\n        return true;\n    }\n    /**\n   * Record failed access attempt\n   */ static recordFailedAttempt(userId) {\n        const attempts = failedAttempts.get(userId) || {\n            count: 0,\n            lastAttempt: Date.now()\n        };\n        attempts.count++;\n        attempts.lastAttempt = Date.now();\n        failedAttempts.set(userId, attempts);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zaGFyZWQvdXRpbHMvc2VjdXJpdHkvY29udGVudFNoYXJpbmdTZWN1cml0eS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStDO0FBQ2dHO0FBQ3ZHO0FBRXhDLHFCQUFxQjtBQUNyQixNQUFNWSxrQkFBa0I7SUFDdEJDLHFCQUFxQjtJQUNyQkMsa0JBQWtCO0lBQ2xCQyx1QkFBdUI7SUFDdkJDLHNCQUFzQjtJQUN0QkMsa0JBQWtCO0lBQ2xCQyxnQkFBZ0I7SUFDaEIsMEJBQTBCO0lBQzFCQyx1QkFBdUI7SUFDdkJDLG1CQUFtQjtJQUNuQkMsbUJBQW1CO0lBQ25CQyxpQkFBaUI7SUFDakJDLG1CQUFtQjtBQUNyQjtBQUVBLHdCQUF3QjtBQUN4QixNQUFNQyxzQkFBc0IsSUFBSUM7QUFFaEMsdUJBQXVCO0FBQ3ZCLE1BQU1DLGlCQUFpQixJQUFJRDtBQUMzQixNQUFNRSxpQkFBaUIsSUFBSUY7QUErQ3BCLE1BQU1HO0lBRVg7O0dBRUMsR0FDRCxPQUFPQyxvQkFBb0JDLEtBQWEsRUFBd0M7UUFDOUUsSUFBSSxDQUFDQSxTQUFTLE9BQU9BLFVBQVUsVUFBVTtZQUN2QyxPQUFPO2dCQUFFQyxTQUFTO2dCQUFPQyxPQUFPO1lBQTJCO1FBQzdEO1FBRUEsMkNBQTJDO1FBQzNDLE1BQU1DLFVBQVVILE1BQU1JLE9BQU8sQ0FBQyxXQUFXO1FBRXpDLHNCQUFzQjtRQUN0QixJQUFJRCxRQUFRRSxNQUFNLEdBQUd2QixnQkFBZ0JNLGNBQWMsRUFBRTtZQUNuRCxPQUFPO2dCQUFFYSxTQUFTO2dCQUFPQyxPQUFPO1lBQXdCO1FBQzFEO1FBRUEsMENBQTBDO1FBQzFDLE1BQU1JLGFBQWE7UUFDbkIsSUFBSSxDQUFDQSxXQUFXQyxJQUFJLENBQUNKLFVBQVU7WUFDN0IsT0FBTztnQkFBRUYsU0FBUztnQkFBT0MsT0FBTztZQUEyRDtRQUM3RjtRQUVBLE9BQU87WUFBRUQsU0FBUztRQUFLO0lBQ3pCO0lBRUE7O0dBRUMsR0FDRCxPQUFPTyxjQUFjQyxLQUFhLEVBQVU7UUFDMUMsSUFBSSxDQUFDQSxTQUFTLE9BQU9BLFVBQVUsVUFBVSxPQUFPO1FBRWhELE9BQU9BLE1BQ0pDLElBQUksR0FDSk4sT0FBTyxDQUFDLHVEQUF1RCxJQUFJLGlCQUFpQjtTQUNwRkEsT0FBTyxDQUFDLFdBQVcsSUFBSSx3QkFBd0I7U0FDL0NBLE9BQU8sQ0FBQyxpQkFBaUIsSUFBSSwwQkFBMEI7U0FDdkRBLE9BQU8sQ0FBQyxXQUFXLElBQUksb0JBQW9CO1NBQzNDTyxTQUFTLENBQUMsR0FBRzdCLGdCQUFnQkssZ0JBQWdCLEdBQUcsZUFBZTtJQUNwRTtJQUVBOztHQUVDLEdBQ0QsT0FBT3lCLGdCQUFnQkMsT0FBZSxFQUF3QztRQUM1RSxJQUFJLENBQUNBLFdBQVdBLFFBQVFILElBQUksT0FBTyxJQUFJLE9BQU87WUFBRVQsU0FBUztRQUFLLEdBQUcsd0JBQXdCO1FBRXpGLE1BQU1hLFlBQVksSUFBSSxDQUFDTixhQUFhLENBQUNLO1FBRXJDLGdDQUFnQztRQUNoQyxNQUFNRSxxQkFBcUI7WUFDekI7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUVELElBQUlBLG1CQUFtQkMsSUFBSSxDQUFDQyxDQUFBQSxVQUFXQSxRQUFRVixJQUFJLENBQUNPLGFBQWE7WUFDL0QsT0FBTztnQkFBRWIsU0FBUztnQkFBT0MsT0FBTztZQUFzQztRQUN4RTtRQUVBLE9BQU87WUFBRUQsU0FBUztRQUFLO0lBQ3pCO0lBRUE7O0dBRUMsR0FDRCxPQUFPaUIseUJBQXlCQyxNQUFjLEVBQXdDO1FBQ3BGLE1BQU1DLE1BQU1DLEtBQUtELEdBQUc7UUFDcEIsTUFBTUUsU0FBUyxLQUFLLEtBQUs7UUFDekIsTUFBTUMsUUFBUSxLQUFLRDtRQUVuQixNQUFNRSxhQUFhOUIsb0JBQW9CK0IsR0FBRyxDQUFDTixXQUFXO1lBQ3BETyxPQUFPO1lBQ1BDLFdBQVdQO1lBQ1hRLFlBQVk7WUFDWkMsWUFBWVQ7UUFDZDtRQUVBLGlDQUFpQztRQUNqQyxJQUFJQSxNQUFNSSxXQUFXRyxTQUFTLEdBQUdMLFFBQVE7WUFDdkNFLFdBQVdFLEtBQUssR0FBRztZQUNuQkYsV0FBV0csU0FBUyxHQUFHUDtRQUN6QjtRQUVBLGdDQUFnQztRQUNoQyxJQUFJQSxNQUFNSSxXQUFXSyxVQUFVLEdBQUdOLE9BQU87WUFDdkNDLFdBQVdJLFVBQVUsR0FBRztZQUN4QkosV0FBV0ssVUFBVSxHQUFHVDtRQUMxQjtRQUVBLGVBQWU7UUFDZixJQUFJSSxXQUFXRSxLQUFLLElBQUk1QyxnQkFBZ0JHLHFCQUFxQixFQUFFO1lBQzdELE9BQU87Z0JBQUU2QyxTQUFTO2dCQUFPNUIsT0FBTztZQUFvRDtRQUN0RjtRQUVBLElBQUlzQixXQUFXSSxVQUFVLElBQUk5QyxnQkFBZ0JJLG9CQUFvQixFQUFFO1lBQ2pFLE9BQU87Z0JBQUU0QyxTQUFTO2dCQUFPNUIsT0FBTztZQUE2RDtRQUMvRjtRQUVBLHFCQUFxQjtRQUNyQnNCLFdBQVdFLEtBQUs7UUFDaEJGLFdBQVdJLFVBQVU7UUFDckJsQyxvQkFBb0JxQyxHQUFHLENBQUNaLFFBQVFLO1FBRWhDLE9BQU87WUFBRU0sU0FBUztRQUFLO0lBQ3pCO0lBRUE7O0dBRUMsR0FDRCxhQUFhRSxvQkFBb0JiLE1BQWMsRUFBRWMsU0FBaUIsRUFBaUQ7UUFDakgsSUFBSTtZQUNGLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQztnQkFDcEQzRCwyREFBT0EsQ0FBQ0YseURBQUtBLENBQ1hILDhEQUFVQSxDQUFDSCw0REFBRUEsSUFBSSxtQkFDakJPLHlEQUFLQSxDQUFDLGNBQWMsTUFBTTBDLFNBQzFCMUMseURBQUtBLENBQUMsWUFBWSxNQUFNO2dCQUUxQkMsMkRBQU9BLENBQUNGLHlEQUFLQSxDQUNYSCw4REFBVUEsQ0FBQ0gsNERBQUVBLElBQUksbUJBQ2pCTyx5REFBS0EsQ0FBQyxhQUFhLE1BQU13RCxZQUN6QnhELHlEQUFLQSxDQUFDLFlBQVksTUFBTTthQUUzQjtZQUVELElBQUl5RCxXQUFXSSxJQUFJLElBQUl4RCxnQkFBZ0JFLGdCQUFnQixFQUFFO2dCQUN2RCxPQUFPO29CQUFFOEMsU0FBUztvQkFBTzVCLE9BQU87Z0JBQW1DO1lBQ3JFO1lBRUEsSUFBSWlDLGNBQWNHLElBQUksSUFBSXhELGdCQUFnQkMsbUJBQW1CLEVBQUU7Z0JBQzdELE9BQU87b0JBQUUrQyxTQUFTO29CQUFPNUIsT0FBTztnQkFBMkM7WUFDN0U7WUFFQSxPQUFPO2dCQUFFNEIsU0FBUztZQUFLO1FBQ3pCLEVBQUUsT0FBTzVCLE9BQU87WUFDZHFDLFFBQVFyQyxLQUFLLENBQUMsbUNBQW1DQTtZQUNqRCxPQUFPO2dCQUFFNEIsU0FBUztnQkFBTzVCLE9BQU87WUFBbUM7UUFDckU7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBT3NDLHlCQUNMQyxrQkFBc0MsRUFDdENDLGNBQWtDLEVBQ0k7UUFDdEMsMENBQTBDO1FBQzFDLElBQUlBLGVBQWVDLElBQUksS0FBSyxXQUFXRixtQkFBbUJFLElBQUksS0FBSyxTQUFTO1lBQzFFLE9BQU87Z0JBQUUxQyxTQUFTO2dCQUFPQyxPQUFPO1lBQTBDO1FBQzVFO1FBRUEsZ0RBQWdEO1FBQ2hELElBQUksQ0FBQ3VDLG1CQUFtQkcsU0FBUyxJQUFJSCxtQkFBbUJFLElBQUksS0FBSyxTQUFTO1lBQ3hFLE9BQU87Z0JBQUUxQyxTQUFTO2dCQUFPQyxPQUFPO1lBQTRDO1FBQzlFO1FBRUEsc0RBQXNEO1FBQ3RELE1BQU0yQyxnQkFBd0M7WUFBRUMsUUFBUTtZQUFHQyxRQUFRO1lBQUdDLE9BQU87WUFBR0MsT0FBTztZQUFHQyxjQUFjO1FBQUU7UUFDMUcsTUFBTUMsZUFBZU4sYUFBYSxDQUFDSixtQkFBbUJFLElBQUksQ0FBQyxJQUFJO1FBQy9ELE1BQU1TLFdBQVdQLGFBQWEsQ0FBQ0gsZUFBZUMsSUFBSSxDQUFDLElBQUk7UUFFdkQsSUFBSVMsV0FBV0QsY0FBYztZQUMzQixPQUFPO2dCQUFFbEQsU0FBUztnQkFBT0MsT0FBTztZQUFnRDtRQUNsRjtRQUVBLE9BQU87WUFBRUQsU0FBUztRQUFLO0lBQ3pCO0lBRUE7O0dBRUMsR0FDRCxhQUFhb0QsaUJBQWlCQyxLQU03QixFQUFpQjtRQUNoQixJQUFJO1lBQ0YsTUFBTWhGLDBEQUFNQSxDQUFDRCw4REFBVUEsQ0FBQ0gsNERBQUVBLElBQUksaUJBQWlCO2dCQUM3QyxHQUFHb0YsS0FBSztnQkFDUkMsV0FBV2hGLG1FQUFlQTtnQkFDMUJpRixXQUFXLE9BQU9DLGNBQWMsY0FBY0EsVUFBVUQsU0FBUyxHQUFHO1lBQ3RFO1FBQ0YsRUFBRSxPQUFPdEQsT0FBTztZQUNkcUMsUUFBUXJDLEtBQUssQ0FBQyxpQ0FBaUNBO1FBQ2pEO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELGFBQWF3RCxvQkFDWEMsV0FBdUUsRUFDdkUxQixTQUFpQixFQUNqQmQsTUFBYyxFQUNlO1FBQzdCLDZCQUE2QjtRQUM3QixJQUFJLENBQUUsTUFBTSxJQUFJLENBQUN5QyxxQkFBcUIsQ0FBQ3pDLFNBQVU7WUFDL0MsTUFBTSxJQUFJLENBQUNrQyxnQkFBZ0IsQ0FBQztnQkFDMUJRLE1BQU07Z0JBQ04xQztnQkFDQXdDO2dCQUNBMUI7Z0JBQ0E2QixTQUFTO29CQUFFQyxRQUFRO2dCQUE2RDtZQUNsRjtZQUNBLE9BQU8sSUFBSSxDQUFDQyx1QkFBdUI7UUFDckM7UUFFQSxNQUFNQyxjQUFjcEYsc0RBQU9BLEdBQUdvRixXQUFXO1FBQ3pDLElBQUksQ0FBQ0EsZUFBZUEsWUFBWUMsR0FBRyxLQUFLL0MsUUFBUTtZQUM5QyxJQUFJLENBQUNnRCxtQkFBbUIsQ0FBQ2hEO1lBQ3pCLE9BQU8sSUFBSSxDQUFDNkMsdUJBQXVCO1FBQ3JDO1FBRUEsSUFBSTtZQUNGLG1DQUFtQztZQUNuQyxNQUFNSSxVQUFVLE1BQU0sSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ1YsYUFBYTFCLFdBQVdkO1lBQ3pFLElBQUlpRCxTQUFTO2dCQUNYLE9BQU8sSUFBSSxDQUFDRSxnQkFBZ0I7WUFDOUI7WUFFQSxzQ0FBc0M7WUFDdEMsTUFBTUMsb0JBQW9CLE1BQU0sSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ2IsYUFBYTFCLFdBQVdkO1lBQ2xGLElBQUlvRCxtQkFBbUI7Z0JBQ3JCLE9BQU9BO1lBQ1Q7WUFFQSxJQUFJLENBQUNKLG1CQUFtQixDQUFDaEQ7WUFDekIsT0FBTyxJQUFJLENBQUM2Qyx1QkFBdUI7UUFFckMsRUFBRSxPQUFPOUQsT0FBTztZQUNkcUMsUUFBUXJDLEtBQUssQ0FBQyxtQ0FBbUNBO1lBQ2pELElBQUksQ0FBQ2lFLG1CQUFtQixDQUFDaEQ7WUFDekIsT0FBTyxJQUFJLENBQUM2Qyx1QkFBdUI7UUFDckM7SUFDRjtJQUVBOztHQUVDLEdBQ0QsYUFBYVMsYUFDWGQsV0FBdUUsRUFDdkUxQixTQUFpQixFQUNqQnlDLGVBQXVCLEVBQ3ZCQyxjQUFzQixFQUN0QkMsV0FBK0IsRUFDL0JDLGNBQXNCLEVBQ3RCQyxZQUFvQixFQUNwQkMsY0FBdUIsRUFDdkJsRSxPQUFnQixFQUM2RTtRQUM3RixJQUFJO1lBQ0YsMkJBQTJCO1lBQzNCLE1BQU1tRSxrQkFBa0IsSUFBSSxDQUFDakYsbUJBQW1CLENBQUMyRTtZQUNqRCxJQUFJLENBQUNNLGdCQUFnQi9FLE9BQU8sRUFBRTtnQkFDNUIsTUFBTSxJQUFJLENBQUNvRCxnQkFBZ0IsQ0FBQztvQkFDMUJRLE1BQU07b0JBQ04xQyxRQUFRMEQ7b0JBQ1JsQjtvQkFDQTFCO29CQUNBNkIsU0FBUzt3QkFBRUMsUUFBUTt3QkFBd0IvRCxPQUFPMEU7b0JBQWdCO2dCQUNwRTtnQkFDQSxPQUFPO29CQUFFTyxTQUFTO29CQUFPL0UsT0FBTzhFLGdCQUFnQjlFLEtBQUs7Z0JBQUM7WUFDeEQ7WUFFQSw4QkFBOEI7WUFDOUIsSUFBSVcsU0FBUztnQkFDWCxNQUFNcUUsb0JBQW9CLElBQUksQ0FBQ3RFLGVBQWUsQ0FBQ0M7Z0JBQy9DLElBQUksQ0FBQ3FFLGtCQUFrQmpGLE9BQU8sRUFBRTtvQkFDOUIsTUFBTSxJQUFJLENBQUNvRCxnQkFBZ0IsQ0FBQzt3QkFDMUJRLE1BQU07d0JBQ04xQyxRQUFRMEQ7d0JBQ1JsQjt3QkFDQTFCO3dCQUNBNkIsU0FBUzs0QkFBRUMsUUFBUTs0QkFBOEJsRDt3QkFBUTtvQkFDM0Q7b0JBQ0EsT0FBTzt3QkFBRW9FLFNBQVM7d0JBQU8vRSxPQUFPZ0Ysa0JBQWtCaEYsS0FBSztvQkFBQztnQkFDMUQ7WUFDRjtZQUVBLHVCQUF1QjtZQUN2QixNQUFNaUYsaUJBQWlCLElBQUksQ0FBQ2pFLHdCQUF3QixDQUFDMkQ7WUFDckQsSUFBSSxDQUFDTSxlQUFlckQsT0FBTyxFQUFFO2dCQUMzQixPQUFPO29CQUFFbUQsU0FBUztvQkFBTy9FLE9BQU9pRixlQUFlakYsS0FBSztnQkFBQztZQUN2RDtZQUVBLDJCQUEyQjtZQUMzQixNQUFNa0YsZ0JBQWdCLE1BQU0sSUFBSSxDQUFDcEQsbUJBQW1CLENBQUM2QyxnQkFBZ0I1QztZQUNyRSxJQUFJLENBQUNtRCxjQUFjdEQsT0FBTyxFQUFFO2dCQUMxQixPQUFPO29CQUFFbUQsU0FBUztvQkFBTy9FLE9BQU9rRixjQUFjbEYsS0FBSztnQkFBQztZQUN0RDtZQUVBLHVFQUF1RTtZQUN2RSxNQUFNbUYsb0JBQW9CLE1BQU0sSUFBSSxDQUFDM0IsbUJBQW1CLENBQUNDLGFBQWExQixXQUFXNEM7WUFFakYsMkRBQTJEO1lBQzNELElBQUlRLGtCQUFrQjFDLElBQUksS0FBSyxTQUFTO2dCQUN0QyxNQUFNLElBQUksQ0FBQ1UsZ0JBQWdCLENBQUM7b0JBQzFCUSxNQUFNO29CQUNOMUMsUUFBUTBEO29CQUNSbEI7b0JBQ0ExQjtvQkFDQTZCLFNBQVM7d0JBQ1BDLFFBQVE7d0JBQ1J1QixVQUFVRCxrQkFBa0IxQyxJQUFJO3dCQUNoQzRDLGNBQWM7b0JBQ2hCO2dCQUNGO2dCQUNBLE9BQU87b0JBQ0xOLFNBQVM7b0JBQ1QvRSxPQUFPLDJEQUEyRG1GLGtCQUFrQjFDLElBQUksR0FBRztnQkFDN0Y7WUFDRjtZQUVBLCtCQUErQjtZQUMvQixNQUFNNkMsdUJBQXVCLElBQUksQ0FBQ2hELHdCQUF3QixDQUFDNkMsbUJBQW1CVDtZQUM5RSxJQUFJLENBQUNZLHFCQUFxQnZGLE9BQU8sRUFBRTtnQkFDakMsT0FBTztvQkFBRWdGLFNBQVM7b0JBQU8vRSxPQUFPc0YscUJBQXFCdEYsS0FBSztnQkFBQztZQUM3RDtZQUVBLHFCQUFxQjtZQUNyQixNQUFNdUYsbUJBQW1CNUUsVUFBVSxJQUFJLENBQUNMLGFBQWEsQ0FBQ0ssV0FBVztZQUNqRSxNQUFNNkUsc0JBQXNCLElBQUksQ0FBQ2xGLGFBQWEsQ0FBQ21FO1lBQy9DLE1BQU1nQixpQkFBaUJqQixnQkFBZ0J0RSxPQUFPLENBQUMsV0FBVyxLQUFLLHFCQUFxQjtZQUVwRixpQ0FBaUM7WUFDakMsTUFBTXdGLGFBQWEsTUFBTSxJQUFJLENBQUNDLGVBQWUsQ0FBQ0Y7WUFDOUMsTUFBTUcsWUFBWWYsaUJBQWlCLElBQUkxRCxLQUFLQSxLQUFLRCxHQUFHLEtBQUsyRCxpQkFBaUIsS0FBSyxLQUFLLE1BQU1nQixXQUFXLEtBQUtDO1lBRTFHLElBQUlKLFlBQVk7Z0JBQ2Qsd0NBQXdDO2dCQUN4QyxNQUFNSyxhQUFxQztvQkFDekN0QztvQkFDQTFCO29CQUNBZCxRQUFReUUsV0FBVzFCLEdBQUc7b0JBQ3RCZ0MsV0FBV1A7b0JBQ1hRLFVBQVVULHVCQUF1QkUsV0FBV1EsSUFBSSxJQUFJO29CQUNwRHhCO29CQUNBeUIsWUFBWXhCO29CQUNaeUIsZ0JBQWdCeEI7b0JBQ2hCeUIsWUFBWSxJQUFJbEYsT0FBTzBFLFdBQVc7b0JBQ2xDRDtvQkFDQVUsVUFBVTtvQkFDVkMsUUFBUTtvQkFDUkMsT0FBT2pCO29CQUNQa0IsbUJBQW1CbEI7Z0JBQ3JCO2dCQUVBLG1DQUFtQztnQkFDbkMsTUFBTW1CLGdCQUFnQnBJLHlEQUFLQSxDQUN6QkgsOERBQVVBLENBQUNILDREQUFFQSxJQUFJLG1CQUNqQk8seURBQUtBLENBQUMsZUFBZSxNQUFNa0YsY0FDM0JsRix5REFBS0EsQ0FBQyxhQUFhLE1BQU13RCxZQUN6QnhELHlEQUFLQSxDQUFDLFVBQVUsTUFBTW1ILFdBQVcxQixHQUFHLEdBQ3BDekYseURBQUtBLENBQUMsWUFBWSxNQUFNO2dCQUcxQixNQUFNb0ksbUJBQW1CLE1BQU1uSSwyREFBT0EsQ0FBQ2tJO2dCQUV2QyxJQUFJLENBQUNDLGlCQUFpQkMsS0FBSyxFQUFFO29CQUMzQiw2QkFBNkI7b0JBQzdCLE1BQU1DLGNBQWNGLGlCQUFpQkcsSUFBSSxDQUFDLEVBQUU7b0JBQzVDLE1BQU1ySSw2REFBU0EsQ0FBQ29JLFlBQVlFLEdBQUcsRUFBRTt3QkFDL0JyQzt3QkFDQXlCLFlBQVl4Qjt3QkFDWnlCLGdCQUFnQnhCO3dCQUNoQnlCLFlBQVlOLFdBQVdNLFVBQVU7d0JBQ2pDVDt3QkFDQVksT0FBT2pCO3dCQUNQeUIsV0FBVzNJLG1FQUFlQTtvQkFDNUI7b0JBRUEsTUFBTSxJQUFJLENBQUM4RSxnQkFBZ0IsQ0FBQzt3QkFDMUJRLE1BQU07d0JBQ04xQyxRQUFRMEQ7d0JBQ1JsQjt3QkFDQTFCO3dCQUNBNkIsU0FBUzs0QkFBRXFELGNBQWN2QixXQUFXMUIsR0FBRzs0QkFBRWtELFNBQVN4QyxZQUFZakMsSUFBSTs0QkFBRTBFLFFBQVE7d0JBQVU7b0JBQ3hGO29CQUVBLE9BQU87d0JBQUVwQyxTQUFTO3dCQUFNcUMsY0FBY1AsWUFBWVEsRUFBRTtvQkFBQztnQkFDdkQsT0FBTztvQkFDTCx3QkFBd0I7b0JBQ3hCLE1BQU1DLFNBQVMsTUFBTWxKLDBEQUFNQSxDQUFDRCw4REFBVUEsQ0FBQ0gsNERBQUVBLElBQUksbUJBQW1CO3dCQUM5RCxHQUFHK0gsVUFBVTt3QkFDYndCLFdBQVdsSixtRUFBZUE7b0JBQzVCO29CQUVBLE1BQU0sSUFBSSxDQUFDOEUsZ0JBQWdCLENBQUM7d0JBQzFCUSxNQUFNO3dCQUNOMUMsUUFBUTBEO3dCQUNSbEI7d0JBQ0ExQjt3QkFDQTZCLFNBQVM7NEJBQUVxRCxjQUFjdkIsV0FBVzFCLEdBQUc7NEJBQUV2QixNQUFNaUMsWUFBWWpDLElBQUk7NEJBQUUwRSxRQUFRO3dCQUFVO29CQUNyRjtvQkFFQSxPQUFPO3dCQUFFcEMsU0FBUzt3QkFBTXFDLGNBQWNFLE9BQU9ELEVBQUU7b0JBQUM7Z0JBQ2xEO1lBQ0YsT0FBTztnQkFDTCx3Q0FBd0M7Z0JBQ3hDLE1BQU1HLGNBQWMsTUFBTSxJQUFJLENBQUNDLGNBQWMsQ0FBQ2hFLGFBQWExQjtnQkFFM0QsTUFBTTJGLGFBQWdDO29CQUNwQ2pFO29CQUNBMUI7b0JBQ0F5RjtvQkFDQUcsY0FBY2xDO29CQUNkbUMsaUJBQWlCakQ7b0JBQ2pCa0QsZUFBZWpEO29CQUNmRjtvQkFDQS9ELFNBQVM0RTtvQkFDVGdCLFFBQVE7b0JBQ1JnQixXQUFXLElBQUlwRyxPQUFPMEUsV0FBVztvQkFDakNELFdBQVcsSUFBSXpFLEtBQUtBLEtBQUtELEdBQUcsS0FBSyxJQUFJLEtBQUssS0FBSyxLQUFLLE1BQU0yRSxXQUFXLEdBQUcsU0FBUztnQkFDbkY7Z0JBRUEsTUFBTXlCLFNBQVMsTUFBTWxKLDBEQUFNQSxDQUFDRCw4REFBVUEsQ0FBQ0gsNERBQUVBLElBQUksdUJBQXVCO29CQUNsRSxHQUFHMEosVUFBVTtvQkFDYkgsV0FBV2xKLG1FQUFlQTtnQkFDNUI7Z0JBRUEsTUFBTSxJQUFJLENBQUM4RSxnQkFBZ0IsQ0FBQztvQkFDMUJRLE1BQU07b0JBQ04xQyxRQUFRMEQ7b0JBQ1JsQjtvQkFDQTFCO29CQUNBNkIsU0FBUzt3QkFBRStELGNBQWNsQzt3QkFBZ0JoRCxNQUFNaUMsWUFBWWpDLElBQUk7d0JBQUUwRSxRQUFRO29CQUFxQjtnQkFDaEc7Z0JBRUEsT0FBTztvQkFBRXBDLFNBQVM7b0JBQU0rQyxjQUFjUixPQUFPRCxFQUFFO2dCQUFDO1lBQ2xEO1FBQ0YsRUFBRSxPQUFPckgsT0FBTztZQUNkcUMsUUFBUXJDLEtBQUssQ0FBQywwQkFBMEJBO1lBQ3hDLE9BQU87Z0JBQUUrRSxTQUFTO2dCQUFPL0UsT0FBTztZQUEwQjtRQUM1RDtJQUNGO0lBRUE7O0dBRUMsR0FDRCxhQUFhK0gsbUJBQ1h0RSxXQUF1RSxFQUN2RTFCLFNBQWlCLEVBQ2pCa0YsWUFBb0IsRUFDcEJlLGVBQXVCLEVBQ3dCO1FBQy9DLElBQUk7WUFDRixnQ0FBZ0M7WUFDaEMsTUFBTUMscUJBQXFCLE1BQU0sSUFBSSxDQUFDekUsbUJBQW1CLENBQUNDLGFBQWExQixXQUFXaUc7WUFFbEYsSUFBSSxDQUFDQyxtQkFBbUJ2RixTQUFTLElBQUl1RixtQkFBbUJ4RixJQUFJLEtBQUssU0FBUztnQkFDeEUsT0FBTztvQkFBRXNDLFNBQVM7b0JBQU8vRSxPQUFPO2dCQUE4QztZQUNoRjtZQUVBLGlDQUFpQztZQUNqQyxNQUFNa0ksa0JBQWtCNUoseURBQUtBLENBQzNCSCw4REFBVUEsQ0FBQ0gsNERBQUVBLElBQUksbUJBQ2pCTyx5REFBS0EsQ0FBQyxlQUFlLE1BQU1rRixjQUMzQmxGLHlEQUFLQSxDQUFDLGFBQWEsTUFBTXdELFlBQ3pCeEQseURBQUtBLENBQUMsVUFBVSxNQUFNMEksZUFDdEIxSSx5REFBS0EsQ0FBQyxZQUFZLE1BQU07WUFHMUIsTUFBTTRKLFdBQVcsTUFBTTNKLDJEQUFPQSxDQUFDMEo7WUFFL0IsSUFBSUMsU0FBU3ZCLEtBQUssRUFBRTtnQkFDbEIsT0FBTztvQkFBRTdCLFNBQVM7b0JBQU8vRSxPQUFPO2dCQUF1QztZQUN6RTtZQUVBLE1BQU1vSSxRQUFRMUosOERBQVVBLENBQUNWLDREQUFFQTtZQUUzQm1LLFNBQVNyQixJQUFJLENBQUN1QixPQUFPLENBQUNwSyxDQUFBQTtnQkFDcEJtSyxNQUFNRSxNQUFNLENBQUNySyxJQUFJOEksR0FBRyxFQUFFO29CQUNwQlQsVUFBVTtvQkFDVmlDLFdBQVdsSyxtRUFBZUE7b0JBQzFCbUssV0FBV1I7Z0JBQ2I7WUFDRjtZQUVBLE1BQU1JLE1BQU1LLE1BQU07WUFFbEIsT0FBTztnQkFBRTFELFNBQVM7WUFBSztRQUN6QixFQUFFLE9BQU8vRSxPQUFPO1lBQ2RxQyxRQUFRckMsS0FBSyxDQUFDLGlDQUFpQ0E7WUFDL0MsT0FBTztnQkFBRStFLFNBQVM7Z0JBQU8vRSxPQUFPO1lBQWlDO1FBQ25FO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELGFBQWEwSSx3QkFDWGpGLFdBQXVFLEVBQ3ZFMUIsU0FBaUIsRUFDa0I7UUFDbkMsSUFBSTtZQUNGLE1BQU00RyxxQkFBcUJySyx5REFBS0EsQ0FDOUJILDhEQUFVQSxDQUFDSCw0REFBRUEsSUFBSSxtQkFDakJPLHlEQUFLQSxDQUFDLGVBQWUsTUFBTWtGLGNBQzNCbEYseURBQUtBLENBQUMsYUFBYSxNQUFNd0QsWUFDekJ4RCx5REFBS0EsQ0FBQyxZQUFZLE1BQU07WUFHMUIsTUFBTTRKLFdBQVcsTUFBTTNKLDJEQUFPQSxDQUFDbUs7WUFFL0IsTUFBTUMsY0FBY1QsU0FBU3JCLElBQUksQ0FBQytCLEdBQUcsQ0FBQzVLLENBQUFBLE1BQVE7b0JBQzVDb0osSUFBSXBKLElBQUlvSixFQUFFO29CQUNWLEdBQUdwSixJQUFJNkssSUFBSSxFQUFFO2dCQUNmO1lBRUEsNkVBQTZFO1lBQzdFLE1BQU1DLG9CQUFvQixJQUFJdEo7WUFFOUIsS0FBSyxNQUFNc0csY0FBYzZDLFlBQWE7Z0JBQ3BDLDJCQUEyQjtnQkFDM0IsSUFBSTdDLFdBQVdILFNBQVMsSUFBSSxJQUFJekUsS0FBSzRFLFdBQVdILFNBQVMsSUFBSSxJQUFJekUsUUFBUTtvQkFDdkU7Z0JBQ0Y7Z0JBRUEsTUFBTTZILHFCQUFxQkQsa0JBQWtCeEgsR0FBRyxDQUFDd0UsV0FBVzlFLE1BQU07Z0JBRWxFLElBQUksQ0FBQytILHNCQUNELElBQUk3SCxLQUFLNEUsV0FBV00sVUFBVSxJQUFJLElBQUlsRixLQUFLNkgsbUJBQW1CM0MsVUFBVSxHQUFHO29CQUM3RTBDLGtCQUFrQmxILEdBQUcsQ0FBQ2tFLFdBQVc5RSxNQUFNLEVBQUU4RTtnQkFDM0M7WUFDRjtZQUVBLE9BQU9rRCxNQUFNQyxJQUFJLENBQUNILGtCQUFrQkksTUFBTTtRQUM1QyxFQUFFLE9BQU9uSixPQUFPO1lBQ2RxQyxRQUFRckMsS0FBSyxDQUFDLHlDQUF5Q0E7WUFDdkQsT0FBTyxFQUFFO1FBQ1g7SUFDRjtJQUVBOztHQUVDLEdBQ0QsYUFBYW9KLHFCQUFxQm5JLE1BQWMsRUFNN0M7UUFDRCxJQUFJO1lBQ0YsTUFBTW9JLGNBQWMvSyx5REFBS0EsQ0FDdkJILDhEQUFVQSxDQUFDSCw0REFBRUEsSUFBSSxtQkFDakJPLHlEQUFLQSxDQUFDLFVBQVUsTUFBTTBDLFNBQ3RCMUMseURBQUtBLENBQUMsWUFBWSxNQUFNO1lBRzFCLE1BQU00SixXQUFXLE1BQU0zSiwyREFBT0EsQ0FBQzZLO1lBRS9CLE1BQU1DLGdCQUFnQjtnQkFDcEJDLFNBQVMsRUFBRTtnQkFDWEMsZUFBZSxFQUFFO2dCQUNqQkMsUUFBUSxFQUFFO2dCQUNWQyxRQUFRLEVBQUU7Z0JBQ1ZDLFlBQVksRUFBRTtZQUNoQjtZQUVBLG1FQUFtRTtZQUNuRSxNQUFNQyxtQkFBbUIsSUFBSUM7WUFFN0IsS0FBSyxNQUFNQyxXQUFXM0IsU0FBU3JCLElBQUksQ0FBRTtnQkFDbkMsTUFBTWYsYUFBYStELFFBQVFoQixJQUFJO2dCQUUvQixrQ0FBa0M7Z0JBQ2xDLElBQUkvQyxXQUFXSCxTQUFTLElBQUksSUFBSXpFLEtBQUs0RSxXQUFXSCxTQUFTLElBQUksSUFBSXpFLFFBQVE7b0JBQ3ZFO2dCQUNGO2dCQUVBLHNDQUFzQztnQkFDdEMsTUFBTTRJLGFBQWEsR0FBNkJoRSxPQUExQkEsV0FBV3RDLFdBQVcsRUFBQyxLQUF3QixPQUFyQnNDLFdBQVdoRSxTQUFTO2dCQUVwRSxrREFBa0Q7Z0JBQ2xELElBQUk2SCxpQkFBaUJJLEdBQUcsQ0FBQ0QsYUFBYTtvQkFDcEM7Z0JBQ0Y7Z0JBRUFILGlCQUFpQkssR0FBRyxDQUFDRjtnQkFFckIsdUJBQXVCO2dCQUN2QixNQUFNdkMsY0FBYyxNQUFNLElBQUksQ0FBQ0MsY0FBYyxDQUFDMUIsV0FBV3RDLFdBQVcsRUFBRXNDLFdBQVdoRSxTQUFTO2dCQUUxRixNQUFNbUksYUFBYTtvQkFDakJsRyxLQUFLK0IsV0FBV2hFLFNBQVM7b0JBQ3pCbUUsTUFBTXNCO29CQUNOL0UsTUFBTXNELFdBQVdyQixXQUFXLENBQUNqQyxJQUFJO2dCQUNuQztnQkFFQSxPQUFRc0QsV0FBV3RDLFdBQVc7b0JBQzVCLEtBQUs7d0JBQ0g2RixjQUFjQyxPQUFPLENBQUNZLElBQUksQ0FBQ0Q7d0JBQzNCO29CQUNGLEtBQUs7d0JBQ0haLGNBQWNFLGFBQWEsQ0FBQ1csSUFBSSxDQUFDRDt3QkFDakM7b0JBQ0YsS0FBSzt3QkFDSFosY0FBY0csTUFBTSxDQUFDVSxJQUFJLENBQUNEO3dCQUMxQjtvQkFDRixLQUFLO3dCQUNIWixjQUFjSSxNQUFNLENBQUNTLElBQUksQ0FBQ0Q7d0JBQzFCO29CQUNGLEtBQUs7d0JBQ0haLGNBQWNLLFVBQVUsQ0FBQ1EsSUFBSSxDQUFDRDt3QkFDOUI7Z0JBQ0o7WUFDRjtZQUVBLE9BQU9aO1FBQ1QsRUFBRSxPQUFPdEosT0FBTztZQUNkcUMsUUFBUXJDLEtBQUssQ0FBQyxrQ0FBa0NBO1lBQ2hELE9BQU87Z0JBQ0x1SixTQUFTLEVBQUU7Z0JBQ1hDLGVBQWUsRUFBRTtnQkFDakJDLFFBQVEsRUFBRTtnQkFDVkMsUUFBUSxFQUFFO2dCQUNWQyxZQUFZLEVBQUU7WUFDaEI7UUFDRjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxhQUFhUywwQkFBMEJwRSxTQUFpQixFQUFnQztRQUN0RixJQUFJO1lBQ0YsTUFBTXFFLG1CQUFtQi9MLHlEQUFLQSxDQUM1QkgsOERBQVVBLENBQUNILDREQUFFQSxJQUFJLHVCQUNqQk8seURBQUtBLENBQUMsZ0JBQWdCLE1BQU15SCxZQUM1QnpILHlEQUFLQSxDQUFDLFVBQVUsTUFBTTtZQUd4QixNQUFNNEosV0FBVyxNQUFNM0osMkRBQU9BLENBQUM2TDtZQUUvQixPQUFPbEMsU0FBU3JCLElBQUksQ0FBQytCLEdBQUcsQ0FBQzVLLENBQUFBLE1BQVE7b0JBQy9Cb0osSUFBSXBKLElBQUlvSixFQUFFO29CQUNWLEdBQUdwSixJQUFJNkssSUFBSSxFQUFFO2dCQUNmO1FBQ0YsRUFBRSxPQUFPOUksT0FBTztZQUNkcUMsUUFBUXJDLEtBQUssQ0FBQyx1Q0FBdUNBO1lBQ3JELE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELGFBQWFzSyxpQkFDWHhDLFlBQW9CLEVBQ3BCN0csTUFBYyxFQUNkZ0YsUUFBZ0IsRUFDK0I7UUFDL0MsSUFBSTtZQUNGLE1BQU1zRSxnQkFBZ0IsTUFBTXJNLDBEQUFNQSxDQUFDRCx1REFBR0EsQ0FBQ0QsNERBQUVBLElBQUksc0JBQXNCOEo7WUFFbkUsSUFBSSxDQUFDeUMsY0FBY0MsTUFBTSxJQUFJO2dCQUMzQixPQUFPO29CQUFFekYsU0FBUztvQkFBTy9FLE9BQU87Z0JBQXVCO1lBQ3pEO1lBRUEsTUFBTTBILGFBQWE2QyxjQUFjekIsSUFBSTtZQUVyQyxxQ0FBcUM7WUFDckMsSUFBSXBCLFdBQVduQixNQUFNLEtBQUssYUFBYSxJQUFJcEYsS0FBS3VHLFdBQVc5QixTQUFTLElBQUksSUFBSXpFLFFBQVE7Z0JBQ2xGLE9BQU87b0JBQUU0RCxTQUFTO29CQUFPL0UsT0FBTztnQkFBc0Q7WUFDeEY7WUFFQSxvQ0FBb0M7WUFDcEMsTUFBTStGLGFBQXFDO2dCQUN6Q3RDLGFBQWFpRSxXQUFXakUsV0FBVztnQkFDbkMxQixXQUFXMkYsV0FBVzNGLFNBQVM7Z0JBQy9CZDtnQkFDQStFLFdBQVcwQixXQUFXQyxZQUFZO2dCQUNsQzFCO2dCQUNBdkIsYUFBYWdELFdBQVdoRCxXQUFXO2dCQUNuQ3lCLFlBQVl1QixXQUFXRSxlQUFlO2dCQUN0Q3hCLGdCQUFnQnNCLFdBQVdHLGFBQWE7Z0JBQ3hDeEIsWUFBWSxJQUFJbEYsT0FBTzBFLFdBQVc7Z0JBQ2xDUyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSQyxPQUFPLHdCQUFpRCxPQUF6QmtCLFdBQVcvRyxPQUFPLElBQUk7Z0JBQ3JEOEYsbUJBQW1CaUIsV0FBVy9HLE9BQU8sSUFBSTtZQUMzQztZQUVBLHVEQUF1RDtZQUN2RCxNQUFNeUgsUUFBUTFKLDhEQUFVQSxDQUFDViw0REFBRUE7WUFFM0IsMkJBQTJCO1lBQzNCb0ssTUFBTUUsTUFBTSxDQUFDckssdURBQUdBLENBQUNELDREQUFFQSxJQUFJLHNCQUFzQjhKLGVBQWU7Z0JBQzFEdkIsUUFBUTtnQkFDUmtFLGFBQWFwTSxtRUFBZUE7Z0JBQzVCcU0sZUFBZXpKO1lBQ2pCO1lBRUEsNEJBQTRCO1lBQzVCLE1BQU0wSixnQkFBZ0IxTSx1REFBR0EsQ0FBQ0UsOERBQVVBLENBQUNILDREQUFFQSxJQUFJO1lBQzNDb0ssTUFBTXZHLEdBQUcsQ0FBQzhJLGVBQWU7Z0JBQ3ZCLEdBQUc1RSxVQUFVO2dCQUNid0IsV0FBV2xKLG1FQUFlQTtZQUM1QjtZQUVBLE1BQU0rSixNQUFNSyxNQUFNO1lBRWxCLE1BQU0sSUFBSSxDQUFDbUMsdUJBQXVCLENBQUM7Z0JBQ2pDakgsTUFBTTtnQkFDTjFDO2dCQUNBd0MsYUFBYWlFLFdBQVdqRSxXQUFXO2dCQUNuQzFCLFdBQVcyRixXQUFXM0YsU0FBUztnQkFDL0JvRixRQUFRO2dCQUNSMEQsUUFBUTtnQkFDUmpILFNBQVM7b0JBQUVrRTtvQkFBY3JGLE1BQU1pRixXQUFXaEQsV0FBVyxDQUFDakMsSUFBSTtnQkFBQztZQUM3RDtZQUVBLE9BQU87Z0JBQUVzQyxTQUFTO1lBQUs7UUFDekIsRUFBRSxPQUFPL0UsT0FBTztZQUNkcUMsUUFBUXJDLEtBQUssQ0FBQywrQkFBK0JBO1lBQzdDLE9BQU87Z0JBQUUrRSxTQUFTO2dCQUFPL0UsT0FBTztZQUE4QjtRQUNoRTtJQUNGO0lBRUE7O0dBRUMsR0FDRCxhQUFhOEssa0JBQWtCaEQsWUFBb0IsRUFBaUQ7UUFDbEcsSUFBSTtZQUNGLE1BQU1ySiw2REFBU0EsQ0FBQ1IsdURBQUdBLENBQUNELDREQUFFQSxJQUFJLHNCQUFzQjhKLGVBQWU7Z0JBQzdEdkIsUUFBUTtnQkFDUmtFLGFBQWFwTSxtRUFBZUE7WUFDOUI7WUFFQSxPQUFPO2dCQUFFMEcsU0FBUztZQUFLO1FBQ3pCLEVBQUUsT0FBTy9FLE9BQU87WUFDZHFDLFFBQVFyQyxLQUFLLENBQUMsK0JBQStCQTtZQUM3QyxPQUFPO2dCQUFFK0UsU0FBUztnQkFBTy9FLE9BQU87WUFBK0I7UUFDakU7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBTytLLHlCQUF5QjtRQUM5QixPQUFPO1lBQ0xuSSxRQUFRO2dCQUNOb0ksU0FBUztnQkFDVEMsU0FBUztnQkFDVHZJLFdBQVc7Z0JBQ1h3SSxpQkFBaUI7Z0JBQ2pCQyxrQkFBa0I7Z0JBQ2xCQyxXQUFXO2dCQUNYM0ksTUFBTTtZQUNSO1lBQ0FJLFFBQVE7Z0JBQ05tSSxTQUFTO2dCQUNUQyxTQUFTO2dCQUNUdkksV0FBVztnQkFDWHdJLGlCQUFpQjtnQkFDakJDLGtCQUFrQjtnQkFDbEJDLFdBQVc7Z0JBQ1gzSSxNQUFNO1lBQ1I7WUFDQUssT0FBTztnQkFDTGtJLFNBQVM7Z0JBQ1RDLFNBQVM7Z0JBQ1R2SSxXQUFXO2dCQUNYd0ksaUJBQWlCO2dCQUNqQkMsa0JBQWtCO2dCQUNsQkMsV0FBVztnQkFDWDNJLE1BQU07WUFDUjtRQUNGO0lBQ0Y7SUFFQSx5QkFBeUI7SUFDekIsYUFBcUIwQixzQkFDbkJWLFdBQXVFLEVBQ3ZFMUIsU0FBaUIsRUFDakJkLE1BQWMsRUFDSTtRQUNsQixJQUFJO1lBQ0YsSUFBSW9LLGlCQUFpQjtZQUNyQixJQUFJQyxhQUFhO1lBRWpCLE9BQVE3SDtnQkFDTixLQUFLO29CQUNINEgsaUJBQWlCO29CQUNqQjtnQkFDRixLQUFLO29CQUNIQSxpQkFBaUI7b0JBQ2pCO2dCQUNGLEtBQUs7b0JBQ0hBLGlCQUFpQjtvQkFDakI7Z0JBQ0YsS0FBSztvQkFDSEEsaUJBQWlCO29CQUNqQkMsYUFBYTtvQkFDYjtnQkFDRixLQUFLO29CQUNIRCxpQkFBaUI7b0JBQ2pCQyxhQUFhO29CQUNiO1lBQ0o7WUFFQSxNQUFNQyxhQUFhLE1BQU1yTiwwREFBTUEsQ0FBQ0QsdURBQUdBLENBQUNELDREQUFFQSxJQUFJcU4sZ0JBQWdCdEo7WUFDMUQsSUFBSSxDQUFDd0osV0FBV2YsTUFBTSxJQUFJLE9BQU87WUFFakMsTUFBTWdCLGNBQWNELFdBQVd6QyxJQUFJO1lBRW5DLDJEQUEyRDtZQUMzRCxJQUFJckYsZ0JBQWdCLFNBQVM7Z0JBQzNCLE9BQU8rSCxZQUFZQyxjQUFjLEtBQUt4SyxVQUM5QnVLLFlBQVlFLE9BQU8sSUFBSUYsWUFBWUUsT0FBTyxDQUFDekssTUFBTSxLQUFLQTtZQUNoRTtZQUVBLE9BQU91SyxXQUFXLENBQUNGLFdBQVcsS0FBS3JLO1FBQ3JDLEVBQUUsT0FBT2pCLE9BQU87WUFDZHFDLFFBQVFyQyxLQUFLLENBQUMscUNBQXFDQTtZQUNuRCxPQUFPO1FBQ1Q7SUFDRjtJQUVBLGFBQXFCc0UscUJBQ25CYixXQUF1RSxFQUN2RTFCLFNBQWlCLEVBQ2pCZCxNQUFjLEVBQ3NCO1FBQ3BDLElBQUk7WUFDRixNQUFNMEssZUFBZXJOLHlEQUFLQSxDQUN4QkgsOERBQVVBLENBQUNILDREQUFFQSxJQUFJLG1CQUNqQk8seURBQUtBLENBQUMsZUFBZSxNQUFNa0YsY0FDM0JsRix5REFBS0EsQ0FBQyxhQUFhLE1BQU13RCxZQUN6QnhELHlEQUFLQSxDQUFDLFVBQVUsTUFBTTBDLFNBQ3RCMUMseURBQUtBLENBQUMsWUFBWSxNQUFNO1lBRzFCLE1BQU00SixXQUFXLE1BQU0zSiwyREFBT0EsQ0FBQ21OO1lBRS9CLElBQUl4RCxTQUFTdkIsS0FBSyxFQUFFLE9BQU87WUFFM0IsTUFBTWIsYUFBYW9DLFNBQVNyQixJQUFJLENBQUMsRUFBRSxDQUFDZ0MsSUFBSTtZQUV4QyxrQ0FBa0M7WUFDbEMsSUFBSS9DLFdBQVdILFNBQVMsSUFBSSxJQUFJekUsS0FBSzRFLFdBQVdILFNBQVMsSUFBSSxJQUFJekUsUUFBUTtnQkFDdkUsa0JBQWtCO2dCQUNsQixNQUFNMUMsNkRBQVNBLENBQUMwSixTQUFTckIsSUFBSSxDQUFDLEVBQUUsQ0FBQ0MsR0FBRyxFQUFFO29CQUNwQ1QsVUFBVTtvQkFDVkMsUUFBUTtnQkFDVjtnQkFDQSxPQUFPO1lBQ1Q7WUFFQSxPQUFPUixXQUFXckIsV0FBVztRQUMvQixFQUFFLE9BQU8xRSxPQUFPO1lBQ2RxQyxRQUFRckMsS0FBSyxDQUFDLHFDQUFxQ0E7WUFDbkQsT0FBTztRQUNUO0lBQ0Y7SUFFQSxhQUFxQjJGLGdCQUFnQjdGLEtBQWEsRUFBaUQ7UUFDakcsSUFBSTtZQUNGLE1BQU04TCxhQUFhdE4seURBQUtBLENBQ3RCSCw4REFBVUEsQ0FBQ0gsNERBQUVBLElBQUksVUFDakJPLHlEQUFLQSxDQUFDLGVBQWUsTUFBTXVCO1lBRzdCLE1BQU1xSSxXQUFXLE1BQU0zSiwyREFBT0EsQ0FBQ29OO1lBRS9CLElBQUl6RCxTQUFTdkIsS0FBSyxFQUFFLE9BQU87WUFFM0IsTUFBTWlGLFdBQVcxRCxTQUFTckIsSUFBSSxDQUFDLEVBQUUsQ0FBQ2dDLElBQUk7WUFDdEMsT0FBTztnQkFDTDlFLEtBQUttRSxTQUFTckIsSUFBSSxDQUFDLEVBQUUsQ0FBQ08sRUFBRTtnQkFDeEJuQixNQUFNMkYsU0FBUzNGLElBQUksSUFBSTJGLFNBQVNDLFdBQVcsSUFBSTtZQUNqRDtRQUNGLEVBQUUsT0FBTzlMLE9BQU87WUFDZHFDLFFBQVFyQyxLQUFLLENBQUMsZ0NBQWdDQTtZQUM5QyxPQUFPO1FBQ1Q7SUFDRjtJQUVBLGFBQXFCeUgsZUFDbkJoRSxXQUF1RSxFQUN2RTFCLFNBQWlCLEVBQ0E7UUFDakIsSUFBSTtZQUNGLElBQUlzSixpQkFBaUI7WUFDckIsSUFBSVUsWUFBWTtZQUVoQixPQUFRdEk7Z0JBQ04sS0FBSztvQkFDSDRILGlCQUFpQjtvQkFDakI7Z0JBQ0YsS0FBSztvQkFDSEEsaUJBQWlCO29CQUNqQjtnQkFDRixLQUFLO29CQUNIQSxpQkFBaUI7b0JBQ2pCO2dCQUNGLEtBQUs7b0JBQ0hBLGlCQUFpQjtvQkFDakJVLFlBQVk7b0JBQ1o7Z0JBQ0YsS0FBSztvQkFDSFYsaUJBQWlCO29CQUNqQlUsWUFBWTtvQkFDWjtZQUNKO1lBRUEsTUFBTVIsYUFBYSxNQUFNck4sMERBQU1BLENBQUNELHVEQUFHQSxDQUFDRCw0REFBRUEsSUFBSXFOLGdCQUFnQnRKO1lBRTFELElBQUl3SixXQUFXZixNQUFNLElBQUk7Z0JBQ3ZCLE1BQU0xQixPQUFPeUMsV0FBV3pDLElBQUk7Z0JBQzVCLE9BQU9BLElBQUksQ0FBQ2lELFVBQVUsSUFBSSxHQUFrQmhLLE9BQWYwQixhQUFZLEtBQWEsT0FBVjFCO1lBQzlDO1lBRUEsT0FBTyxHQUFrQkEsT0FBZjBCLGFBQVksS0FBYSxPQUFWMUI7UUFDM0IsRUFBRSxPQUFPL0IsT0FBTztZQUNkcUMsUUFBUXJDLEtBQUssQ0FBQywrQkFBK0JBO1lBQzdDLE9BQU8sR0FBa0IrQixPQUFmMEIsYUFBWSxLQUFhLE9BQVYxQjtRQUMzQjtJQUNGO0lBRUEsYUFBcUI2SSx3QkFBd0J4SCxLQUFVLEVBQWlCO1FBQ3RFLElBQUk7WUFDRixNQUFNaEYsMERBQU1BLENBQUNELDhEQUFVQSxDQUFDSCw0REFBRUEsSUFBSSxtQkFBbUI7Z0JBQy9DLEdBQUdvRixLQUFLO2dCQUNSQyxXQUFXaEYsbUVBQWVBO2dCQUMxQjJOLFFBQVE7WUFDVjtRQUNGLEVBQUUsT0FBT2hNLE9BQU87WUFDZHFDLFFBQVFyQyxLQUFLLENBQUMsaUNBQWlDQTtRQUNqRDtJQUNGO0lBRUEsT0FBZW9FLG1CQUF1QztRQUNwRCxPQUFPO1lBQ0w0RyxTQUFTO1lBQ1RDLFNBQVM7WUFDVHZJLFdBQVc7WUFDWHdJLGlCQUFpQjtZQUNqQkMsa0JBQWtCO1lBQ2xCQyxXQUFXO1lBQ1gzSSxNQUFNO1FBQ1I7SUFDRjtJQUVBLE9BQWVxQiwwQkFBOEM7UUFDM0QsT0FBTztZQUNMa0gsU0FBUztZQUNUQyxTQUFTO1lBQ1R2SSxXQUFXO1lBQ1h3SSxpQkFBaUI7WUFDakJDLGtCQUFrQjtZQUNsQkMsV0FBVztZQUNYM0ksTUFBTTtRQUNSO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELGFBQWF3SixhQUFhaEwsTUFBYyxFQUFFaUwsU0FBaUIsRUFBb0I7UUFDN0UsSUFBSSxDQUFDeE0sZUFBZXNLLEdBQUcsQ0FBQy9JLFNBQVM7WUFDL0J2QixlQUFlbUMsR0FBRyxDQUFDWixRQUFRLElBQUk0STtRQUNqQztRQUVBLE1BQU1zQyxlQUFlek0sZUFBZTZCLEdBQUcsQ0FBQ047UUFFeEMsSUFBSWtMLGFBQWEvSixJQUFJLElBQUl4RCxnQkFBZ0JPLHFCQUFxQixFQUFFO1lBQzlELE1BQU0sSUFBSSxDQUFDZ0UsZ0JBQWdCLENBQUM7Z0JBQzFCUSxNQUFNO2dCQUNOMUM7Z0JBQ0F3QyxhQUFhO2dCQUNiMUIsV0FBVztnQkFDWDZCLFNBQVM7b0JBQUVzSTtvQkFBV0UsYUFBYUQsYUFBYS9KLElBQUk7Z0JBQUM7WUFDdkQ7WUFDQSxPQUFPO1FBQ1Q7UUFFQStKLGFBQWFsQyxHQUFHLENBQUNpQztRQUNqQixPQUFPO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELGFBQWF4SSxzQkFBc0J6QyxNQUFjLEVBQW9CO1FBQ25FLElBQUksQ0FBQ3RCLGVBQWVxSyxHQUFHLENBQUMvSSxTQUFTO1lBQy9CdEIsZUFBZWtDLEdBQUcsQ0FBQ1osUUFBUTtnQkFBRU8sT0FBTztnQkFBRzZLLGFBQWFsTCxLQUFLRCxHQUFHO1lBQUc7WUFDL0QsT0FBTztRQUNUO1FBRUEsTUFBTW9MLFdBQVczTSxlQUFlNEIsR0FBRyxDQUFDTjtRQUNwQyxNQUFNQyxNQUFNQyxLQUFLRCxHQUFHO1FBRXBCLHVDQUF1QztRQUN2QyxJQUFJQSxNQUFNb0wsU0FBU0QsV0FBVyxHQUFHek4sZ0JBQWdCVSxlQUFlLEdBQUcsTUFBTTtZQUN2RUssZUFBZWtDLEdBQUcsQ0FBQ1osUUFBUTtnQkFBRU8sT0FBTztnQkFBRzZLLGFBQWFuTDtZQUFJO1lBQ3hELE9BQU87UUFDVDtRQUVBLElBQUlvTCxTQUFTOUssS0FBSyxJQUFJNUMsZ0JBQWdCUyxpQkFBaUIsRUFBRTtZQUN2RCxNQUFNLElBQUksQ0FBQzhELGdCQUFnQixDQUFDO2dCQUMxQlEsTUFBTTtnQkFDTjFDO2dCQUNBd0MsYUFBYTtnQkFDYjFCLFdBQVc7Z0JBQ1g2QixTQUFTO29CQUFFakUsZ0JBQWdCMk0sU0FBUzlLLEtBQUs7Z0JBQUM7WUFDNUM7WUFDQSxPQUFPO1FBQ1Q7UUFFQSxPQUFPO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELE9BQU95QyxvQkFBb0JoRCxNQUFjLEVBQVE7UUFDL0MsTUFBTXFMLFdBQVczTSxlQUFlNEIsR0FBRyxDQUFDTixXQUFXO1lBQUVPLE9BQU87WUFBRzZLLGFBQWFsTCxLQUFLRCxHQUFHO1FBQUc7UUFDbkZvTCxTQUFTOUssS0FBSztRQUNkOEssU0FBU0QsV0FBVyxHQUFHbEwsS0FBS0QsR0FBRztRQUMvQnZCLGVBQWVrQyxHQUFHLENBQUNaLFFBQVFxTDtJQUM3QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zaGFyZWQvdXRpbHMvc2VjdXJpdHkvY29udGVudFNoYXJpbmdTZWN1cml0eS50cz85OTNjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRiIH0gZnJvbSAnQC9pbmZyYXN0cnVjdHVyZS9maXJlYmFzZSc7XG5pbXBvcnQgeyBkb2MsIGdldERvYywgY29sbGVjdGlvbiwgYWRkRG9jLCBzZXJ2ZXJUaW1lc3RhbXAsIHF1ZXJ5LCB3aGVyZSwgZ2V0RG9jcywgdXBkYXRlRG9jLCBkZWxldGVEb2MsIHdyaXRlQmF0Y2ggfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xuaW1wb3J0IHsgZ2V0QXV0aCB9IGZyb20gJ2ZpcmViYXNlL2F1dGgnO1xuXG4vLyBTZWN1cml0eSBDb25zdGFudHNcbmNvbnN0IFNFQ1VSSVRZX0xJTUlUUyA9IHtcbiAgbWF4U2hhcmVzUGVyQ29udGVudDogMTAwLFxuICBtYXhTaGFyZXNQZXJVc2VyOiAxMDAwLFxuICBtYXhJbnZpdGF0aW9uc1BlckhvdXI6IDEwLFxuICBtYXhJbnZpdGF0aW9uc1BlckRheTogNTAsXG4gIG1heE1lc3NhZ2VMZW5ndGg6IDUwMCxcbiAgbWF4UGhvbmVMZW5ndGg6IDIwLFxuICAvLyBBZGQgbmV3IHNlY3VyaXR5IGxpbWl0c1xuICBtYXhDb25jdXJyZW50U2Vzc2lvbnM6IDUsXG4gIGFjY2Vzc1Rva2VuRXhwaXJ5OiAzNjAwLCAvLyAxIGhvdXIgaW4gc2Vjb25kc1xuICBtYXhGYWlsZWRBdHRlbXB0czogNSxcbiAgbG9ja291dER1cmF0aW9uOiA5MDAsIC8vIDE1IG1pbnV0ZXMgaW4gc2Vjb25kc1xuICBtaW5QYXNzd29yZExlbmd0aDogOFxufTtcblxuLy8gUmF0ZSBsaW1pdGluZyBzdG9yYWdlXG5jb25zdCBpbnZpdGF0aW9uUmF0ZUxpbWl0ID0gbmV3IE1hcDxzdHJpbmcsIHsgY291bnQ6IG51bWJlcjsgbGFzdFJlc2V0OiBudW1iZXI7IGRhaWx5Q291bnQ6IG51bWJlcjsgZGFpbHlSZXNldDogbnVtYmVyIH0+KCk7XG5cbi8vIEFkZCBzZXNzaW9uIHRyYWNraW5nXG5jb25zdCBhY3RpdmVTZXNzaW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj4oKTtcbmNvbnN0IGZhaWxlZEF0dGVtcHRzID0gbmV3IE1hcDxzdHJpbmcsIHsgY291bnQ6IG51bWJlcjsgbGFzdEF0dGVtcHQ6IG51bWJlciB9PigpO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRlbnRQZXJtaXNzaW9ucyB7XG4gIGNhblZpZXc6IGJvb2xlYW47XG4gIGNhbkVkaXQ6IGJvb2xlYW47XG4gIGNhbk1hbmFnZTogYm9vbGVhbjtcbiAgY2FuSW52aXRlT3RoZXJzOiBib29sZWFuO1xuICBjYW5WaWV3QW5hbHl0aWNzOiBib29sZWFuO1xuICBjYW5EZWxldGU6IGJvb2xlYW47XG4gIHJvbGU6ICdvd25lcicgfCAnYWRtaW4nIHwgJ2VkaXRvcicgfCAndmlld2VyJyB8ICd1bmF1dGhvcml6ZWQnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRlbnRTaGFyZUFzc2lnbm1lbnQge1xuICBpZD86IHN0cmluZztcbiAgY29udGVudFR5cGU6ICdhcnRpc3QnIHwgJ29yZ2FuaXphdGlvbicgfCAndmVudWUnIHwgJ2V2ZW50JyB8ICdhY3Rpdml0eSc7XG4gIGNvbnRlbnRJZDogc3RyaW5nO1xuICB1c2VySWQ6IHN0cmluZztcbiAgdXNlclBob25lOiBzdHJpbmc7XG4gIHVzZXJOYW1lOiBzdHJpbmc7XG4gIHBlcm1pc3Npb25zOiBDb250ZW50UGVybWlzc2lvbnM7XG4gIGFzc2lnbmVkQnk6IHN0cmluZztcbiAgYXNzaWduZWRCeU5hbWU6IHN0cmluZztcbiAgYXNzaWduZWRBdDogc3RyaW5nO1xuICBleHBpcmVzQXQ/OiBzdHJpbmc7XG4gIGlzQWN0aXZlOiBib29sZWFuO1xuICBzdGF0dXM6ICdhY3RpdmUnIHwgJ3BlbmRpbmcnIHwgJ2RlY2xpbmVkJyB8ICdleHBpcmVkJztcbiAgbm90ZXM6IHN0cmluZzsgLy8gQWx3YXlzIHN0cmluZywgZW1wdHkgc3RyaW5nIGlmIG5vIG5vdGVzXG4gIGludml0YXRpb25NZXNzYWdlOiBzdHJpbmc7IC8vIEFsd2F5cyBzdHJpbmcsIGVtcHR5IHN0cmluZyBpZiBubyBtZXNzYWdlXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudEludml0YXRpb24ge1xuICBpZD86IHN0cmluZztcbiAgY29udGVudFR5cGU6ICdhcnRpc3QnIHwgJ29yZ2FuaXphdGlvbicgfCAndmVudWUnIHwgJ2V2ZW50JyB8ICdhY3Rpdml0eSc7XG4gIGNvbnRlbnRJZDogc3RyaW5nO1xuICBjb250ZW50TmFtZTogc3RyaW5nO1xuICBpbnZpdGVkUGhvbmU6IHN0cmluZztcbiAgaW52aXRlZFVzZXJJZD86IHN0cmluZztcbiAgaW52aXRlZEJ5VXNlcklkOiBzdHJpbmc7XG4gIGludml0ZWRCeU5hbWU6IHN0cmluZztcbiAgcGVybWlzc2lvbnM6IENvbnRlbnRQZXJtaXNzaW9ucztcbiAgbWVzc2FnZTogc3RyaW5nOyAvLyBBbHdheXMgc3RyaW5nLCBlbXB0eSBzdHJpbmcgaWYgbm8gbWVzc2FnZVxuICBzdGF0dXM6ICdwZW5kaW5nJyB8ICdhY2NlcHRlZCcgfCAnZGVjbGluZWQnIHwgJ2V4cGlyZWQnO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgcmVzcG9uZGVkQXQ/OiBzdHJpbmc7XG4gIGV4cGlyZXNBdDogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ29udGVudFNoYXJpbmdTZWN1cml0eSB7XG4gIFxuICAvKipcbiAgICogRW5oYW5jZWQgcGhvbmUgbnVtYmVyIHZhbGlkYXRpb24gd2l0aCBpbnRlcm5hdGlvbmFsIGZvcm1hdCBzdXBwb3J0XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVQaG9uZU51bWJlcihwaG9uZTogc3RyaW5nKTogeyBpc1ZhbGlkOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9IHtcbiAgICBpZiAoIXBob25lIHx8IHR5cGVvZiBwaG9uZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogJ1Bob25lIG51bWJlciBpcyByZXF1aXJlZCcgfTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIG5vbi1kaWdpdCBjaGFyYWN0ZXJzIGV4Y2VwdCArXG4gICAgY29uc3QgY2xlYW5lZCA9IHBob25lLnJlcGxhY2UoL1teXFxkK10vZywgJycpO1xuICAgIFxuICAgIC8vIENoZWNrIGxlbmd0aCBsaW1pdHNcbiAgICBpZiAoY2xlYW5lZC5sZW5ndGggPiBTRUNVUklUWV9MSU1JVFMubWF4UGhvbmVMZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogJ1Bob25lIG51bWJlciB0b28gbG9uZycgfTtcbiAgICB9XG5cbiAgICAvLyBNdXN0IHN0YXJ0IHdpdGggKyBhbmQgaGF2ZSAxMC0xNSBkaWdpdHNcbiAgICBjb25zdCBwaG9uZVJlZ2V4ID0gL15cXCtbMS05XVxcZHs5LDE0fSQvO1xuICAgIGlmICghcGhvbmVSZWdleC50ZXN0KGNsZWFuZWQpKSB7XG4gICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIHBob25lIG51bWJlciBmb3JtYXQuIFVzZSArW2NvdW50cnkgY29kZV1bbnVtYmVyXScgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG4gIH1cblxuICAvKipcbiAgICogSW5wdXQgc2FuaXRpemF0aW9uIGZvciBtZXNzYWdlcyBhbmQgdGV4dCBpbnB1dHNcbiAgICovXG4gIHN0YXRpYyBzYW5pdGl6ZUlucHV0KGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykgcmV0dXJuICcnO1xuICAgIFxuICAgIHJldHVybiBpbnB1dFxuICAgICAgLnRyaW0oKVxuICAgICAgLnJlcGxhY2UoLzxzY3JpcHRcXGJbXjxdKig/Oig/ITxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcL3NjcmlwdD4vZ2ksICcnKSAvLyBSZW1vdmUgc2NyaXB0c1xuICAgICAgLnJlcGxhY2UoL1s8PidcIl0vZywgJycpIC8vIFJlbW92ZSBIVE1ML1hNTCBjaGFyc1xuICAgICAgLnJlcGxhY2UoL2phdmFzY3JpcHQ6L2dpLCAnJykgLy8gUmVtb3ZlIGphdmFzY3JpcHQ6IHVybHNcbiAgICAgIC5yZXBsYWNlKC9kYXRhOi9naSwgJycpIC8vIFJlbW92ZSBkYXRhOiB1cmxzXG4gICAgICAuc3Vic3RyaW5nKDAsIFNFQ1VSSVRZX0xJTUlUUy5tYXhNZXNzYWdlTGVuZ3RoKTsgLy8gTGltaXQgbGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgaW52aXRhdGlvbiBtZXNzYWdlIGZvciBzdXNwaWNpb3VzIGNvbnRlbnRcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZU1lc3NhZ2UobWVzc2FnZTogc3RyaW5nKTogeyBpc1ZhbGlkOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9IHtcbiAgICBpZiAoIW1lc3NhZ2UgfHwgbWVzc2FnZS50cmltKCkgPT09ICcnKSByZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07IC8vIEVtcHR5IG1lc3NhZ2UgaXMgb2theVxuXG4gICAgY29uc3Qgc2FuaXRpemVkID0gdGhpcy5zYW5pdGl6ZUlucHV0KG1lc3NhZ2UpO1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBzdXNwaWNpb3VzIHBhdHRlcm5zXG4gICAgY29uc3Qgc3VzcGljaW91c1BhdHRlcm5zID0gW1xuICAgICAgL3Zic2NyaXB0Oi9pLFxuICAgICAgLzxpZnJhbWUvaSxcbiAgICAgIC88b2JqZWN0L2ksXG4gICAgICAvPGVtYmVkL2ksXG4gICAgICAvZXZhbFxcKC9pLFxuICAgICAgL2RvY3VtZW50XFwuL2ksXG4gICAgICAvd2luZG93XFwuL2lcbiAgICBdO1xuICAgIFxuICAgIGlmIChzdXNwaWNpb3VzUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChzYW5pdGl6ZWQpKSkge1xuICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiAnTWVzc2FnZSBjb250YWlucyBzdXNwaWNpb3VzIGNvbnRlbnQnIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHJhdGUgbGltaXRzIGZvciBpbnZpdGF0aW9uc1xuICAgKi9cbiAgc3RhdGljIGNoZWNrSW52aXRhdGlvblJhdGVMaW1pdCh1c2VySWQ6IHN0cmluZyk6IHsgYWxsb3dlZDogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBob3VyTXMgPSA2MCAqIDYwICogMTAwMDtcbiAgICBjb25zdCBkYXlNcyA9IDI0ICogaG91ck1zO1xuICAgIFxuICAgIGNvbnN0IHVzZXJMaW1pdHMgPSBpbnZpdGF0aW9uUmF0ZUxpbWl0LmdldCh1c2VySWQpIHx8IHtcbiAgICAgIGNvdW50OiAwLFxuICAgICAgbGFzdFJlc2V0OiBub3csXG4gICAgICBkYWlseUNvdW50OiAwLFxuICAgICAgZGFpbHlSZXNldDogbm93XG4gICAgfTtcblxuICAgIC8vIFJlc2V0IGhvdXJseSBjb3VudGVyIGlmIG5lZWRlZFxuICAgIGlmIChub3cgLSB1c2VyTGltaXRzLmxhc3RSZXNldCA+IGhvdXJNcykge1xuICAgICAgdXNlckxpbWl0cy5jb3VudCA9IDA7XG4gICAgICB1c2VyTGltaXRzLmxhc3RSZXNldCA9IG5vdztcbiAgICB9XG5cbiAgICAvLyBSZXNldCBkYWlseSBjb3VudGVyIGlmIG5lZWRlZFxuICAgIGlmIChub3cgLSB1c2VyTGltaXRzLmRhaWx5UmVzZXQgPiBkYXlNcykge1xuICAgICAgdXNlckxpbWl0cy5kYWlseUNvdW50ID0gMDtcbiAgICAgIHVzZXJMaW1pdHMuZGFpbHlSZXNldCA9IG5vdztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBsaW1pdHNcbiAgICBpZiAodXNlckxpbWl0cy5jb3VudCA+PSBTRUNVUklUWV9MSU1JVFMubWF4SW52aXRhdGlvbnNQZXJIb3VyKSB7XG4gICAgICByZXR1cm4geyBhbGxvd2VkOiBmYWxzZSwgZXJyb3I6ICdUb28gbWFueSBpbnZpdGF0aW9ucyBzZW50IHRoaXMgaG91ci4gUGxlYXNlIHdhaXQuJyB9O1xuICAgIH1cblxuICAgIGlmICh1c2VyTGltaXRzLmRhaWx5Q291bnQgPj0gU0VDVVJJVFlfTElNSVRTLm1heEludml0YXRpb25zUGVyRGF5KSB7XG4gICAgICByZXR1cm4geyBhbGxvd2VkOiBmYWxzZSwgZXJyb3I6ICdEYWlseSBpbnZpdGF0aW9uIGxpbWl0IHJlYWNoZWQuIFBsZWFzZSB0cnkgYWdhaW4gdG9tb3Jyb3cuJyB9O1xuICAgIH1cblxuICAgIC8vIEluY3JlbWVudCBjb3VudGVyc1xuICAgIHVzZXJMaW1pdHMuY291bnQrKztcbiAgICB1c2VyTGltaXRzLmRhaWx5Q291bnQrKztcbiAgICBpbnZpdGF0aW9uUmF0ZUxpbWl0LnNldCh1c2VySWQsIHVzZXJMaW1pdHMpO1xuXG4gICAgcmV0dXJuIHsgYWxsb3dlZDogdHJ1ZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHJlc291cmNlIGxpbWl0cyAobWF4IHNoYXJlcyBwZXIgdXNlci9jb250ZW50KVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNoZWNrUmVzb3VyY2VMaW1pdHModXNlcklkOiBzdHJpbmcsIGNvbnRlbnRJZDogc3RyaW5nKTogUHJvbWlzZTx7IGFsbG93ZWQ6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW3VzZXJTaGFyZXMsIGNvbnRlbnRTaGFyZXNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZXREb2NzKHF1ZXJ5KFxuICAgICAgICAgIGNvbGxlY3Rpb24oZGIoKSwgJ2NvbnRlbnRTaGFyaW5nJyksXG4gICAgICAgICAgd2hlcmUoJ2Fzc2lnbmVkQnknLCAnPT0nLCB1c2VySWQpLFxuICAgICAgICAgIHdoZXJlKCdpc0FjdGl2ZScsICc9PScsIHRydWUpXG4gICAgICAgICkpLFxuICAgICAgICBnZXREb2NzKHF1ZXJ5KFxuICAgICAgICAgIGNvbGxlY3Rpb24oZGIoKSwgJ2NvbnRlbnRTaGFyaW5nJyksXG4gICAgICAgICAgd2hlcmUoJ2NvbnRlbnRJZCcsICc9PScsIGNvbnRlbnRJZCksXG4gICAgICAgICAgd2hlcmUoJ2lzQWN0aXZlJywgJz09JywgdHJ1ZSlcbiAgICAgICAgKSlcbiAgICAgIF0pO1xuXG4gICAgICBpZiAodXNlclNoYXJlcy5zaXplID49IFNFQ1VSSVRZX0xJTUlUUy5tYXhTaGFyZXNQZXJVc2VyKSB7XG4gICAgICAgIHJldHVybiB7IGFsbG93ZWQ6IGZhbHNlLCBlcnJvcjogJ01heGltdW0gc2hhcmVzIHBlciB1c2VyIGV4Y2VlZGVkJyB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudFNoYXJlcy5zaXplID49IFNFQ1VSSVRZX0xJTUlUUy5tYXhTaGFyZXNQZXJDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB7IGFsbG93ZWQ6IGZhbHNlLCBlcnJvcjogJ01heGltdW0gc2hhcmVzIGZvciB0aGlzIGNvbnRlbnQgZXhjZWVkZWQnIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGFsbG93ZWQ6IHRydWUgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgcmVzb3VyY2UgbGltaXRzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IGFsbG93ZWQ6IGZhbHNlLCBlcnJvcjogJ1VuYWJsZSB0byB2ZXJpZnkgcmVzb3VyY2UgbGltaXRzJyB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbmhhbmNlZCBwZXJtaXNzaW9uIHZhbGlkYXRpb25cbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZVBlcm1pc3Npb25DaGFuZ2UoXG4gICAgY3VycmVudFBlcm1pc3Npb25zOiBDb250ZW50UGVybWlzc2lvbnMsXG4gICAgbmV3UGVybWlzc2lvbnM6IENvbnRlbnRQZXJtaXNzaW9uc1xuICApOiB7IGlzVmFsaWQ6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0ge1xuICAgIC8vIE9ubHkgb3duZXJzIGNhbiBncmFudCBhZG1pbiBwZXJtaXNzaW9uc1xuICAgIGlmIChuZXdQZXJtaXNzaW9ucy5yb2xlID09PSAnYWRtaW4nICYmIGN1cnJlbnRQZXJtaXNzaW9ucy5yb2xlICE9PSAnb3duZXInKSB7XG4gICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6ICdPbmx5IG93bmVycyBjYW4gZ3JhbnQgYWRtaW4gcGVybWlzc2lvbnMnIH07XG4gICAgfVxuXG4gICAgLy8gT25seSBhZG1pbnMgYW5kIG93bmVycyBjYW4gbWFuYWdlIHBlcm1pc3Npb25zXG4gICAgaWYgKCFjdXJyZW50UGVybWlzc2lvbnMuY2FuTWFuYWdlICYmIGN1cnJlbnRQZXJtaXNzaW9ucy5yb2xlICE9PSAnb3duZXInKSB7XG4gICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6ICdJbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMgdG8gbWFuYWdlIGFjY2VzcycgfTtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IHJvbGUgZXNjYWxhdGlvbiBiZXlvbmQgY3VycmVudCB1c2VyJ3MgbGV2ZWxcbiAgICBjb25zdCByb2xlSGllcmFyY2h5OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0geyB2aWV3ZXI6IDEsIGVkaXRvcjogMiwgYWRtaW46IDMsIG93bmVyOiA0LCB1bmF1dGhvcml6ZWQ6IDAgfTtcbiAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSByb2xlSGllcmFyY2h5W2N1cnJlbnRQZXJtaXNzaW9ucy5yb2xlXSB8fCAwO1xuICAgIGNvbnN0IG5ld0xldmVsID0gcm9sZUhpZXJhcmNoeVtuZXdQZXJtaXNzaW9ucy5yb2xlXSB8fCAwO1xuXG4gICAgaWYgKG5ld0xldmVsID4gY3VycmVudExldmVsKSB7XG4gICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6ICdDYW5ub3QgZ3JhbnQgcGVybWlzc2lvbnMgaGlnaGVyIHRoYW4geW91ciBvd24nIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIExvZyBzZWN1cml0eSBldmVudHMgZm9yIG1vbml0b3JpbmdcbiAgICovXG4gIHN0YXRpYyBhc3luYyBsb2dTZWN1cml0eUV2ZW50KGV2ZW50OiB7XG4gICAgdHlwZTogJ2FjY2Vzc19ncmFudGVkJyB8ICdhY2Nlc3NfZGVuaWVkJyB8ICdwZXJtaXNzaW9uX2NoYW5nZScgfCAnc3VzcGljaW91c19hY3Rpdml0eScgfCAnc2Vzc2lvbl9saW1pdF9leGNlZWRlZCcgfCAnYWNjb3VudF9sb2Nrb3V0JztcbiAgICB1c2VySWQ6IHN0cmluZztcbiAgICBjb250ZW50VHlwZTogc3RyaW5nO1xuICAgIGNvbnRlbnRJZDogc3RyaW5nO1xuICAgIGRldGFpbHM6IGFueTtcbiAgfSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYigpLCAnc2VjdXJpdHlMb2dzJyksIHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIHRpbWVzdGFtcDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICAgIHVzZXJBZ2VudDogdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50IDogJ3Vua25vd24nXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvZyBzZWN1cml0eSBldmVudDonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBpZiBhIHVzZXIgaGFzIGFjY2VzcyB0byBzcGVjaWZpYyBjb250ZW50XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdmVyaWZ5Q29udGVudEFjY2VzcyhcbiAgICBjb250ZW50VHlwZTogJ2FydGlzdCcgfCAnb3JnYW5pemF0aW9uJyB8ICd2ZW51ZScgfCAnZXZlbnQnIHwgJ2FjdGl2aXR5JyxcbiAgICBjb250ZW50SWQ6IHN0cmluZyxcbiAgICB1c2VySWQ6IHN0cmluZ1xuICApOiBQcm9taXNlPENvbnRlbnRQZXJtaXNzaW9ucz4ge1xuICAgIC8vIEFkZCBicnV0ZSBmb3JjZSBwcm90ZWN0aW9uXG4gICAgaWYgKCEoYXdhaXQgdGhpcy52YWxpZGF0ZUFjY2Vzc0F0dGVtcHQodXNlcklkKSkpIHtcbiAgICAgIGF3YWl0IHRoaXMubG9nU2VjdXJpdHlFdmVudCh7XG4gICAgICAgIHR5cGU6ICdhY2Nlc3NfZGVuaWVkJyxcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgY29udGVudElkLFxuICAgICAgICBkZXRhaWxzOiB7IHJlYXNvbjogJ0FjY291bnQgdGVtcG9yYXJpbHkgbG9ja2VkIGR1ZSB0byB0b28gbWFueSBmYWlsZWQgYXR0ZW1wdHMnIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMudW5hdXRob3JpemVkUGVybWlzc2lvbnMoKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50VXNlciA9IGdldEF1dGgoKS5jdXJyZW50VXNlcjtcbiAgICBpZiAoIWN1cnJlbnRVc2VyIHx8IGN1cnJlbnRVc2VyLnVpZCAhPT0gdXNlcklkKSB7XG4gICAgICB0aGlzLnJlY29yZEZhaWxlZEF0dGVtcHQodXNlcklkKTtcbiAgICAgIHJldHVybiB0aGlzLnVuYXV0aG9yaXplZFBlcm1pc3Npb25zKCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHVzZXIgaXMgdGhlIG93bmVyXG4gICAgICBjb25zdCBpc093bmVyID0gYXdhaXQgdGhpcy5jaGVja0NvbnRlbnRPd25lcnNoaXAoY29udGVudFR5cGUsIGNvbnRlbnRJZCwgdXNlcklkKTtcbiAgICAgIGlmIChpc093bmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm93bmVyUGVybWlzc2lvbnMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIHNoYXJlZCBhY2Nlc3MgcGVybWlzc2lvbnNcbiAgICAgIGNvbnN0IHNoYXJlZFBlcm1pc3Npb25zID0gYXdhaXQgdGhpcy5nZXRTaGFyZWRQZXJtaXNzaW9ucyhjb250ZW50VHlwZSwgY29udGVudElkLCB1c2VySWQpO1xuICAgICAgaWYgKHNoYXJlZFBlcm1pc3Npb25zKSB7XG4gICAgICAgIHJldHVybiBzaGFyZWRQZXJtaXNzaW9ucztcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWNvcmRGYWlsZWRBdHRlbXB0KHVzZXJJZCk7XG4gICAgICByZXR1cm4gdGhpcy51bmF1dGhvcml6ZWRQZXJtaXNzaW9ucygpO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBjb250ZW50IGFjY2VzczonLCBlcnJvcik7XG4gICAgICB0aGlzLnJlY29yZEZhaWxlZEF0dGVtcHQodXNlcklkKTtcbiAgICAgIHJldHVybiB0aGlzLnVuYXV0aG9yaXplZFBlcm1pc3Npb25zKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNoYXJlIGNvbnRlbnQgd2l0aCBhbm90aGVyIHVzZXJcbiAgICovXG4gIHN0YXRpYyBhc3luYyBzaGFyZUNvbnRlbnQoXG4gICAgY29udGVudFR5cGU6ICdhcnRpc3QnIHwgJ29yZ2FuaXphdGlvbicgfCAndmVudWUnIHwgJ2V2ZW50JyB8ICdhY3Rpdml0eScsXG4gICAgY29udGVudElkOiBzdHJpbmcsXG4gICAgdGFyZ2V0VXNlclBob25lOiBzdHJpbmcsXG4gICAgdGFyZ2V0VXNlck5hbWU6IHN0cmluZyxcbiAgICBwZXJtaXNzaW9uczogQ29udGVudFBlcm1pc3Npb25zLFxuICAgIHNoYXJlZEJ5VXNlcklkOiBzdHJpbmcsXG4gICAgc2hhcmVkQnlOYW1lOiBzdHJpbmcsXG4gICAgZXhwaXJlc0luSG91cnM/OiBudW1iZXIsXG4gICAgbWVzc2FnZT86IHN0cmluZ1xuICApOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgYXNzaWdubWVudElkPzogc3RyaW5nOyBpbnZpdGF0aW9uSWQ/OiBzdHJpbmc7IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gMS4gVmFsaWRhdGUgcGhvbmUgbnVtYmVyXG4gICAgICBjb25zdCBwaG9uZVZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlUGhvbmVOdW1iZXIodGFyZ2V0VXNlclBob25lKTtcbiAgICAgIGlmICghcGhvbmVWYWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2dTZWN1cml0eUV2ZW50KHtcbiAgICAgICAgICB0eXBlOiAnc3VzcGljaW91c19hY3Rpdml0eScsXG4gICAgICAgICAgdXNlcklkOiBzaGFyZWRCeVVzZXJJZCxcbiAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICBjb250ZW50SWQsXG4gICAgICAgICAgZGV0YWlsczogeyByZWFzb246ICdJbnZhbGlkIHBob25lIG51bWJlcicsIHBob25lOiB0YXJnZXRVc2VyUGhvbmUgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBwaG9uZVZhbGlkYXRpb24uZXJyb3IgfTtcbiAgICAgIH1cblxuICAgICAgLy8gMi4gVmFsaWRhdGUgbWVzc2FnZSBjb250ZW50XG4gICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlVmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICBpZiAoIW1lc3NhZ2VWYWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmxvZ1NlY3VyaXR5RXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ3N1c3BpY2lvdXNfYWN0aXZpdHknLFxuICAgICAgICAgICAgdXNlcklkOiBzaGFyZWRCeVVzZXJJZCxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgY29udGVudElkLFxuICAgICAgICAgICAgZGV0YWlsczogeyByZWFzb246ICdTdXNwaWNpb3VzIG1lc3NhZ2UgY29udGVudCcsIG1lc3NhZ2UgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogbWVzc2FnZVZhbGlkYXRpb24uZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBDaGVjayByYXRlIGxpbWl0c1xuICAgICAgY29uc3QgcmF0ZUxpbWl0Q2hlY2sgPSB0aGlzLmNoZWNrSW52aXRhdGlvblJhdGVMaW1pdChzaGFyZWRCeVVzZXJJZCk7XG4gICAgICBpZiAoIXJhdGVMaW1pdENoZWNrLmFsbG93ZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByYXRlTGltaXRDaGVjay5lcnJvciB9O1xuICAgICAgfVxuXG4gICAgICAvLyA0LiBDaGVjayByZXNvdXJjZSBsaW1pdHNcbiAgICAgIGNvbnN0IHJlc291cmNlQ2hlY2sgPSBhd2FpdCB0aGlzLmNoZWNrUmVzb3VyY2VMaW1pdHMoc2hhcmVkQnlVc2VySWQsIGNvbnRlbnRJZCk7XG4gICAgICBpZiAoIXJlc291cmNlQ2hlY2suYWxsb3dlZCkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHJlc291cmNlQ2hlY2suZXJyb3IgfTtcbiAgICAgIH1cblxuICAgICAgLy8gNS4gVmVyaWZ5IHRoZSBzaGFyZXIgaGFzIHBlcm1pc3Npb24gdG8gc2hhcmUgLSBPTkxZIE9XTkVSUyBDQU4gU0hBUkVcbiAgICAgIGNvbnN0IHNoYXJlclBlcm1pc3Npb25zID0gYXdhaXQgdGhpcy52ZXJpZnlDb250ZW50QWNjZXNzKGNvbnRlbnRUeXBlLCBjb250ZW50SWQsIHNoYXJlZEJ5VXNlcklkKTtcbiAgICAgIFxuICAgICAgLy8g8J+aqCBFTkhBTkNFRDogT25seSBwYWdlIG93bmVycyBjYW4gZ3JhbnQgYWNjZXNzIHRvIG90aGVyc1xuICAgICAgaWYgKHNoYXJlclBlcm1pc3Npb25zLnJvbGUgIT09ICdvd25lcicpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2dTZWN1cml0eUV2ZW50KHtcbiAgICAgICAgICB0eXBlOiAnYWNjZXNzX2RlbmllZCcsXG4gICAgICAgICAgdXNlcklkOiBzaGFyZWRCeVVzZXJJZCxcbiAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICBjb250ZW50SWQsXG4gICAgICAgICAgZGV0YWlsczogeyBcbiAgICAgICAgICAgIHJlYXNvbjogJ09ubHkgcGFnZSBvd25lcnMgY2FuIGdyYW50IGFjY2VzcyB0byBvdGhlcnMnLCBcbiAgICAgICAgICAgIHVzZXJSb2xlOiBzaGFyZXJQZXJtaXNzaW9ucy5yb2xlLFxuICAgICAgICAgICAgcmVxdWlyZWRSb2xlOiAnb3duZXInXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgIGVycm9yOiAnT25seSBwYWdlIG93bmVycyBjYW4gZ3JhbnQgYWNjZXNzIHRvIG90aGVycy4gWW91IGhhdmUgJyArIHNoYXJlclBlcm1pc3Npb25zLnJvbGUgKyAnIGFjY2Vzcy4nIFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyA2LiBWYWxpZGF0ZSBwZXJtaXNzaW9uIGxldmVsXG4gICAgICBjb25zdCBwZXJtaXNzaW9uVmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVQZXJtaXNzaW9uQ2hhbmdlKHNoYXJlclBlcm1pc3Npb25zLCBwZXJtaXNzaW9ucyk7XG4gICAgICBpZiAoIXBlcm1pc3Npb25WYWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBwZXJtaXNzaW9uVmFsaWRhdGlvbi5lcnJvciB9O1xuICAgICAgfVxuXG4gICAgICAvLyA3LiBTYW5pdGl6ZSBpbnB1dHNcbiAgICAgIGNvbnN0IHNhbml0aXplZE1lc3NhZ2UgPSBtZXNzYWdlID8gdGhpcy5zYW5pdGl6ZUlucHV0KG1lc3NhZ2UpIDogJyc7XG4gICAgICBjb25zdCBzYW5pdGl6ZWRUYXJnZXROYW1lID0gdGhpcy5zYW5pdGl6ZUlucHV0KHRhcmdldFVzZXJOYW1lKTtcbiAgICAgIGNvbnN0IHNhbml0aXplZFBob25lID0gdGFyZ2V0VXNlclBob25lLnJlcGxhY2UoL1teXFxkK10vZywgJycpOyAvLyBDbGVhbiBwaG9uZSBudW1iZXJcblxuICAgICAgLy8gOC4gQ2hlY2sgaWYgdGFyZ2V0IHVzZXIgZXhpc3RzXG4gICAgICBjb25zdCB0YXJnZXRVc2VyID0gYXdhaXQgdGhpcy5maW5kVXNlckJ5UGhvbmUoc2FuaXRpemVkUGhvbmUpO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gZXhwaXJlc0luSG91cnMgPyBuZXcgRGF0ZShEYXRlLm5vdygpICsgZXhwaXJlc0luSG91cnMgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHRhcmdldFVzZXIpIHtcbiAgICAgICAgLy8gVXNlciBleGlzdHMsIGNyZWF0ZSBkaXJlY3QgYXNzaWdubWVudFxuICAgICAgICBjb25zdCBhc3NpZ25tZW50OiBDb250ZW50U2hhcmVBc3NpZ25tZW50ID0ge1xuICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgIGNvbnRlbnRJZCxcbiAgICAgICAgICB1c2VySWQ6IHRhcmdldFVzZXIudWlkLFxuICAgICAgICAgIHVzZXJQaG9uZTogc2FuaXRpemVkUGhvbmUsXG4gICAgICAgICAgdXNlck5hbWU6IHNhbml0aXplZFRhcmdldE5hbWUgfHwgdGFyZ2V0VXNlci5uYW1lIHx8ICdFZGl0b3InLFxuICAgICAgICAgIHBlcm1pc3Npb25zLFxuICAgICAgICAgIGFzc2lnbmVkQnk6IHNoYXJlZEJ5VXNlcklkLFxuICAgICAgICAgIGFzc2lnbmVkQnlOYW1lOiBzaGFyZWRCeU5hbWUsXG4gICAgICAgICAgYXNzaWduZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGV4cGlyZXNBdCxcbiAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICAgIG5vdGVzOiBzYW5pdGl6ZWRNZXNzYWdlLFxuICAgICAgICAgIGludml0YXRpb25NZXNzYWdlOiBzYW5pdGl6ZWRNZXNzYWdlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciBhbHJlYWR5IGhhcyBhY2Nlc3NcbiAgICAgICAgY29uc3QgZXhpc3RpbmdRdWVyeSA9IHF1ZXJ5KFxuICAgICAgICAgIGNvbGxlY3Rpb24oZGIoKSwgJ2NvbnRlbnRTaGFyaW5nJyksXG4gICAgICAgICAgd2hlcmUoJ2NvbnRlbnRUeXBlJywgJz09JywgY29udGVudFR5cGUpLFxuICAgICAgICAgIHdoZXJlKCdjb250ZW50SWQnLCAnPT0nLCBjb250ZW50SWQpLFxuICAgICAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB0YXJnZXRVc2VyLnVpZCksXG4gICAgICAgICAgd2hlcmUoJ2lzQWN0aXZlJywgJz09JywgdHJ1ZSlcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBleGlzdGluZ1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhleGlzdGluZ1F1ZXJ5KTtcbiAgICAgICAgXG4gICAgICAgIGlmICghZXhpc3RpbmdTbmFwc2hvdC5lbXB0eSkge1xuICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBhc3NpZ25tZW50XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdEb2MgPSBleGlzdGluZ1NuYXBzaG90LmRvY3NbMF07XG4gICAgICAgICAgYXdhaXQgdXBkYXRlRG9jKGV4aXN0aW5nRG9jLnJlZiwge1xuICAgICAgICAgICAgcGVybWlzc2lvbnMsXG4gICAgICAgICAgICBhc3NpZ25lZEJ5OiBzaGFyZWRCeVVzZXJJZCxcbiAgICAgICAgICAgIGFzc2lnbmVkQnlOYW1lOiBzaGFyZWRCeU5hbWUsXG4gICAgICAgICAgICBhc3NpZ25lZEF0OiBhc3NpZ25tZW50LmFzc2lnbmVkQXQsXG4gICAgICAgICAgICBleHBpcmVzQXQsXG4gICAgICAgICAgICBub3Rlczogc2FuaXRpemVkTWVzc2FnZSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGF3YWl0IHRoaXMubG9nU2VjdXJpdHlFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAncGVybWlzc2lvbl9jaGFuZ2UnLFxuICAgICAgICAgICAgdXNlcklkOiBzaGFyZWRCeVVzZXJJZCxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgY29udGVudElkLFxuICAgICAgICAgICAgZGV0YWlsczogeyB0YXJnZXRVc2VySWQ6IHRhcmdldFVzZXIudWlkLCBuZXdSb2xlOiBwZXJtaXNzaW9ucy5yb2xlLCBhY3Rpb246ICd1cGRhdGVkJyB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBhc3NpZ25tZW50SWQ6IGV4aXN0aW5nRG9jLmlkIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIG5ldyBhc3NpZ25tZW50XG4gICAgICAgICAgY29uc3QgZG9jUmVmID0gYXdhaXQgYWRkRG9jKGNvbGxlY3Rpb24oZGIoKSwgJ2NvbnRlbnRTaGFyaW5nJyksIHtcbiAgICAgICAgICAgIC4uLmFzc2lnbm1lbnQsXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBhd2FpdCB0aGlzLmxvZ1NlY3VyaXR5RXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ2FjY2Vzc19ncmFudGVkJyxcbiAgICAgICAgICAgIHVzZXJJZDogc2hhcmVkQnlVc2VySWQsXG4gICAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICAgIGNvbnRlbnRJZCxcbiAgICAgICAgICAgIGRldGFpbHM6IHsgdGFyZ2V0VXNlcklkOiB0YXJnZXRVc2VyLnVpZCwgcm9sZTogcGVybWlzc2lvbnMucm9sZSwgYWN0aW9uOiAnY3JlYXRlZCcgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgYXNzaWdubWVudElkOiBkb2NSZWYuaWQgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlciBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaW52aXRhdGlvblxuICAgICAgICBjb25zdCBjb250ZW50TmFtZSA9IGF3YWl0IHRoaXMuZ2V0Q29udGVudE5hbWUoY29udGVudFR5cGUsIGNvbnRlbnRJZCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBpbnZpdGF0aW9uOiBDb250ZW50SW52aXRhdGlvbiA9IHtcbiAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICBjb250ZW50SWQsXG4gICAgICAgICAgY29udGVudE5hbWUsXG4gICAgICAgICAgaW52aXRlZFBob25lOiBzYW5pdGl6ZWRQaG9uZSxcbiAgICAgICAgICBpbnZpdGVkQnlVc2VySWQ6IHNoYXJlZEJ5VXNlcklkLFxuICAgICAgICAgIGludml0ZWRCeU5hbWU6IHNoYXJlZEJ5TmFtZSxcbiAgICAgICAgICBwZXJtaXNzaW9ucyxcbiAgICAgICAgICBtZXNzYWdlOiBzYW5pdGl6ZWRNZXNzYWdlLFxuICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpIC8vIDcgZGF5c1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiKCksICdjb250ZW50SW52aXRhdGlvbnMnKSwge1xuICAgICAgICAgIC4uLmludml0YXRpb24sXG4gICAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCB0aGlzLmxvZ1NlY3VyaXR5RXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdhY2Nlc3NfZ3JhbnRlZCcsXG4gICAgICAgICAgdXNlcklkOiBzaGFyZWRCeVVzZXJJZCxcbiAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICBjb250ZW50SWQsXG4gICAgICAgICAgZGV0YWlsczogeyBpbnZpdGVkUGhvbmU6IHNhbml0aXplZFBob25lLCByb2xlOiBwZXJtaXNzaW9ucy5yb2xlLCBhY3Rpb246ICdpbnZpdGF0aW9uX2NyZWF0ZWQnIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgaW52aXRhdGlvbklkOiBkb2NSZWYuaWQgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2hhcmluZyBjb250ZW50OicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0ZhaWxlZCB0byBzaGFyZSBjb250ZW50JyB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgc2hhcmVkIGFjY2Vzc1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIHJlbW92ZVNoYXJlZEFjY2VzcyhcbiAgICBjb250ZW50VHlwZTogJ2FydGlzdCcgfCAnb3JnYW5pemF0aW9uJyB8ICd2ZW51ZScgfCAnZXZlbnQnIHwgJ2FjdGl2aXR5JyxcbiAgICBjb250ZW50SWQ6IHN0cmluZyxcbiAgICB0YXJnZXRVc2VySWQ6IHN0cmluZyxcbiAgICByZW1vdmVkQnlVc2VySWQ6IHN0cmluZ1xuICApOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBWZXJpZnkgcmVtb3ZlciBoYXMgcGVybWlzc2lvblxuICAgICAgY29uc3QgcmVtb3ZlclBlcm1pc3Npb25zID0gYXdhaXQgdGhpcy52ZXJpZnlDb250ZW50QWNjZXNzKGNvbnRlbnRUeXBlLCBjb250ZW50SWQsIHJlbW92ZWRCeVVzZXJJZCk7XG4gICAgICBcbiAgICAgIGlmICghcmVtb3ZlclBlcm1pc3Npb25zLmNhbk1hbmFnZSAmJiByZW1vdmVyUGVybWlzc2lvbnMucm9sZSAhPT0gJ293bmVyJykge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byByZW1vdmUgYWNjZXNzJyB9O1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIGFuZCByZW1vdmUgdGhlIGFzc2lnbm1lbnRcbiAgICAgIGNvbnN0IGFzc2lnbm1lbnRRdWVyeSA9IHF1ZXJ5KFxuICAgICAgICBjb2xsZWN0aW9uKGRiKCksICdjb250ZW50U2hhcmluZycpLFxuICAgICAgICB3aGVyZSgnY29udGVudFR5cGUnLCAnPT0nLCBjb250ZW50VHlwZSksXG4gICAgICAgIHdoZXJlKCdjb250ZW50SWQnLCAnPT0nLCBjb250ZW50SWQpLFxuICAgICAgICB3aGVyZSgndXNlcklkJywgJz09JywgdGFyZ2V0VXNlcklkKSxcbiAgICAgICAgd2hlcmUoJ2lzQWN0aXZlJywgJz09JywgdHJ1ZSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhhc3NpZ25tZW50UXVlcnkpO1xuICAgICAgXG4gICAgICBpZiAoc25hcHNob3QuZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnTm8gc2hhcmVkIGFjY2VzcyBmb3VuZCBmb3IgdGhpcyB1c2VyJyB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiYXRjaCA9IHdyaXRlQmF0Y2goZGIoKSk7XG4gICAgICBcbiAgICAgIHNuYXBzaG90LmRvY3MuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICBiYXRjaC51cGRhdGUoZG9jLnJlZiwge1xuICAgICAgICAgIGlzQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICByZW1vdmVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgICAgIHJlbW92ZWRCeTogcmVtb3ZlZEJ5VXNlcklkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGJhdGNoLmNvbW1pdCgpO1xuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHNoYXJlZCBhY2Nlc3M6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnRmFpbGVkIHRvIHJlbW92ZSBzaGFyZWQgYWNjZXNzJyB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHVzZXJzIHdobyBoYXZlIGFjY2VzcyB0byBjb250ZW50XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0Q29udGVudENvbGxhYm9yYXRvcnMoXG4gICAgY29udGVudFR5cGU6ICdhcnRpc3QnIHwgJ29yZ2FuaXphdGlvbicgfCAndmVudWUnIHwgJ2V2ZW50JyB8ICdhY3Rpdml0eScsXG4gICAgY29udGVudElkOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxDb250ZW50U2hhcmVBc3NpZ25tZW50W10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29sbGFib3JhdG9yc1F1ZXJ5ID0gcXVlcnkoXG4gICAgICAgIGNvbGxlY3Rpb24oZGIoKSwgJ2NvbnRlbnRTaGFyaW5nJyksXG4gICAgICAgIHdoZXJlKCdjb250ZW50VHlwZScsICc9PScsIGNvbnRlbnRUeXBlKSxcbiAgICAgICAgd2hlcmUoJ2NvbnRlbnRJZCcsICc9PScsIGNvbnRlbnRJZCksXG4gICAgICAgIHdoZXJlKCdpc0FjdGl2ZScsICc9PScsIHRydWUpXG4gICAgICApO1xuXG4gICAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoY29sbGFib3JhdG9yc1F1ZXJ5KTtcbiAgICAgIFxuICAgICAgY29uc3QgYXNzaWdubWVudHMgPSBzbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcbiAgICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgICAgLi4uZG9jLmRhdGEoKVxuICAgICAgfSBhcyBDb250ZW50U2hhcmVBc3NpZ25tZW50KSk7XG5cbiAgICAgIC8vIERlZHVwbGljYXRlIGJ5IHVzZXJJZCAtIGtlZXAgb25seSB0aGUgbW9zdCByZWNlbnQgYXNzaWdubWVudCBmb3IgZWFjaCB1c2VyXG4gICAgICBjb25zdCB1c2VyQXNzaWdubWVudE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBDb250ZW50U2hhcmVBc3NpZ25tZW50PigpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGFzc2lnbm1lbnQgb2YgYXNzaWdubWVudHMpIHtcbiAgICAgICAgLy8gU2tpcCBleHBpcmVkIGFzc2lnbm1lbnRzXG4gICAgICAgIGlmIChhc3NpZ25tZW50LmV4cGlyZXNBdCAmJiBuZXcgRGF0ZShhc3NpZ25tZW50LmV4cGlyZXNBdCkgPCBuZXcgRGF0ZSgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQXNzaWdubWVudCA9IHVzZXJBc3NpZ25tZW50TWFwLmdldChhc3NpZ25tZW50LnVzZXJJZCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWV4aXN0aW5nQXNzaWdubWVudCB8fCBcbiAgICAgICAgICAgIG5ldyBEYXRlKGFzc2lnbm1lbnQuYXNzaWduZWRBdCkgPiBuZXcgRGF0ZShleGlzdGluZ0Fzc2lnbm1lbnQuYXNzaWduZWRBdCkpIHtcbiAgICAgICAgICB1c2VyQXNzaWdubWVudE1hcC5zZXQoYXNzaWdubWVudC51c2VySWQsIGFzc2lnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHVzZXJBc3NpZ25tZW50TWFwLnZhbHVlcygpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY29udGVudCBjb2xsYWJvcmF0b3JzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNoYXJlZCBjb250ZW50IGZvciBhIHVzZXIgKGNvbnRlbnQgdGhleSBoYXZlIGFjY2VzcyB0byBidXQgZG9uJ3Qgb3duKVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdldFVzZXJTaGFyZWRDb250ZW50KHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx7XG4gICAgYXJ0aXN0czogQXJyYXk8eyB1aWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nOyByb2xlOiBzdHJpbmcgfT47XG4gICAgb3JnYW5pemF0aW9uczogQXJyYXk8eyB1aWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nOyByb2xlOiBzdHJpbmcgfT47XG4gICAgdmVudWVzOiBBcnJheTx7IHVpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmc7IHJvbGU6IHN0cmluZyB9PjtcbiAgICBldmVudHM6IEFycmF5PHsgdWlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgcm9sZTogc3RyaW5nIH0+O1xuICAgIGFjdGl2aXRpZXM6IEFycmF5PHsgdWlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgcm9sZTogc3RyaW5nIH0+O1xuICB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNoYXJlZFF1ZXJ5ID0gcXVlcnkoXG4gICAgICAgIGNvbGxlY3Rpb24oZGIoKSwgJ2NvbnRlbnRTaGFyaW5nJyksXG4gICAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VySWQpLFxuICAgICAgICB3aGVyZSgnaXNBY3RpdmUnLCAnPT0nLCB0cnVlKVxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHNoYXJlZFF1ZXJ5KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc2hhcmVkQ29udGVudCA9IHtcbiAgICAgICAgYXJ0aXN0czogW10gYXMgQXJyYXk8eyB1aWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nOyByb2xlOiBzdHJpbmcgfT4sXG4gICAgICAgIG9yZ2FuaXphdGlvbnM6IFtdIGFzIEFycmF5PHsgdWlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgcm9sZTogc3RyaW5nIH0+LFxuICAgICAgICB2ZW51ZXM6IFtdIGFzIEFycmF5PHsgdWlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgcm9sZTogc3RyaW5nIH0+LFxuICAgICAgICBldmVudHM6IFtdIGFzIEFycmF5PHsgdWlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgcm9sZTogc3RyaW5nIH0+LFxuICAgICAgICBhY3Rpdml0aWVzOiBbXSBhcyBBcnJheTx7IHVpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmc7IHJvbGU6IHN0cmluZyB9PlxuICAgICAgfTtcblxuICAgICAgLy8gVXNlIFNldCB0byB0cmFjayBhbHJlYWR5IHByb2Nlc3NlZCBjb250ZW50IHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgY29uc3QgcHJvY2Vzc2VkQ29udGVudCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgICBmb3IgKGNvbnN0IGRvY1NuYXAgb2Ygc25hcHNob3QuZG9jcykge1xuICAgICAgICBjb25zdCBhc3NpZ25tZW50ID0gZG9jU25hcC5kYXRhKCkgYXMgQ29udGVudFNoYXJlQXNzaWdubWVudDtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGFzc2lnbm1lbnQgaGFzIGV4cGlyZWRcbiAgICAgICAgaWYgKGFzc2lnbm1lbnQuZXhwaXJlc0F0ICYmIG5ldyBEYXRlKGFzc2lnbm1lbnQuZXhwaXJlc0F0KSA8IG5ldyBEYXRlKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSB1bmlxdWUga2V5IGZvciBkZWR1cGxpY2F0aW9uXG4gICAgICAgIGNvbnN0IGNvbnRlbnRLZXkgPSBgJHthc3NpZ25tZW50LmNvbnRlbnRUeXBlfS0ke2Fzc2lnbm1lbnQuY29udGVudElkfWA7XG4gICAgICAgIFxuICAgICAgICAvLyBTa2lwIGlmIGFscmVhZHkgcHJvY2Vzc2VkIHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICBpZiAocHJvY2Vzc2VkQ29udGVudC5oYXMoY29udGVudEtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcHJvY2Vzc2VkQ29udGVudC5hZGQoY29udGVudEtleSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBjb250ZW50IG5hbWVcbiAgICAgICAgY29uc3QgY29udGVudE5hbWUgPSBhd2FpdCB0aGlzLmdldENvbnRlbnROYW1lKGFzc2lnbm1lbnQuY29udGVudFR5cGUsIGFzc2lnbm1lbnQuY29udGVudElkKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNoYXJlZEl0ZW0gPSB7XG4gICAgICAgICAgdWlkOiBhc3NpZ25tZW50LmNvbnRlbnRJZCxcbiAgICAgICAgICBuYW1lOiBjb250ZW50TmFtZSxcbiAgICAgICAgICByb2xlOiBhc3NpZ25tZW50LnBlcm1pc3Npb25zLnJvbGVcbiAgICAgICAgfTtcblxuICAgICAgICBzd2l0Y2ggKGFzc2lnbm1lbnQuY29udGVudFR5cGUpIHtcbiAgICAgICAgICBjYXNlICdhcnRpc3QnOlxuICAgICAgICAgICAgc2hhcmVkQ29udGVudC5hcnRpc3RzLnB1c2goc2hhcmVkSXRlbSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdvcmdhbml6YXRpb24nOlxuICAgICAgICAgICAgc2hhcmVkQ29udGVudC5vcmdhbml6YXRpb25zLnB1c2goc2hhcmVkSXRlbSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd2ZW51ZSc6XG4gICAgICAgICAgICBzaGFyZWRDb250ZW50LnZlbnVlcy5wdXNoKHNoYXJlZEl0ZW0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZXZlbnQnOlxuICAgICAgICAgICAgc2hhcmVkQ29udGVudC5ldmVudHMucHVzaChzaGFyZWRJdGVtKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2FjdGl2aXR5JzpcbiAgICAgICAgICAgIHNoYXJlZENvbnRlbnQuYWN0aXZpdGllcy5wdXNoKHNoYXJlZEl0ZW0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNoYXJlZENvbnRlbnQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNoYXJlZCBjb250ZW50OicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFydGlzdHM6IFtdLFxuICAgICAgICBvcmdhbml6YXRpb25zOiBbXSxcbiAgICAgICAgdmVudWVzOiBbXSxcbiAgICAgICAgZXZlbnRzOiBbXSxcbiAgICAgICAgYWN0aXZpdGllczogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwZW5kaW5nIGludml0YXRpb25zIGZvciBhIHVzZXJcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRVc2VyUGVuZGluZ0ludml0YXRpb25zKHVzZXJQaG9uZTogc3RyaW5nKTogUHJvbWlzZTxDb250ZW50SW52aXRhdGlvbltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGludml0YXRpb25zUXVlcnkgPSBxdWVyeShcbiAgICAgICAgY29sbGVjdGlvbihkYigpLCAnY29udGVudEludml0YXRpb25zJyksXG4gICAgICAgIHdoZXJlKCdpbnZpdGVkUGhvbmUnLCAnPT0nLCB1c2VyUGhvbmUpLFxuICAgICAgICB3aGVyZSgnc3RhdHVzJywgJz09JywgJ3BlbmRpbmcnKVxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGludml0YXRpb25zUXVlcnkpO1xuICAgICAgXG4gICAgICByZXR1cm4gc25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XG4gICAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAgIC4uLmRvYy5kYXRhKClcbiAgICAgIH0gYXMgQ29udGVudEludml0YXRpb24pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcGVuZGluZyBpbnZpdGF0aW9uczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBpbnZpdGF0aW9uXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgYWNjZXB0SW52aXRhdGlvbihcbiAgICBpbnZpdGF0aW9uSWQ6IHN0cmluZyxcbiAgICB1c2VySWQ6IHN0cmluZyxcbiAgICB1c2VyTmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGludml0YXRpb25Eb2MgPSBhd2FpdCBnZXREb2MoZG9jKGRiKCksICdjb250ZW50SW52aXRhdGlvbnMnLCBpbnZpdGF0aW9uSWQpKTtcbiAgICAgIFxuICAgICAgaWYgKCFpbnZpdGF0aW9uRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0ludml0YXRpb24gbm90IGZvdW5kJyB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnZpdGF0aW9uID0gaW52aXRhdGlvbkRvYy5kYXRhKCkgYXMgQ29udGVudEludml0YXRpb247XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGludml0YXRpb24gaXMgc3RpbGwgdmFsaWRcbiAgICAgIGlmIChpbnZpdGF0aW9uLnN0YXR1cyAhPT0gJ3BlbmRpbmcnIHx8IG5ldyBEYXRlKGludml0YXRpb24uZXhwaXJlc0F0KSA8IG5ldyBEYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnSW52aXRhdGlvbiBoYXMgZXhwaXJlZCBvciBhbHJlYWR5IGJlZW4gcmVzcG9uZGVkIHRvJyB9O1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgY29udGVudCBzaGFyaW5nIGFzc2lnbm1lbnRcbiAgICAgIGNvbnN0IGFzc2lnbm1lbnQ6IENvbnRlbnRTaGFyZUFzc2lnbm1lbnQgPSB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBpbnZpdGF0aW9uLmNvbnRlbnRUeXBlLFxuICAgICAgICBjb250ZW50SWQ6IGludml0YXRpb24uY29udGVudElkLFxuICAgICAgICB1c2VySWQsXG4gICAgICAgIHVzZXJQaG9uZTogaW52aXRhdGlvbi5pbnZpdGVkUGhvbmUsXG4gICAgICAgIHVzZXJOYW1lLFxuICAgICAgICBwZXJtaXNzaW9uczogaW52aXRhdGlvbi5wZXJtaXNzaW9ucyxcbiAgICAgICAgYXNzaWduZWRCeTogaW52aXRhdGlvbi5pbnZpdGVkQnlVc2VySWQsXG4gICAgICAgIGFzc2lnbmVkQnlOYW1lOiBpbnZpdGF0aW9uLmludml0ZWRCeU5hbWUsXG4gICAgICAgIGFzc2lnbmVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG5vdGVzOiBgQWNjZXB0ZWQgaW52aXRhdGlvbjogJHtpbnZpdGF0aW9uLm1lc3NhZ2UgfHwgJyd9YCxcbiAgICAgICAgaW52aXRhdGlvbk1lc3NhZ2U6IGludml0YXRpb24ubWVzc2FnZSB8fCAnJ1xuICAgICAgfTtcblxuICAgICAgLy8gVXNlIGJhdGNoIHRvIHVwZGF0ZSBpbnZpdGF0aW9uIGFuZCBjcmVhdGUgYXNzaWdubWVudFxuICAgICAgY29uc3QgYmF0Y2ggPSB3cml0ZUJhdGNoKGRiKCkpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgaW52aXRhdGlvbiBzdGF0dXNcbiAgICAgIGJhdGNoLnVwZGF0ZShkb2MoZGIoKSwgJ2NvbnRlbnRJbnZpdGF0aW9ucycsIGludml0YXRpb25JZCksIHtcbiAgICAgICAgc3RhdHVzOiAnYWNjZXB0ZWQnLFxuICAgICAgICByZXNwb25kZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICAgIGludml0ZWRVc2VySWQ6IHVzZXJJZFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBzaGFyaW5nIGFzc2lnbm1lbnRcbiAgICAgIGNvbnN0IGFzc2lnbm1lbnRSZWYgPSBkb2MoY29sbGVjdGlvbihkYigpLCAnY29udGVudFNoYXJpbmcnKSk7XG4gICAgICBiYXRjaC5zZXQoYXNzaWdubWVudFJlZiwge1xuICAgICAgICAuLi5hc3NpZ25tZW50LFxuICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgYmF0Y2guY29tbWl0KCk7XG5cbiAgICAgIGF3YWl0IHRoaXMubG9nQ29udGVudFNlY3VyaXR5RXZlbnQoe1xuICAgICAgICB0eXBlOiAnaW52aXRhdGlvbl9yZXNwb25zZScsXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgY29udGVudFR5cGU6IGludml0YXRpb24uY29udGVudFR5cGUsXG4gICAgICAgIGNvbnRlbnRJZDogaW52aXRhdGlvbi5jb250ZW50SWQsXG4gICAgICAgIGFjdGlvbjogJ2ludml0YXRpb25fYWNjZXB0ZWQnLFxuICAgICAgICByZXN1bHQ6ICdzdWNjZXNzJyxcbiAgICAgICAgZGV0YWlsczogeyBpbnZpdGF0aW9uSWQsIHJvbGU6IGludml0YXRpb24ucGVybWlzc2lvbnMucm9sZSB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhY2NlcHRpbmcgaW52aXRhdGlvbjonLCBlcnJvcik7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdGYWlsZWQgdG8gYWNjZXB0IGludml0YXRpb24nIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlY2xpbmUgYW4gaW52aXRhdGlvblxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGRlY2xpbmVJbnZpdGF0aW9uKGludml0YXRpb25JZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdXBkYXRlRG9jKGRvYyhkYigpLCAnY29udGVudEludml0YXRpb25zJywgaW52aXRhdGlvbklkKSwge1xuICAgICAgICBzdGF0dXM6ICdkZWNsaW5lZCcsXG4gICAgICAgIHJlc3BvbmRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVjbGluaW5nIGludml0YXRpb246JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnRmFpbGVkIHRvIGRlY2xpbmUgaW52aXRhdGlvbicgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVybWlzc2lvbiB0ZW1wbGF0ZXMgZm9yIGRpZmZlcmVudCByb2xlc1xuICAgKi9cbiAgc3RhdGljIGdldFBlcm1pc3Npb25UZW1wbGF0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZXdlcjoge1xuICAgICAgICBjYW5WaWV3OiB0cnVlLFxuICAgICAgICBjYW5FZGl0OiBmYWxzZSxcbiAgICAgICAgY2FuTWFuYWdlOiBmYWxzZSxcbiAgICAgICAgY2FuSW52aXRlT3RoZXJzOiBmYWxzZSxcbiAgICAgICAgY2FuVmlld0FuYWx5dGljczogZmFsc2UsXG4gICAgICAgIGNhbkRlbGV0ZTogZmFsc2UsXG4gICAgICAgIHJvbGU6ICd2aWV3ZXInIGFzIGNvbnN0XG4gICAgICB9LFxuICAgICAgZWRpdG9yOiB7XG4gICAgICAgIGNhblZpZXc6IHRydWUsXG4gICAgICAgIGNhbkVkaXQ6IHRydWUsXG4gICAgICAgIGNhbk1hbmFnZTogZmFsc2UsXG4gICAgICAgIGNhbkludml0ZU90aGVyczogZmFsc2UsXG4gICAgICAgIGNhblZpZXdBbmFseXRpY3M6IHRydWUsXG4gICAgICAgIGNhbkRlbGV0ZTogZmFsc2UsXG4gICAgICAgIHJvbGU6ICdlZGl0b3InIGFzIGNvbnN0XG4gICAgICB9LFxuICAgICAgYWRtaW46IHtcbiAgICAgICAgY2FuVmlldzogdHJ1ZSxcbiAgICAgICAgY2FuRWRpdDogdHJ1ZSxcbiAgICAgICAgY2FuTWFuYWdlOiB0cnVlLFxuICAgICAgICBjYW5JbnZpdGVPdGhlcnM6IHRydWUsXG4gICAgICAgIGNhblZpZXdBbmFseXRpY3M6IHRydWUsXG4gICAgICAgIGNhbkRlbGV0ZTogZmFsc2UsXG4gICAgICAgIHJvbGU6ICdhZG1pbicgYXMgY29uc3RcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gUHJpdmF0ZSBoZWxwZXIgbWV0aG9kc1xuICBwcml2YXRlIHN0YXRpYyBhc3luYyBjaGVja0NvbnRlbnRPd25lcnNoaXAoXG4gICAgY29udGVudFR5cGU6ICdhcnRpc3QnIHwgJ29yZ2FuaXphdGlvbicgfCAndmVudWUnIHwgJ2V2ZW50JyB8ICdhY3Rpdml0eScsXG4gICAgY29udGVudElkOiBzdHJpbmcsXG4gICAgdXNlcklkOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb2xsZWN0aW9uTmFtZSA9ICcnO1xuICAgICAgbGV0IG93bmVyRmllbGQgPSAnb3duZXJJZCc7XG5cbiAgICAgIHN3aXRjaCAoY29udGVudFR5cGUpIHtcbiAgICAgICAgY2FzZSAnYXJ0aXN0JzpcbiAgICAgICAgICBjb2xsZWN0aW9uTmFtZSA9ICdBcnRpc3RzJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb3JnYW5pemF0aW9uJzpcbiAgICAgICAgICBjb2xsZWN0aW9uTmFtZSA9ICdPcmdhbmlzYXRpb25zJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVudWUnOlxuICAgICAgICAgIGNvbGxlY3Rpb25OYW1lID0gJ1ZlbnVlcyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2V2ZW50JzpcbiAgICAgICAgICBjb2xsZWN0aW9uTmFtZSA9ICdldmVudHMnO1xuICAgICAgICAgIG93bmVyRmllbGQgPSAnb3JnYW5pemF0aW9uSWQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhY3Rpdml0eSc6XG4gICAgICAgICAgY29sbGVjdGlvbk5hbWUgPSAnYWN0aXZpdGllcyc7XG4gICAgICAgICAgb3duZXJGaWVsZCA9ICdvcmdhbml6YXRpb25JZCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnRlbnREb2MgPSBhd2FpdCBnZXREb2MoZG9jKGRiKCksIGNvbGxlY3Rpb25OYW1lLCBjb250ZW50SWQpKTtcbiAgICAgIGlmICghY29udGVudERvYy5leGlzdHMoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjb25zdCBjb250ZW50RGF0YSA9IGNvbnRlbnREb2MuZGF0YSgpO1xuICAgICAgXG4gICAgICAvLyBGb3IgZXZlbnRzLCBjaGVjayBib3RoIG9yZ2FuaXphdGlvbklkIGFuZCBjcmVhdG9yLnVzZXJJZFxuICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSAnZXZlbnQnKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50RGF0YS5vcmdhbml6YXRpb25JZCA9PT0gdXNlcklkIHx8IFxuICAgICAgICAgICAgICAgKGNvbnRlbnREYXRhLmNyZWF0b3IgJiYgY29udGVudERhdGEuY3JlYXRvci51c2VySWQgPT09IHVzZXJJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50RGF0YVtvd25lckZpZWxkXSA9PT0gdXNlcklkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBjb250ZW50IG93bmVyc2hpcDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgZ2V0U2hhcmVkUGVybWlzc2lvbnMoXG4gICAgY29udGVudFR5cGU6ICdhcnRpc3QnIHwgJ29yZ2FuaXphdGlvbicgfCAndmVudWUnIHwgJ2V2ZW50JyB8ICdhY3Rpdml0eScsXG4gICAgY29udGVudElkOiBzdHJpbmcsXG4gICAgdXNlcklkOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxDb250ZW50UGVybWlzc2lvbnMgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNoYXJpbmdRdWVyeSA9IHF1ZXJ5KFxuICAgICAgICBjb2xsZWN0aW9uKGRiKCksICdjb250ZW50U2hhcmluZycpLFxuICAgICAgICB3aGVyZSgnY29udGVudFR5cGUnLCAnPT0nLCBjb250ZW50VHlwZSksXG4gICAgICAgIHdoZXJlKCdjb250ZW50SWQnLCAnPT0nLCBjb250ZW50SWQpLFxuICAgICAgICB3aGVyZSgndXNlcklkJywgJz09JywgdXNlcklkKSxcbiAgICAgICAgd2hlcmUoJ2lzQWN0aXZlJywgJz09JywgdHJ1ZSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhzaGFyaW5nUXVlcnkpO1xuICAgICAgXG4gICAgICBpZiAoc25hcHNob3QuZW1wdHkpIHJldHVybiBudWxsO1xuXG4gICAgICBjb25zdCBhc3NpZ25tZW50ID0gc25hcHNob3QuZG9jc1swXS5kYXRhKCkgYXMgQ29udGVudFNoYXJlQXNzaWdubWVudDtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgYXNzaWdubWVudCBoYXMgZXhwaXJlZFxuICAgICAgaWYgKGFzc2lnbm1lbnQuZXhwaXJlc0F0ICYmIG5ldyBEYXRlKGFzc2lnbm1lbnQuZXhwaXJlc0F0KSA8IG5ldyBEYXRlKCkpIHtcbiAgICAgICAgLy8gTWFyayBhcyBleHBpcmVkXG4gICAgICAgIGF3YWl0IHVwZGF0ZURvYyhzbmFwc2hvdC5kb2NzWzBdLnJlZiwge1xuICAgICAgICAgIGlzQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICBzdGF0dXM6ICdleHBpcmVkJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhc3NpZ25tZW50LnBlcm1pc3Npb25zO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHNoYXJlZCBwZXJtaXNzaW9uczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBhc3luYyBmaW5kVXNlckJ5UGhvbmUocGhvbmU6IHN0cmluZyk6IFByb21pc2U8eyB1aWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nIH0gfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXJzUXVlcnkgPSBxdWVyeShcbiAgICAgICAgY29sbGVjdGlvbihkYigpLCAnVXNlcnMnKSxcbiAgICAgICAgd2hlcmUoJ3Bob25lTnVtYmVyJywgJz09JywgcGhvbmUpXG4gICAgICApO1xuXG4gICAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3ModXNlcnNRdWVyeSk7XG4gICAgICBcbiAgICAgIGlmIChzbmFwc2hvdC5lbXB0eSkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNvbnN0IHVzZXJEYXRhID0gc25hcHNob3QuZG9jc1swXS5kYXRhKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1aWQ6IHNuYXBzaG90LmRvY3NbMF0uaWQsXG4gICAgICAgIG5hbWU6IHVzZXJEYXRhLm5hbWUgfHwgdXNlckRhdGEuZGlzcGxheU5hbWUgfHwgJ1Vua25vd24gVXNlcidcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZpbmRpbmcgdXNlciBieSBwaG9uZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBhc3luYyBnZXRDb250ZW50TmFtZShcbiAgICBjb250ZW50VHlwZTogJ2FydGlzdCcgfCAnb3JnYW5pemF0aW9uJyB8ICd2ZW51ZScgfCAnZXZlbnQnIHwgJ2FjdGl2aXR5JyxcbiAgICBjb250ZW50SWQ6IHN0cmluZ1xuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29sbGVjdGlvbk5hbWUgPSAnJztcbiAgICAgIGxldCBuYW1lRmllbGQgPSAnbmFtZSc7XG5cbiAgICAgIHN3aXRjaCAoY29udGVudFR5cGUpIHtcbiAgICAgICAgY2FzZSAnYXJ0aXN0JzpcbiAgICAgICAgICBjb2xsZWN0aW9uTmFtZSA9ICdBcnRpc3RzJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb3JnYW5pemF0aW9uJzpcbiAgICAgICAgICBjb2xsZWN0aW9uTmFtZSA9ICdPcmdhbmlzYXRpb25zJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVudWUnOlxuICAgICAgICAgIGNvbGxlY3Rpb25OYW1lID0gJ1ZlbnVlcyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2V2ZW50JzpcbiAgICAgICAgICBjb2xsZWN0aW9uTmFtZSA9ICdldmVudHMnO1xuICAgICAgICAgIG5hbWVGaWVsZCA9ICd0aXRsZSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FjdGl2aXR5JzpcbiAgICAgICAgICBjb2xsZWN0aW9uTmFtZSA9ICdhY3Rpdml0aWVzJztcbiAgICAgICAgICBuYW1lRmllbGQgPSAndGl0bGUnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb250ZW50RG9jID0gYXdhaXQgZ2V0RG9jKGRvYyhkYigpLCBjb2xsZWN0aW9uTmFtZSwgY29udGVudElkKSk7XG4gICAgICBcbiAgICAgIGlmIChjb250ZW50RG9jLmV4aXN0cygpKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjb250ZW50RG9jLmRhdGEoKTtcbiAgICAgICAgcmV0dXJuIGRhdGFbbmFtZUZpZWxkXSB8fCBgJHtjb250ZW50VHlwZX0gJHtjb250ZW50SWR9YDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGAke2NvbnRlbnRUeXBlfSAke2NvbnRlbnRJZH1gO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGNvbnRlbnQgbmFtZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gYCR7Y29udGVudFR5cGV9ICR7Y29udGVudElkfWA7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgbG9nQ29udGVudFNlY3VyaXR5RXZlbnQoZXZlbnQ6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYigpLCAnc2VjdXJpdHlFdmVudHMnKSwge1xuICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgdGltZXN0YW1wOiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgICAgc291cmNlOiAnY29udGVudF9zaGFyaW5nX3NlY3VyaXR5J1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvZ2dpbmcgc2VjdXJpdHkgZXZlbnQ6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIG93bmVyUGVybWlzc2lvbnMoKTogQ29udGVudFBlcm1pc3Npb25zIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FuVmlldzogdHJ1ZSxcbiAgICAgIGNhbkVkaXQ6IHRydWUsXG4gICAgICBjYW5NYW5hZ2U6IHRydWUsXG4gICAgICBjYW5JbnZpdGVPdGhlcnM6IHRydWUsXG4gICAgICBjYW5WaWV3QW5hbHl0aWNzOiB0cnVlLFxuICAgICAgY2FuRGVsZXRlOiB0cnVlLFxuICAgICAgcm9sZTogJ293bmVyJ1xuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyB1bmF1dGhvcml6ZWRQZXJtaXNzaW9ucygpOiBDb250ZW50UGVybWlzc2lvbnMge1xuICAgIHJldHVybiB7XG4gICAgICBjYW5WaWV3OiBmYWxzZSxcbiAgICAgIGNhbkVkaXQ6IGZhbHNlLFxuICAgICAgY2FuTWFuYWdlOiBmYWxzZSxcbiAgICAgIGNhbkludml0ZU90aGVyczogZmFsc2UsXG4gICAgICBjYW5WaWV3QW5hbHl0aWNzOiBmYWxzZSxcbiAgICAgIGNhbkRlbGV0ZTogZmFsc2UsXG4gICAgICByb2xlOiAndW5hdXRob3JpemVkJ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVHJhY2sgYW5kIGxpbWl0IGNvbmN1cnJlbnQgc2Vzc2lvbnNcbiAgICovXG4gIHN0YXRpYyBhc3luYyB0cmFja1Nlc3Npb24odXNlcklkOiBzdHJpbmcsIHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCFhY3RpdmVTZXNzaW9ucy5oYXModXNlcklkKSkge1xuICAgICAgYWN0aXZlU2Vzc2lvbnMuc2V0KHVzZXJJZCwgbmV3IFNldCgpKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdXNlclNlc3Npb25zID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHVzZXJJZCkhO1xuICAgIFxuICAgIGlmICh1c2VyU2Vzc2lvbnMuc2l6ZSA+PSBTRUNVUklUWV9MSU1JVFMubWF4Q29uY3VycmVudFNlc3Npb25zKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvZ1NlY3VyaXR5RXZlbnQoe1xuICAgICAgICB0eXBlOiAnc2Vzc2lvbl9saW1pdF9leGNlZWRlZCcsXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgY29udGVudFR5cGU6ICdzeXN0ZW0nLFxuICAgICAgICBjb250ZW50SWQ6ICdnbG9iYWwnLFxuICAgICAgICBkZXRhaWxzOiB7IHNlc3Npb25JZCwgYWN0aXZlQ291bnQ6IHVzZXJTZXNzaW9ucy5zaXplIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICB1c2VyU2Vzc2lvbnMuYWRkKHNlc3Npb25JZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRW5oYW5jZWQgcGVybWlzc2lvbiB2YWxpZGF0aW9uIHdpdGggYnJ1dGUgZm9yY2UgcHJvdGVjdGlvblxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHZhbGlkYXRlQWNjZXNzQXR0ZW1wdCh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghZmFpbGVkQXR0ZW1wdHMuaGFzKHVzZXJJZCkpIHtcbiAgICAgIGZhaWxlZEF0dGVtcHRzLnNldCh1c2VySWQsIHsgY291bnQ6IDAsIGxhc3RBdHRlbXB0OiBEYXRlLm5vdygpIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgYXR0ZW1wdHMgPSBmYWlsZWRBdHRlbXB0cy5nZXQodXNlcklkKSE7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIFJlc2V0IGlmIGxvY2tvdXQgZHVyYXRpb24gaGFzIHBhc3NlZFxuICAgIGlmIChub3cgLSBhdHRlbXB0cy5sYXN0QXR0ZW1wdCA+IFNFQ1VSSVRZX0xJTUlUUy5sb2Nrb3V0RHVyYXRpb24gKiAxMDAwKSB7XG4gICAgICBmYWlsZWRBdHRlbXB0cy5zZXQodXNlcklkLCB7IGNvdW50OiAwLCBsYXN0QXR0ZW1wdDogbm93IH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGF0dGVtcHRzLmNvdW50ID49IFNFQ1VSSVRZX0xJTUlUUy5tYXhGYWlsZWRBdHRlbXB0cykge1xuICAgICAgYXdhaXQgdGhpcy5sb2dTZWN1cml0eUV2ZW50KHtcbiAgICAgICAgdHlwZTogJ2FjY291bnRfbG9ja291dCcsXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgY29udGVudFR5cGU6ICdzeXN0ZW0nLFxuICAgICAgICBjb250ZW50SWQ6ICdnbG9iYWwnLFxuICAgICAgICBkZXRhaWxzOiB7IGZhaWxlZEF0dGVtcHRzOiBhdHRlbXB0cy5jb3VudCB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvcmQgZmFpbGVkIGFjY2VzcyBhdHRlbXB0XG4gICAqL1xuICBzdGF0aWMgcmVjb3JkRmFpbGVkQXR0ZW1wdCh1c2VySWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGF0dGVtcHRzID0gZmFpbGVkQXR0ZW1wdHMuZ2V0KHVzZXJJZCkgfHwgeyBjb3VudDogMCwgbGFzdEF0dGVtcHQ6IERhdGUubm93KCkgfTtcbiAgICBhdHRlbXB0cy5jb3VudCsrO1xuICAgIGF0dGVtcHRzLmxhc3RBdHRlbXB0ID0gRGF0ZS5ub3coKTtcbiAgICBmYWlsZWRBdHRlbXB0cy5zZXQodXNlcklkLCBhdHRlbXB0cyk7XG4gIH1cbn0gIl0sIm5hbWVzIjpbImRiIiwiZG9jIiwiZ2V0RG9jIiwiY29sbGVjdGlvbiIsImFkZERvYyIsInNlcnZlclRpbWVzdGFtcCIsInF1ZXJ5Iiwid2hlcmUiLCJnZXREb2NzIiwidXBkYXRlRG9jIiwid3JpdGVCYXRjaCIsImdldEF1dGgiLCJTRUNVUklUWV9MSU1JVFMiLCJtYXhTaGFyZXNQZXJDb250ZW50IiwibWF4U2hhcmVzUGVyVXNlciIsIm1heEludml0YXRpb25zUGVySG91ciIsIm1heEludml0YXRpb25zUGVyRGF5IiwibWF4TWVzc2FnZUxlbmd0aCIsIm1heFBob25lTGVuZ3RoIiwibWF4Q29uY3VycmVudFNlc3Npb25zIiwiYWNjZXNzVG9rZW5FeHBpcnkiLCJtYXhGYWlsZWRBdHRlbXB0cyIsImxvY2tvdXREdXJhdGlvbiIsIm1pblBhc3N3b3JkTGVuZ3RoIiwiaW52aXRhdGlvblJhdGVMaW1pdCIsIk1hcCIsImFjdGl2ZVNlc3Npb25zIiwiZmFpbGVkQXR0ZW1wdHMiLCJDb250ZW50U2hhcmluZ1NlY3VyaXR5IiwidmFsaWRhdGVQaG9uZU51bWJlciIsInBob25lIiwiaXNWYWxpZCIsImVycm9yIiwiY2xlYW5lZCIsInJlcGxhY2UiLCJsZW5ndGgiLCJwaG9uZVJlZ2V4IiwidGVzdCIsInNhbml0aXplSW5wdXQiLCJpbnB1dCIsInRyaW0iLCJzdWJzdHJpbmciLCJ2YWxpZGF0ZU1lc3NhZ2UiLCJtZXNzYWdlIiwic2FuaXRpemVkIiwic3VzcGljaW91c1BhdHRlcm5zIiwic29tZSIsInBhdHRlcm4iLCJjaGVja0ludml0YXRpb25SYXRlTGltaXQiLCJ1c2VySWQiLCJub3ciLCJEYXRlIiwiaG91ck1zIiwiZGF5TXMiLCJ1c2VyTGltaXRzIiwiZ2V0IiwiY291bnQiLCJsYXN0UmVzZXQiLCJkYWlseUNvdW50IiwiZGFpbHlSZXNldCIsImFsbG93ZWQiLCJzZXQiLCJjaGVja1Jlc291cmNlTGltaXRzIiwiY29udGVudElkIiwidXNlclNoYXJlcyIsImNvbnRlbnRTaGFyZXMiLCJQcm9taXNlIiwiYWxsIiwic2l6ZSIsImNvbnNvbGUiLCJ2YWxpZGF0ZVBlcm1pc3Npb25DaGFuZ2UiLCJjdXJyZW50UGVybWlzc2lvbnMiLCJuZXdQZXJtaXNzaW9ucyIsInJvbGUiLCJjYW5NYW5hZ2UiLCJyb2xlSGllcmFyY2h5Iiwidmlld2VyIiwiZWRpdG9yIiwiYWRtaW4iLCJvd25lciIsInVuYXV0aG9yaXplZCIsImN1cnJlbnRMZXZlbCIsIm5ld0xldmVsIiwibG9nU2VjdXJpdHlFdmVudCIsImV2ZW50IiwidGltZXN0YW1wIiwidXNlckFnZW50IiwibmF2aWdhdG9yIiwidmVyaWZ5Q29udGVudEFjY2VzcyIsImNvbnRlbnRUeXBlIiwidmFsaWRhdGVBY2Nlc3NBdHRlbXB0IiwidHlwZSIsImRldGFpbHMiLCJyZWFzb24iLCJ1bmF1dGhvcml6ZWRQZXJtaXNzaW9ucyIsImN1cnJlbnRVc2VyIiwidWlkIiwicmVjb3JkRmFpbGVkQXR0ZW1wdCIsImlzT3duZXIiLCJjaGVja0NvbnRlbnRPd25lcnNoaXAiLCJvd25lclBlcm1pc3Npb25zIiwic2hhcmVkUGVybWlzc2lvbnMiLCJnZXRTaGFyZWRQZXJtaXNzaW9ucyIsInNoYXJlQ29udGVudCIsInRhcmdldFVzZXJQaG9uZSIsInRhcmdldFVzZXJOYW1lIiwicGVybWlzc2lvbnMiLCJzaGFyZWRCeVVzZXJJZCIsInNoYXJlZEJ5TmFtZSIsImV4cGlyZXNJbkhvdXJzIiwicGhvbmVWYWxpZGF0aW9uIiwic3VjY2VzcyIsIm1lc3NhZ2VWYWxpZGF0aW9uIiwicmF0ZUxpbWl0Q2hlY2siLCJyZXNvdXJjZUNoZWNrIiwic2hhcmVyUGVybWlzc2lvbnMiLCJ1c2VyUm9sZSIsInJlcXVpcmVkUm9sZSIsInBlcm1pc3Npb25WYWxpZGF0aW9uIiwic2FuaXRpemVkTWVzc2FnZSIsInNhbml0aXplZFRhcmdldE5hbWUiLCJzYW5pdGl6ZWRQaG9uZSIsInRhcmdldFVzZXIiLCJmaW5kVXNlckJ5UGhvbmUiLCJleHBpcmVzQXQiLCJ0b0lTT1N0cmluZyIsInVuZGVmaW5lZCIsImFzc2lnbm1lbnQiLCJ1c2VyUGhvbmUiLCJ1c2VyTmFtZSIsIm5hbWUiLCJhc3NpZ25lZEJ5IiwiYXNzaWduZWRCeU5hbWUiLCJhc3NpZ25lZEF0IiwiaXNBY3RpdmUiLCJzdGF0dXMiLCJub3RlcyIsImludml0YXRpb25NZXNzYWdlIiwiZXhpc3RpbmdRdWVyeSIsImV4aXN0aW5nU25hcHNob3QiLCJlbXB0eSIsImV4aXN0aW5nRG9jIiwiZG9jcyIsInJlZiIsInVwZGF0ZWRBdCIsInRhcmdldFVzZXJJZCIsIm5ld1JvbGUiLCJhY3Rpb24iLCJhc3NpZ25tZW50SWQiLCJpZCIsImRvY1JlZiIsImNyZWF0ZWRBdCIsImNvbnRlbnROYW1lIiwiZ2V0Q29udGVudE5hbWUiLCJpbnZpdGF0aW9uIiwiaW52aXRlZFBob25lIiwiaW52aXRlZEJ5VXNlcklkIiwiaW52aXRlZEJ5TmFtZSIsImludml0YXRpb25JZCIsInJlbW92ZVNoYXJlZEFjY2VzcyIsInJlbW92ZWRCeVVzZXJJZCIsInJlbW92ZXJQZXJtaXNzaW9ucyIsImFzc2lnbm1lbnRRdWVyeSIsInNuYXBzaG90IiwiYmF0Y2giLCJmb3JFYWNoIiwidXBkYXRlIiwicmVtb3ZlZEF0IiwicmVtb3ZlZEJ5IiwiY29tbWl0IiwiZ2V0Q29udGVudENvbGxhYm9yYXRvcnMiLCJjb2xsYWJvcmF0b3JzUXVlcnkiLCJhc3NpZ25tZW50cyIsIm1hcCIsImRhdGEiLCJ1c2VyQXNzaWdubWVudE1hcCIsImV4aXN0aW5nQXNzaWdubWVudCIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImdldFVzZXJTaGFyZWRDb250ZW50Iiwic2hhcmVkUXVlcnkiLCJzaGFyZWRDb250ZW50IiwiYXJ0aXN0cyIsIm9yZ2FuaXphdGlvbnMiLCJ2ZW51ZXMiLCJldmVudHMiLCJhY3Rpdml0aWVzIiwicHJvY2Vzc2VkQ29udGVudCIsIlNldCIsImRvY1NuYXAiLCJjb250ZW50S2V5IiwiaGFzIiwiYWRkIiwic2hhcmVkSXRlbSIsInB1c2giLCJnZXRVc2VyUGVuZGluZ0ludml0YXRpb25zIiwiaW52aXRhdGlvbnNRdWVyeSIsImFjY2VwdEludml0YXRpb24iLCJpbnZpdGF0aW9uRG9jIiwiZXhpc3RzIiwicmVzcG9uZGVkQXQiLCJpbnZpdGVkVXNlcklkIiwiYXNzaWdubWVudFJlZiIsImxvZ0NvbnRlbnRTZWN1cml0eUV2ZW50IiwicmVzdWx0IiwiZGVjbGluZUludml0YXRpb24iLCJnZXRQZXJtaXNzaW9uVGVtcGxhdGVzIiwiY2FuVmlldyIsImNhbkVkaXQiLCJjYW5JbnZpdGVPdGhlcnMiLCJjYW5WaWV3QW5hbHl0aWNzIiwiY2FuRGVsZXRlIiwiY29sbGVjdGlvbk5hbWUiLCJvd25lckZpZWxkIiwiY29udGVudERvYyIsImNvbnRlbnREYXRhIiwib3JnYW5pemF0aW9uSWQiLCJjcmVhdG9yIiwic2hhcmluZ1F1ZXJ5IiwidXNlcnNRdWVyeSIsInVzZXJEYXRhIiwiZGlzcGxheU5hbWUiLCJuYW1lRmllbGQiLCJzb3VyY2UiLCJ0cmFja1Nlc3Npb24iLCJzZXNzaW9uSWQiLCJ1c2VyU2Vzc2lvbnMiLCJhY3RpdmVDb3VudCIsImxhc3RBdHRlbXB0IiwiYXR0ZW1wdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/shared/utils/security/contentSharingSecurity.ts\n"));

/***/ })

}]);