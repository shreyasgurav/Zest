"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_domains_events_services_collaboration_service_ts"],{

/***/ "(app-pages-browser)/./src/domains/events/services/collaboration.service.ts":
/*!**************************************************************!*\
  !*** ./src/domains/events/services/collaboration.service.ts ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventCollaborationSecurity: function() { return /* binding */ EventCollaborationSecurity; }\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/infrastructure/firebase */ \"(app-pages-browser)/./src/infrastructure/firebase/index.ts\");\n/* __next_internal_client_entry_do_not_use__ EventCollaborationSecurity auto */ \n\nclass EventCollaborationSecurity {\n    /**\n   * Enhanced input validation with multiple layers of security\n   */ static validateUsername(username) {\n        if (!username || typeof username !== \"string\") {\n            return {\n                isValid: false,\n                error: \"Username is required\"\n            };\n        }\n        const trimmed = username.trim();\n        if (trimmed.length < 3) {\n            return {\n                isValid: false,\n                error: \"Username must be at least 3 characters\"\n            };\n        }\n        if (trimmed.length > 30) {\n            return {\n                isValid: false,\n                error: \"Username must be less than 30 characters\"\n            };\n        }\n        // More restrictive regex for usernames\n        const usernameRegex = /^[a-zA-Z0-9_.-]+$/;\n        if (!usernameRegex.test(trimmed)) {\n            return {\n                isValid: false,\n                error: \"Username can only contain letters, numbers, underscores, dots, and hyphens\"\n            };\n        }\n        // Security: Check for suspicious patterns\n        const suspiciousPatterns = [\n            /admin/i,\n            /root/i,\n            /system/i,\n            /api/i,\n            /null/i,\n            /undefined/i,\n            /script/i,\n            /javascript/i,\n            /eval/i,\n            /alert/i\n        ];\n        if (suspiciousPatterns.some((pattern)=>pattern.test(trimmed))) {\n            return {\n                isValid: false,\n                error: \"Username contains restricted words\"\n            };\n        }\n        return {\n            isValid: true\n        };\n    }\n    static validatePhoneNumber(phone) {\n        if (!phone || typeof phone !== \"string\") {\n            return {\n                isValid: false,\n                error: \"Phone number is required\"\n            };\n        }\n        // Remove all non-digit characters except +\n        const cleanPhone = phone.replace(/[^\\d+]/g, \"\");\n        if (!cleanPhone.startsWith(\"+\")) {\n            return {\n                isValid: false,\n                error: \"Phone number must start with country code (+)\"\n            };\n        }\n        if (cleanPhone.length < 10 || cleanPhone.length > 15) {\n            return {\n                isValid: false,\n                error: \"Phone number must be 10-15 digits including country code\"\n            };\n        }\n        // International phone number regex\n        const phoneRegex = /^\\+[1-9]\\d{1,14}$/;\n        if (!phoneRegex.test(cleanPhone)) {\n            return {\n                isValid: false,\n                error: \"Invalid phone number format\"\n            };\n        }\n        return {\n            isValid: true\n        };\n    }\n    static sanitizeInput(input) {\n        if (!input || typeof input !== \"string\") return \"\";\n        return input.trim().replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, \"\") // Remove scripts\n        .replace(/<[^>]*>/g, \"\") // Remove HTML tags\n        .replace(/javascript:/gi, \"\") // Remove javascript: URLs\n        .replace(/on\\w+\\s*=/gi, \"\") // Remove event handlers\n        .substring(0, 500); // Limit length\n    }\n    static validateMessage(message) {\n        if (!message) return {\n            isValid: true\n        }; // Message is optional\n        if (message.length > 500) {\n            return {\n                isValid: false,\n                error: \"Message must be less than 500 characters\"\n            };\n        }\n        // Check for suspicious content\n        const suspiciousPatterns = [\n            /<script/i,\n            /javascript:/i,\n            /on\\w+\\s*=/i,\n            /eval\\(/i,\n            /alert\\(/i\n        ];\n        if (suspiciousPatterns.some((pattern)=>pattern.test(message))) {\n            return {\n                isValid: false,\n                error: \"Message contains potentially harmful content\"\n            };\n        }\n        return {\n            isValid: true\n        };\n    }\n    static checkInvitationRateLimit(userId) {\n        const now = Date.now();\n        const hourMs = 60 * 60 * 1000;\n        const dailyMs = 24 * hourMs;\n        // Clean up old entries - Fix TypeScript iterator issue\n        const entriesToDelete = [];\n        this.invitationCounts.forEach((data, key)=>{\n            if (now > data.resetTime) {\n                entriesToDelete.push(key);\n            }\n        });\n        entriesToDelete.forEach((key)=>this.invitationCounts.delete(key));\n        // Check hourly limit (15 invitations per hour)\n        const hourlyKey = \"\".concat(userId, \"_hourly\");\n        const hourlyData = this.invitationCounts.get(hourlyKey);\n        if (hourlyData && hourlyData.count >= 15) {\n            return {\n                allowed: false,\n                error: \"Rate limit exceeded. You can send up to 15 invitations per hour.\"\n            };\n        }\n        // Check daily limit (100 invitations per day)\n        const dailyKey = \"\".concat(userId, \"_daily\");\n        const dailyData = this.invitationCounts.get(dailyKey);\n        if (dailyData && dailyData.count >= 100) {\n            return {\n                allowed: false,\n                error: \"Daily limit exceeded. You can send up to 100 invitations per day.\"\n            };\n        }\n        // Update counters\n        this.invitationCounts.set(hourlyKey, {\n            count: ((hourlyData === null || hourlyData === void 0 ? void 0 : hourlyData.count) || 0) + 1,\n            resetTime: (hourlyData === null || hourlyData === void 0 ? void 0 : hourlyData.resetTime) || now + hourMs\n        });\n        this.invitationCounts.set(dailyKey, {\n            count: ((dailyData === null || dailyData === void 0 ? void 0 : dailyData.count) || 0) + 1,\n            resetTime: (dailyData === null || dailyData === void 0 ? void 0 : dailyData.resetTime) || now + dailyMs\n        });\n        return {\n            allowed: true\n        };\n    }\n    /**\n   * Resource limits to prevent abuse\n   */ static async checkResourceLimits(eventId, inviterId) {\n        try {\n            // Check maximum collaborators per event (50)\n            const collaboratorsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"eventId\", \"==\", eventId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"isActive\", \"==\", true));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(collaboratorsQuery);\n            if (snapshot.size >= 50) {\n                return {\n                    allowed: false,\n                    error: \"Maximum collaborators limit reached (50 per event)\"\n                };\n            }\n            // Check maximum events shared by user (500)\n            const userEventsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"assignedBy\", \"==\", inviterId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"isActive\", \"==\", true));\n            const userSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(userEventsQuery);\n            if (userSnapshot.size >= 500) {\n                return {\n                    allowed: false,\n                    error: \"You have reached the maximum limit of shared events (500)\"\n                };\n            }\n            return {\n                allowed: true\n            };\n        } catch (error) {\n            console.error(\"Error checking resource limits:\", error);\n            return {\n                allowed: false,\n                error: \"Failed to verify resource limits\"\n            };\n        }\n    }\n    /**\n   * Permission templates for different access levels\n   */ static getPermissionTemplates() {\n        return {\n            full_management: {\n                canView: true,\n                canCheckIn: true,\n                canManageAttendees: true,\n                canViewFinancials: true,\n                canEditEvent: true,\n                canViewReports: true,\n                canSendCommunications: true,\n                role: \"full_manager\"\n            },\n            checkin_only: {\n                canView: true,\n                canCheckIn: true,\n                canManageAttendees: false,\n                canViewFinancials: false,\n                canEditEvent: false,\n                canViewReports: false,\n                canSendCommunications: false,\n                role: \"checkin_staff\"\n            }\n        };\n    }\n    /**\n   * Find page by username across all page types\n   */ static async findPageByUsername(username) {\n        try {\n            const normalizedUsername = username.toLowerCase().trim();\n            // Search all page collections\n            const [artistsQuery, organizationsQuery, venuesQuery] = await Promise.all([\n                (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"Artists\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"username\", \"==\", normalizedUsername))),\n                (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"Organisations\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"username\", \"==\", normalizedUsername))),\n                (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"Venues\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"username\", \"==\", normalizedUsername)))\n            ]);\n            if (!artistsQuery.empty) {\n                const doc = artistsQuery.docs[0];\n                const data = doc.data();\n                return {\n                    found: true,\n                    pageType: \"artist\",\n                    pageId: doc.id,\n                    pageName: data.name,\n                    ownerId: data.ownerId\n                };\n            }\n            if (!organizationsQuery.empty) {\n                const doc = organizationsQuery.docs[0];\n                const data = doc.data();\n                return {\n                    found: true,\n                    pageType: \"organization\",\n                    pageId: doc.id,\n                    pageName: data.name,\n                    ownerId: data.ownerId\n                };\n            }\n            if (!venuesQuery.empty) {\n                const doc = venuesQuery.docs[0];\n                const data = doc.data();\n                return {\n                    found: true,\n                    pageType: \"venue\",\n                    pageId: doc.id,\n                    pageName: data.name,\n                    ownerId: data.ownerId\n                };\n            }\n            return {\n                found: false,\n                error: \"Page not found with this username\"\n            };\n        } catch (error) {\n            console.error(\"Error finding page by username:\", error);\n            return {\n                found: false,\n                error: \"Failed to search for page\"\n            };\n        }\n    }\n    /**\n   * Find user by phone number\n   */ static async findUserByPhone(phone) {\n        try {\n            console.log('\\uD83D\\uDD0D Searching for user with phone: \"'.concat(phone, '\"'));\n            // ðŸš¨ DEBUG: Let's also search for a broader range of phone formats\n            const phoneVariations = [\n                phone,\n                phone.replace(/\\s/g, \"\"),\n                phone.replace(/[^\\d+]/g, \"\")\n            ];\n            // Add common Indian variations\n            if (phone.startsWith(\"+91\")) {\n                phoneVariations.push(phone.substring(3)); // Without +91\n                phoneVariations.push(\"91\" + phone.substring(3)); // With 91 prefix\n            }\n            console.log(\"\\uD83D\\uDD0D Searching phone variations:\", phoneVariations);\n            // ðŸš¨ FIX: Search for both possible phone field names\n            // Users might have phone stored as 'phone' or 'phoneNumber'\n            const usersQueryByPhone = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"Users\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"phone\", \"==\", phone));\n            const usersQueryByPhoneNumber = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"Users\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"phoneNumber\", \"==\", phone));\n            console.log(\"\\uD83D\\uDD0D Executing parallel queries for phone fields...\");\n            const [phoneSnapshot, phoneNumberSnapshot] = await Promise.all([\n                (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(usersQueryByPhone),\n                (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(usersQueryByPhoneNumber)\n            ]);\n            let userData = null;\n            let userId = null;\n            let foundField = null;\n            if (!phoneSnapshot.empty) {\n                console.log(\"âœ… Found user by 'phone' field\");\n                userData = phoneSnapshot.docs[0].data();\n                userId = phoneSnapshot.docs[0].id;\n                foundField = \"phone\";\n            } else if (!phoneNumberSnapshot.empty) {\n                console.log(\"âœ… Found user by 'phoneNumber' field\");\n                userData = phoneNumberSnapshot.docs[0].data();\n                userId = phoneNumberSnapshot.docs[0].id;\n                foundField = \"phoneNumber\";\n            } else {\n                console.log(\"âŒ No user found with exact phone: \".concat(phone));\n                // ðŸš¨ DEBUG: Let's check what phone numbers actually exist in the database\n                console.log(\"\\uD83D\\uDD0D Checking what phone numbers exist for debugging...\");\n                const allUsersQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"Users\"));\n                const allUsersSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(allUsersQuery);\n                console.log(\"\\uD83D\\uDD0D Found \".concat(allUsersSnapshot.size, \" total users in database\"));\n                allUsersSnapshot.docs.forEach((doc, index)=>{\n                    const data = doc.data();\n                    if (index < 5) {\n                        console.log(\"\\uD83D\\uDD0D User \".concat(index + 1, \":\"), {\n                            id: doc.id,\n                            phone: data.phone,\n                            phoneNumber: data.phoneNumber,\n                            name: data.name\n                        });\n                    }\n                });\n                return null;\n            }\n            const result = {\n                uid: userId,\n                name: userData.name || userData.displayName || \"Unknown User\"\n            };\n            console.log(\"âœ… User found via '\".concat(foundField, \"' field:\"), result);\n            console.log(\"\\uD83D\\uDD0D User's stored phone data:\", {\n                phone: userData.phone,\n                phoneNumber: userData.phoneNumber\n            });\n            return result;\n        } catch (error) {\n            console.error(\"Error finding user by phone:\", error);\n            return null;\n        }\n    }\n    /**\n   * Verify if user has OWNER-level access to event (for granting access to others)\n   */ static async verifyEventOwnershipAccess(eventId, userId) {\n        try {\n            const eventDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"events\", eventId));\n            if (!eventDoc.exists()) return false;\n            const eventData = eventDoc.data();\n            // Check if user is direct event owner\n            if (eventData.organizationId === userId) return true;\n            if (eventData.creator && eventData.creator.userId === userId) return true;\n            // Check if user is OWNER of the page that created this event\n            if (eventData.creator && eventData.creator.contentType && eventData.creator.contentId) {\n                const { contentType, contentId } = eventData.creator;\n                // Import ContentSharingSecurity locally to avoid circular dependency\n                const { ContentSharingSecurity } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_shared_utils_security_contentSharingSecurity_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/shared/utils/security/contentSharingSecurity */ \"(app-pages-browser)/./src/shared/utils/security/contentSharingSecurity.ts\"));\n                const permissions = await ContentSharingSecurity.verifyContentAccess(contentType, contentId, userId);\n                // Only owners of the creating page can grant access\n                return permissions.role === \"owner\";\n            }\n            return false;\n        } catch (error) {\n            console.error(\"Error verifying event ownership access:\", error);\n            return false;\n        }\n    }\n    /**\n   * Verify if user can manage event collaboration\n   */ static async verifyEventManagementAccess(eventId, userId) {\n        try {\n            const eventDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"events\", eventId));\n            if (!eventDoc.exists()) return false;\n            const eventData = eventDoc.data();\n            // Check if user is event owner\n            if (eventData.organizationId === userId) return true;\n            if (eventData.creator && eventData.creator.userId === userId) return true;\n            // Check if user has full management access through collaboration\n            const collaborationQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"eventId\", \"==\", eventId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"isActive\", \"==\", true));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(collaborationQuery);\n            for (const docSnap of snapshot.docs){\n                const assignment = docSnap.data();\n                // Check if expired\n                if (assignment.expiresAt && new Date(assignment.expiresAt) < new Date()) {\n                    continue;\n                }\n                // Check if this assignment gives the user management access\n                if (assignment.collaboratorType === \"page\" && assignment.pageOwnerId === userId) {\n                    return assignment.accessLevel === \"full_management\";\n                } else if (assignment.collaboratorType === \"user\" && assignment.userId === userId) {\n                    return assignment.accessLevel === \"full_management\";\n                }\n            }\n            return false;\n        } catch (error) {\n            console.error(\"Error verifying event management access:\", error);\n            return false;\n        }\n    }\n    /**\n   * Share session with page or user\n   */ static async shareSession(eventId, sessionId, sessionName, collaboratorType, collaboratorIdentifier, accessLevel, inviterId, inviterName, expiresInHours, message) {\n        let showOnEventPage = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : false;\n        try {\n            // ðŸš¨ ENHANCED: Verify inviter has OWNER-level management access (not just management access)\n            const hasAccess = await this.verifyEventOwnershipAccess(eventId, inviterId);\n            if (!hasAccess) {\n                return {\n                    success: false,\n                    error: \"Only event owners can grant check-in access to others\"\n                };\n            }\n            // Rate limiting\n            const rateLimitCheck = this.checkInvitationRateLimit(inviterId);\n            if (!rateLimitCheck.allowed) {\n                return {\n                    success: false,\n                    error: rateLimitCheck.error\n                };\n            }\n            // Resource limits\n            const resourceCheck = await this.checkResourceLimits(eventId, inviterId);\n            if (!resourceCheck.allowed) {\n                return {\n                    success: false,\n                    error: resourceCheck.error\n                };\n            }\n            // Get event data\n            const eventDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"events\", eventId));\n            if (!eventDoc.exists()) {\n                return {\n                    success: false,\n                    error: \"Event not found\"\n                };\n            }\n            const eventData = eventDoc.data();\n            const eventTitle = eventData.title || \"Untitled Event\";\n            const sanitizedMessage = this.sanitizeInput(message || \"\");\n            const permissions = this.getPermissionTemplates()[accessLevel];\n            if (collaboratorType === \"page\") {\n                // Validate username\n                const usernameValidation = this.validateUsername(collaboratorIdentifier);\n                if (!usernameValidation.isValid) {\n                    return {\n                        success: false,\n                        error: usernameValidation.error\n                    };\n                }\n                // Find page\n                const pageResult = await this.findPageByUsername(collaboratorIdentifier);\n                if (!pageResult.found) {\n                    return {\n                        success: false,\n                        error: pageResult.error\n                    };\n                }\n                // Check for existing assignments and invitations for this page\n                const existingAssignmentQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"eventId\", \"==\", eventId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"pageId\", \"==\", pageResult.pageId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"isActive\", \"==\", true));\n                const existingInvitationQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventInvitations\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"eventId\", \"==\", eventId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"pageId\", \"==\", pageResult.pageId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", \"pending\"));\n                const [existingSnapshot, invitationSnapshot] = await Promise.all([\n                    (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(existingAssignmentQuery),\n                    (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(existingInvitationQuery)\n                ]);\n                if (!existingSnapshot.empty) {\n                    return {\n                        success: false,\n                        error: \"This page already has access to the event\"\n                    };\n                }\n                if (!invitationSnapshot.empty) {\n                    console.log(\"\\uD83D\\uDD0D Found existing invitation. Debug info:\");\n                    const existingInvitation = invitationSnapshot.docs[0].data();\n                    console.log(\"\\uD83D\\uDD0D Existing invitation:\", {\n                        phone: existingInvitation.invitedPhone,\n                        status: existingInvitation.status,\n                        createdAt: existingInvitation.createdAt,\n                        eventTitle: existingInvitation.eventTitle\n                    });\n                    // ðŸš¨ DEBUG: Let's still run the user search to see why it failed\n                    console.log(\"\\uD83D\\uDD0D Running user search debug even though invitation exists...\");\n                    const debugUserSearch = await this.findUserByPhone(collaboratorIdentifier);\n                    console.log(\"\\uD83D\\uDD0D Debug user search result:\", debugUserSearch);\n                    return {\n                        success: false,\n                        error: \"This page already has a pending invitation for this event\"\n                    };\n                }\n                // Create invitation for page\n                const invitation = {\n                    eventId,\n                    eventTitle,\n                    sessionId,\n                    sessionName,\n                    collaboratorType: \"page\",\n                    pageType: pageResult.pageType,\n                    pageUsername: collaboratorIdentifier,\n                    pageId: pageResult.pageId,\n                    pageName: pageResult.pageName,\n                    invitedByUserId: inviterId,\n                    invitedByName: inviterName,\n                    accessLevel,\n                    permissions,\n                    message: sanitizedMessage,\n                    status: \"pending\",\n                    createdAt: new Date().toISOString(),\n                    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),\n                    showOnEventPage\n                };\n                const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventInvitations\"), {\n                    ...invitation,\n                    createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n                });\n                await this.logSecurityEvent({\n                    type: \"event_collaboration\",\n                    userId: inviterId,\n                    eventId,\n                    action: \"page_invitation_sent\",\n                    result: \"success\",\n                    details: {\n                        pageId: pageResult.pageId,\n                        pageType: pageResult.pageType,\n                        accessLevel,\n                        showOnEventPage\n                    }\n                });\n                return {\n                    success: true,\n                    invitationId: docRef.id\n                };\n            } else {\n                // ðŸš¨ FIX: Direct assignment for user collaborators - no invitation needed\n                const phoneValidation = this.validatePhoneNumber(collaboratorIdentifier);\n                if (!phoneValidation.isValid) {\n                    return {\n                        success: false,\n                        error: phoneValidation.error\n                    };\n                }\n                const sanitizedPhone = phoneValidation.isValid ? collaboratorIdentifier.replace(/[^\\d+]/g, \"\") : \"\";\n                // Only allow checkin_only access for user collaborators (security measure)\n                if (accessLevel !== \"checkin_only\") {\n                    return {\n                        success: false,\n                        error: \"User collaborators can only have check-in access\"\n                    };\n                }\n                // Check if user is already registered\n                console.log(\"\\uD83D\\uDD0D Looking for existing user with phone: \".concat(sanitizedPhone));\n                const existingUser = await this.findUserByPhone(sanitizedPhone);\n                console.log(\"\\uD83D\\uDD0D findUserByPhone result:\", existingUser);\n                if (existingUser) {\n                    console.log(\"âœ… User found, creating direct assignment for check-in access\");\n                    // Check for existing assignments for this user\n                    const existingAssignmentQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"eventId\", \"==\", eventId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"userId\", \"==\", existingUser.uid), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"isActive\", \"==\", true));\n                    const existingSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(existingAssignmentQuery);\n                    if (!existingSnapshot.empty) {\n                        return {\n                            success: false,\n                            error: \"This user already has access to the event\"\n                        };\n                    }\n                    // ðŸš¨ FIX: Create direct assignment - no invitation needed!\n                    const assignment = {\n                        eventId,\n                        eventTitle,\n                        sessionId,\n                        sessionName,\n                        collaboratorType: \"user\",\n                        userPhone: sanitizedPhone,\n                        userId: existingUser.uid,\n                        userName: existingUser.name,\n                        permissions,\n                        accessLevel,\n                        assignedBy: inviterId,\n                        assignedByName: inviterName,\n                        assignedAt: new Date().toISOString(),\n                        isActive: true,\n                        status: \"active\",\n                        notes: \"Direct check-in access granted to registered user\",\n                        invitationMessage: sanitizedMessage,\n                        showOnEventPage\n                    };\n                    // Only add expiresAt if there's an expiry time (Firestore doesn't accept undefined)\n                    if (expiresInHours) {\n                        assignment.expiresAt = new Date(Date.now() + expiresInHours * 60 * 60 * 1000).toISOString();\n                    }\n                    const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\"), {\n                        ...assignment,\n                        createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n                    });\n                    await this.logSecurityEvent({\n                        type: \"event_collaboration\",\n                        userId: inviterId,\n                        eventId,\n                        action: \"user_direct_access_granted\",\n                        result: \"success\",\n                        details: {\n                            targetUserId: existingUser.uid,\n                            accessLevel,\n                            showOnEventPage,\n                            method: \"direct_assignment\"\n                        }\n                    });\n                    console.log(\"âœ… Direct check-in access granted successfully\");\n                    return {\n                        success: true,\n                        assignmentId: docRef.id\n                    };\n                } else {\n                    console.log(\"â„¹ï¸ User not found, creating invitation for unregistered user\");\n                    // Check for existing invitations for this phone\n                    const existingInvitationQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventInvitations\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"eventId\", \"==\", eventId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"invitedPhone\", \"==\", sanitizedPhone), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", \"pending\"));\n                    const invitationSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(existingInvitationQuery);\n                    if (!invitationSnapshot.empty) {\n                        console.log(\"\\uD83D\\uDD0D Found existing invitation. Debug info:\");\n                        const existingInvitation = invitationSnapshot.docs[0].data();\n                        console.log(\"\\uD83D\\uDD0D Existing invitation:\", {\n                            phone: existingInvitation.invitedPhone,\n                            status: existingInvitation.status,\n                            createdAt: existingInvitation.createdAt,\n                            eventTitle: existingInvitation.eventTitle\n                        });\n                        // ðŸš¨ DEBUG: Let's still run the user search to see why it failed\n                        console.log(\"\\uD83D\\uDD0D Running user search debug even though invitation exists...\");\n                        const debugUserSearch = await this.findUserByPhone(collaboratorIdentifier);\n                        console.log(\"\\uD83D\\uDD0D Debug user search result:\", debugUserSearch);\n                        return {\n                            success: false,\n                            error: \"This user already has a pending invitation for this event\"\n                        };\n                    }\n                    // Create invitation for unregistered user (they'll get direct access when they register)\n                    const invitation = {\n                        eventId,\n                        eventTitle,\n                        sessionId,\n                        sessionName,\n                        collaboratorType: \"user\",\n                        invitedPhone: sanitizedPhone,\n                        invitedByUserId: inviterId,\n                        invitedByName: inviterName,\n                        accessLevel,\n                        permissions,\n                        message: sanitizedMessage,\n                        status: \"pending\",\n                        createdAt: new Date().toISOString(),\n                        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n                        showOnEventPage\n                    };\n                    const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventInvitations\"), {\n                        ...invitation,\n                        createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n                    });\n                    await this.logSecurityEvent({\n                        type: \"event_collaboration\",\n                        userId: inviterId,\n                        eventId,\n                        action: \"user_invitation_sent\",\n                        result: \"success\",\n                        details: {\n                            invitedPhone: sanitizedPhone,\n                            accessLevel,\n                            showOnEventPage\n                        }\n                    });\n                    console.log(\"âœ… Invitation created for unregistered user\");\n                    return {\n                        success: true,\n                        invitationId: docRef.id\n                    };\n                }\n            }\n        } catch (error) {\n            console.error(\"Error sharing event:\", error);\n            return {\n                success: false,\n                error: \"Failed to share event\"\n            };\n        }\n    }\n    /**\n   * Remove session collaboration\n   */ static async removeSessionAccess(eventId, sessionId, assignmentId, removedByUserId) {\n        try {\n            const hasAccess = await this.verifyEventManagementAccess(eventId, removedByUserId);\n            if (!hasAccess) {\n                return {\n                    success: false,\n                    error: \"You do not have permission to remove access\"\n                };\n            }\n            const assignmentDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\", assignmentId));\n            if (!assignmentDoc.exists()) {\n                return {\n                    success: false,\n                    error: \"Assignment not found\"\n                };\n            }\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\", assignmentId), {\n                isActive: false,\n                status: \"expired\",\n                removedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                removedBy: removedByUserId\n            });\n            await this.logSecurityEvent({\n                type: \"event_collaboration\",\n                userId: removedByUserId,\n                eventId,\n                action: \"access_removed\",\n                result: \"success\",\n                details: {\n                    assignmentId\n                }\n            });\n            return {\n                success: true\n            };\n        } catch (error) {\n            console.error(\"Error removing event access:\", error);\n            return {\n                success: false,\n                error: \"Failed to remove access\"\n            };\n        }\n    }\n    /**\n   * Get session collaborators\n   */ static async getSessionCollaborators(eventId, sessionId) {\n        try {\n            let collaboratorsQuery;\n            if (sessionId) {\n                collaboratorsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"eventId\", \"==\", eventId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"sessionId\", \"==\", sessionId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"isActive\", \"==\", true));\n            } else {\n                collaboratorsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"eventId\", \"==\", eventId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"isActive\", \"==\", true));\n            }\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(collaboratorsQuery);\n            const assignments = snapshot.docs.map((doc)=>({\n                    id: doc.id,\n                    ...doc.data()\n                }));\n            // Deduplicate and filter expired\n            const collaboratorMap = new Map();\n            for (const assignment of assignments){\n                // Skip expired assignments\n                if (assignment.expiresAt && new Date(assignment.expiresAt) < new Date()) {\n                    continue;\n                }\n                const key = assignment.collaboratorType === \"page\" ? \"page_\".concat(assignment.pageId) : \"user_\".concat(assignment.userId);\n                const existing = collaboratorMap.get(key);\n                if (!existing || new Date(assignment.assignedAt) > new Date(existing.assignedAt)) {\n                    collaboratorMap.set(key, assignment);\n                }\n            }\n            return Array.from(collaboratorMap.values());\n        } catch (error) {\n            console.error(\"Error fetching event collaborators:\", error);\n            return [];\n        }\n    }\n    /**\n   * Get events shared with user\n   */ static async getUserSharedEvents(userId) {\n        try {\n            console.log(\"\\uD83D\\uDD0D getUserSharedEvents called for userId: \".concat(userId.substring(0, 8), \"...\"));\n            // ðŸš¨ CRITICAL FIX: Add proper user filtering to prevent downloading ALL collaborations\n            const sharedQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"isActive\", \"==\", true), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"userId\", \"==\", userId) // Direct user collaborations\n            );\n            // Also need to check page-based collaborations where user owns the page\n            const pageBasedQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"isActive\", \"==\", true), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"pageOwnerId\", \"==\", userId) // Page collaborations where user owns the page\n            );\n            console.log(\"\\uD83D\\uDD0D Executing Firestore queries...\");\n            const [userSnapshot, pageSnapshot] = await Promise.all([\n                (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(sharedQuery),\n                (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(pageBasedQuery)\n            ]);\n            console.log(\"\\uD83D\\uDD0D Query results: \".concat(userSnapshot.size, \" user collaborations, \").concat(pageSnapshot.size, \" page collaborations\"));\n            const managedEvents = [];\n            const checkinEvents = [];\n            // Process direct user collaborations\n            for (const docSnap of userSnapshot.docs){\n                const assignment = docSnap.data();\n                console.log(\"\\uD83D\\uDD0D Processing user collaboration: \".concat(assignment.eventTitle, \" (\").concat(assignment.accessLevel, \")\"));\n                // Check if expired\n                if (assignment.expiresAt && new Date(assignment.expiresAt) < new Date()) {\n                    console.log(\"â° Assignment expired: \".concat(assignment.eventTitle, \" (expired at \").concat(assignment.expiresAt, \")\"));\n                    // Mark as expired in database\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(docSnap.ref, {\n                        isActive: false,\n                        status: \"expired\"\n                    });\n                    continue;\n                }\n                const eventInfo = {\n                    eventId: assignment.eventId,\n                    eventTitle: assignment.eventTitle,\n                    role: assignment.permissions.role,\n                    accessLevel: assignment.accessLevel\n                };\n                if (assignment.accessLevel === \"full_management\") {\n                    managedEvents.push(eventInfo);\n                    console.log(\"âœ… Added to managed events: \".concat(assignment.eventTitle));\n                } else {\n                    checkinEvents.push(eventInfo);\n                    console.log(\"âœ… Added to checkin events: \".concat(assignment.eventTitle));\n                }\n            }\n            // Process page-based collaborations\n            for (const docSnap of pageSnapshot.docs){\n                const assignment = docSnap.data();\n                console.log(\"\\uD83D\\uDD0D Processing page collaboration: \".concat(assignment.eventTitle, \" (\").concat(assignment.accessLevel, \") via page \").concat(assignment.pageName));\n                // Check if expired\n                if (assignment.expiresAt && new Date(assignment.expiresAt) < new Date()) {\n                    console.log(\"â° Page assignment expired: \".concat(assignment.eventTitle, \" (expired at \").concat(assignment.expiresAt, \")\"));\n                    // Mark as expired in database\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(docSnap.ref, {\n                        isActive: false,\n                        status: \"expired\"\n                    });\n                    continue;\n                }\n                const eventInfo = {\n                    eventId: assignment.eventId,\n                    eventTitle: assignment.eventTitle,\n                    role: assignment.permissions.role,\n                    accessLevel: assignment.accessLevel\n                };\n                if (assignment.accessLevel === \"full_management\") {\n                    managedEvents.push(eventInfo);\n                    console.log(\"âœ… Added page event to managed events: \".concat(assignment.eventTitle));\n                } else {\n                    checkinEvents.push(eventInfo);\n                    console.log(\"âœ… Added page event to checkin events: \".concat(assignment.eventTitle));\n                }\n            }\n            // Remove duplicates (in case user has both direct and page access to same event)\n            const uniqueManaged = Array.from(new Map(managedEvents.map((event)=>[\n                    event.eventId,\n                    event\n                ])).values());\n            const uniqueCheckin = Array.from(new Map(checkinEvents.map((event)=>[\n                    event.eventId,\n                    event\n                ])).values());\n            console.log(\"\\uD83D\\uDD0D Final results: \".concat(uniqueManaged.length, \" managed events, \").concat(uniqueCheckin.length, \" checkin events\"));\n            return {\n                managedEvents: uniqueManaged,\n                checkinEvents: uniqueCheckin\n            };\n        } catch (error) {\n            console.error(\"âŒ Error fetching user shared events:\", error);\n            return {\n                managedEvents: [],\n                checkinEvents: []\n            };\n        }\n    }\n    /**\n   * Accept event invitation\n   */ static async acceptEventInvitation(invitationId, userId, userName) {\n        try {\n            const invitationDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventInvitations\", invitationId));\n            if (!invitationDoc.exists()) {\n                return {\n                    success: false,\n                    error: \"Invitation not found\"\n                };\n            }\n            const invitation = invitationDoc.data();\n            if (invitation.status !== \"pending\" || new Date(invitation.expiresAt) < new Date()) {\n                return {\n                    success: false,\n                    error: \"Invitation has expired or already been responded to\"\n                };\n            }\n            const assignment = {\n                eventId: invitation.eventId,\n                eventTitle: invitation.eventTitle,\n                sessionId: invitation.sessionId,\n                sessionName: invitation.sessionName,\n                collaboratorType: invitation.collaboratorType,\n                userPhone: invitation.invitedPhone,\n                userId,\n                userName,\n                permissions: invitation.permissions,\n                accessLevel: invitation.accessLevel,\n                assignedBy: invitation.invitedByUserId,\n                assignedByName: invitation.invitedByName,\n                assignedAt: new Date().toISOString(),\n                isActive: true,\n                status: \"active\",\n                notes: \"Accepted invitation: \".concat(invitation.message),\n                invitationMessage: invitation.message,\n                showOnEventPage: invitation.showOnEventPage\n            };\n            const batch = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.writeBatch)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)());\n            // Update invitation status\n            batch.update((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventInvitations\", invitationId), {\n                status: \"accepted\",\n                respondedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                invitedUserId: userId\n            });\n            // Create collaboration assignment\n            const assignmentRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\"));\n            batch.set(assignmentRef, {\n                ...assignment,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n            });\n            await batch.commit();\n            await this.logSecurityEvent({\n                type: \"event_collaboration\",\n                userId,\n                eventId: invitation.eventId,\n                action: \"invitation_accepted\",\n                result: \"success\",\n                details: {\n                    invitationId,\n                    accessLevel: invitation.accessLevel\n                }\n            });\n            return {\n                success: true\n            };\n        } catch (error) {\n            console.error(\"Error accepting invitation:\", error);\n            return {\n                success: false,\n                error: \"Failed to accept invitation\"\n            };\n        }\n    }\n    /**\n   * Verify event access for user\n   */ static async verifyEventAccess(eventId, userId) {\n        try {\n            console.log(\"\\uD83D\\uDD0D verifyEventAccess: Checking access for user \".concat(userId.substring(0, 8), \"... to event \").concat(eventId));\n            // Get event data\n            const eventDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"events\", eventId));\n            if (!eventDoc.exists()) {\n                console.log(\"âŒ verifyEventAccess: Event \".concat(eventId, \" not found\"));\n                return this.unauthorizedPermissions();\n            }\n            const eventData = eventDoc.data();\n            console.log(\"\\uD83D\\uDCC5 verifyEventAccess: Event found - \".concat(eventData.title));\n            // Check if user is event owner\n            if (eventData.organizationId === userId || eventData.creator && eventData.creator.userId === userId) {\n                console.log(\"âœ… verifyEventAccess: User is event owner\");\n                return {\n                    canView: true,\n                    canCheckIn: true,\n                    canManageAttendees: true,\n                    canViewFinancials: true,\n                    canEditEvent: true,\n                    canViewReports: true,\n                    canSendCommunications: true,\n                    role: \"event_owner\"\n                };\n            }\n            // Check collaboration permissions\n            console.log(\"\\uD83D\\uDD0D verifyEventAccess: Checking collaboration permissions...\");\n            const collaborationQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventCollaboration\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"eventId\", \"==\", eventId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"isActive\", \"==\", true));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(collaborationQuery);\n            console.log(\"\\uD83D\\uDD0D verifyEventAccess: Found \".concat(snapshot.size, \" collaboration records\"));\n            for (const docSnap of snapshot.docs){\n                var _assignment_userId, _assignment_pageOwnerId;\n                const assignment = docSnap.data();\n                console.log(\"\\uD83D\\uDD0D verifyEventAccess: Checking assignment:\", {\n                    collaboratorType: assignment.collaboratorType,\n                    userId: (_assignment_userId = assignment.userId) === null || _assignment_userId === void 0 ? void 0 : _assignment_userId.substring(0, 8),\n                    pageOwnerId: (_assignment_pageOwnerId = assignment.pageOwnerId) === null || _assignment_pageOwnerId === void 0 ? void 0 : _assignment_pageOwnerId.substring(0, 8),\n                    accessLevel: assignment.accessLevel,\n                    isActive: assignment.isActive,\n                    expiresAt: assignment.expiresAt\n                });\n                // Check if expired\n                if (assignment.expiresAt && new Date(assignment.expiresAt) < new Date()) {\n                    console.log(\"â° verifyEventAccess: Assignment expired at \".concat(assignment.expiresAt));\n                    continue;\n                }\n                // Check if this assignment gives the user access\n                if (assignment.collaboratorType === \"page\" && assignment.pageOwnerId === userId) {\n                    console.log(\"âœ… verifyEventAccess: Found page-based access for user\");\n                    return assignment.permissions;\n                } else if (assignment.collaboratorType === \"user\" && assignment.userId === userId) {\n                    console.log(\"âœ… verifyEventAccess: Found direct user access\");\n                    return assignment.permissions;\n                }\n            }\n            console.log(\"âŒ verifyEventAccess: No collaboration access found for user \".concat(userId.substring(0, 8), \"...\"));\n            return this.unauthorizedPermissions();\n        } catch (error) {\n            console.error(\"âŒ verifyEventAccess: Error verifying event access:\", error);\n            return this.unauthorizedPermissions();\n        }\n    }\n    /**\n   * Get pending invitations for user phone\n   */ static async getUserPendingInvitations(userPhone) {\n        try {\n            const invitationsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"eventInvitations\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"invitedPhone\", \"==\", userPhone), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", \"pending\"));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(invitationsQuery);\n            return snapshot.docs.map((doc)=>({\n                    id: doc.id,\n                    ...doc.data()\n                }));\n        } catch (error) {\n            console.error(\"Error fetching pending invitations:\", error);\n            return [];\n        }\n    }\n    /**\n   * Security logging\n   */ static async logSecurityEvent(event) {\n        try {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)((0,_infrastructure_firebase__WEBPACK_IMPORTED_MODULE_1__.db)(), \"securityEvents\"), {\n                ...event,\n                timestamp: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                source: \"event_collaboration_security\"\n            });\n        } catch (error) {\n            console.error(\"Error logging security event:\", error);\n        }\n    }\n    static unauthorizedPermissions() {\n        return {\n            canView: false,\n            canCheckIn: false,\n            canManageAttendees: false,\n            canViewFinancials: false,\n            canEditEvent: false,\n            canViewReports: false,\n            canSendCommunications: false,\n            role: \"unauthorized\"\n        };\n    }\n}\n/**\n   * Rate limiting for event collaboration invitations\n   */ EventCollaborationSecurity.invitationCounts = new Map();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9kb21haW5zL2V2ZW50cy9zZXJ2aWNlcy9jb2xsYWJvcmF0aW9uLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O2dGQWM0QjtBQUNtQjtBQXVGeEMsTUFBTVc7SUFFWDs7R0FFQyxHQUNELE9BQU9DLGlCQUFpQkMsUUFBZ0IsRUFBd0M7UUFDOUUsSUFBSSxDQUFDQSxZQUFZLE9BQU9BLGFBQWEsVUFBVTtZQUM3QyxPQUFPO2dCQUFFQyxTQUFTO2dCQUFPQyxPQUFPO1lBQXVCO1FBQ3pEO1FBRUEsTUFBTUMsVUFBVUgsU0FBU0ksSUFBSTtRQUU3QixJQUFJRCxRQUFRRSxNQUFNLEdBQUcsR0FBRztZQUN0QixPQUFPO2dCQUFFSixTQUFTO2dCQUFPQyxPQUFPO1lBQXlDO1FBQzNFO1FBRUEsSUFBSUMsUUFBUUUsTUFBTSxHQUFHLElBQUk7WUFDdkIsT0FBTztnQkFBRUosU0FBUztnQkFBT0MsT0FBTztZQUEyQztRQUM3RTtRQUVBLHVDQUF1QztRQUN2QyxNQUFNSSxnQkFBZ0I7UUFDdEIsSUFBSSxDQUFDQSxjQUFjQyxJQUFJLENBQUNKLFVBQVU7WUFDaEMsT0FBTztnQkFBRUYsU0FBUztnQkFBT0MsT0FBTztZQUE2RTtRQUMvRztRQUVBLDBDQUEwQztRQUMxQyxNQUFNTSxxQkFBcUI7WUFDekI7WUFBVTtZQUFTO1lBQVc7WUFBUTtZQUFTO1lBQy9DO1lBQVc7WUFBZTtZQUFTO1NBQ3BDO1FBRUQsSUFBSUEsbUJBQW1CQyxJQUFJLENBQUNDLENBQUFBLFVBQVdBLFFBQVFILElBQUksQ0FBQ0osV0FBVztZQUM3RCxPQUFPO2dCQUFFRixTQUFTO2dCQUFPQyxPQUFPO1lBQXFDO1FBQ3ZFO1FBRUEsT0FBTztZQUFFRCxTQUFTO1FBQUs7SUFDekI7SUFFQSxPQUFPVSxvQkFBb0JDLEtBQWEsRUFBd0M7UUFDOUUsSUFBSSxDQUFDQSxTQUFTLE9BQU9BLFVBQVUsVUFBVTtZQUN2QyxPQUFPO2dCQUFFWCxTQUFTO2dCQUFP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Y29sbGFib3JhdGlvbi5zZXJ2aWNlLnRzP2Q3NDciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyBcbiAgY29sbGVjdGlvbiwgXG4gIGRvYywgXG4gIGdldERvYywgXG4gIGdldERvY3MsIFxuICBhZGREb2MsIFxuICB1cGRhdGVEb2MsIFxuICB3cml0ZUJhdGNoLCBcbiAgcXVlcnksIFxuICB3aGVyZSwgXG4gIHNlcnZlclRpbWVzdGFtcCxcbiAgVGltZXN0YW1wXG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5pbXBvcnQgeyBkYiB9IGZyb20gJ0AvaW5mcmFzdHJ1Y3R1cmUvZmlyZWJhc2UnO1xuaW1wb3J0IHsgZ2V0VXNlck93bmVkUGFnZXMgfSBmcm9tICdAL2RvbWFpbnMvYXV0aGVudGljYXRpb24vc2VydmljZXMvYXV0aC5zZXJ2aWNlJztcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudFBlcm1pc3Npb25zIHtcbiAgY2FuVmlldzogYm9vbGVhbjtcbiAgY2FuQ2hlY2tJbjogYm9vbGVhbjtcbiAgY2FuTWFuYWdlQXR0ZW5kZWVzOiBib29sZWFuO1xuICBjYW5WaWV3RmluYW5jaWFsczogYm9vbGVhbjtcbiAgY2FuRWRpdEV2ZW50OiBib29sZWFuO1xuICBjYW5WaWV3UmVwb3J0czogYm9vbGVhbjtcbiAgY2FuU2VuZENvbW11bmljYXRpb25zOiBib29sZWFuO1xuICByb2xlOiAnZXZlbnRfb3duZXInIHwgJ2Z1bGxfbWFuYWdlcicgfCAnY2hlY2tpbl9zdGFmZicgfCAndmlld2VyJyB8ICd1bmF1dGhvcml6ZWQnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50Q29sbGFib3JhdGlvbkFzc2lnbm1lbnQge1xuICBpZD86IHN0cmluZztcbiAgZXZlbnRJZDogc3RyaW5nO1xuICBldmVudFRpdGxlOiBzdHJpbmc7XG4gIHNlc3Npb25JZDogc3RyaW5nO1xuICBzZXNzaW9uTmFtZTogc3RyaW5nO1xuICBcbiAgLy8gQ29sbGFib3JhdG9yIGluZm8gKGVpdGhlciBwYWdlIG9yIHVzZXIpXG4gIGNvbGxhYm9yYXRvclR5cGU6ICdwYWdlJyB8ICd1c2VyJztcbiAgXG4gIC8vIEZvciBwYWdlIGNvbGxhYm9yYXRvcnNcbiAgcGFnZVR5cGU/OiAnYXJ0aXN0JyB8ICdvcmdhbml6YXRpb24nIHwgJ3ZlbnVlJztcbiAgcGFnZUlkPzogc3RyaW5nO1xuICBwYWdlTmFtZT86IHN0cmluZztcbiAgcGFnZVVzZXJuYW1lPzogc3RyaW5nO1xuICBwYWdlT3duZXJJZD86IHN0cmluZzsgLy8gVGhlIGFjdHVhbCB1c2VyIHdobyBvd25zIHRoZSBwYWdlXG4gIFxuICAvLyBGb3IgdXNlciBjb2xsYWJvcmF0b3JzICBcbiAgdXNlclBob25lPzogc3RyaW5nO1xuICB1c2VySWQ/OiBzdHJpbmc7XG4gIHVzZXJOYW1lPzogc3RyaW5nO1xuICBcbiAgLy8gUGVybWlzc2lvbnNcbiAgcGVybWlzc2lvbnM6IEV2ZW50UGVybWlzc2lvbnM7XG4gIGFjY2Vzc0xldmVsOiAnZnVsbF9tYW5hZ2VtZW50JyB8ICdjaGVja2luX29ubHknO1xuICBcbiAgLy8gQXNzaWdubWVudCBtZXRhZGF0YVxuICBhc3NpZ25lZEJ5OiBzdHJpbmc7XG4gIGFzc2lnbmVkQnlOYW1lOiBzdHJpbmc7XG4gIGFzc2lnbmVkQXQ6IHN0cmluZztcbiAgZXhwaXJlc0F0Pzogc3RyaW5nOyAvLyBPcHRpb25hbCAtIG9ubHkgcHJlc2VudCB3aGVuIHRoZXJlJ3MgYW4gZXhwaXJ5IGRhdGVcbiAgaXNBY3RpdmU6IGJvb2xlYW47XG4gIHN0YXR1czogJ2FjdGl2ZScgfCAncGVuZGluZycgfCAnZGVjbGluZWQnIHwgJ2V4cGlyZWQnO1xuICBub3Rlczogc3RyaW5nO1xuICBpbnZpdGF0aW9uTWVzc2FnZTogc3RyaW5nO1xuICBcbiAgLy8gRXZlbnQgdmlzaWJpbGl0eVxuICBzaG93T25FdmVudFBhZ2U6IGJvb2xlYW47IC8vIFdoZXRoZXIgdG8gc2hvdyB0aGlzIGNvbGxhYm9yYXRvciBvbiB0aGUgcHVibGljIGV2ZW50IHBhZ2Vcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFdmVudEludml0YXRpb24ge1xuICBpZD86IHN0cmluZztcbiAgZXZlbnRJZDogc3RyaW5nO1xuICBldmVudFRpdGxlOiBzdHJpbmc7XG4gIHNlc3Npb25JZDogc3RyaW5nO1xuICBzZXNzaW9uTmFtZTogc3RyaW5nO1xuICBcbiAgLy8gSW52aXRhdGlvbiB0YXJnZXQgKGVpdGhlciBwYWdlIG9yIHVzZXIpXG4gIGNvbGxhYm9yYXRvclR5cGU6ICdwYWdlJyB8ICd1c2VyJztcbiAgXG4gIC8vIEZvciBwYWdlIGludml0YXRpb25zXG4gIHBhZ2VUeXBlPzogJ2FydGlzdCcgfCAnb3JnYW5pemF0aW9uJyB8ICd2ZW51ZSc7XG4gIHBhZ2VVc2VybmFtZT86IHN0cmluZzsgLy8gVGhlIHVzZXJuYW1lIHRvIGxvb2t1cCB0aGUgcGFnZVxuICBwYWdlSWQ/OiBzdHJpbmc7IC8vIFNldCBhZnRlciBmaW5kaW5nIHRoZSBwYWdlXG4gIHBhZ2VOYW1lPzogc3RyaW5nOyAvLyBTZXQgYWZ0ZXIgZmluZGluZyB0aGUgcGFnZVxuICBcbiAgLy8gRm9yIHVzZXIgaW52aXRhdGlvbnNcbiAgaW52aXRlZFBob25lPzogc3RyaW5nO1xuICBpbnZpdGVkVXNlcklkPzogc3RyaW5nOyAvLyBTZXQgd2hlbiB1c2VyIGFjY2VwdHNcbiAgXG4gIC8vIEludml0YXRpb24gbWV0YWRhdGFcbiAgaW52aXRlZEJ5VXNlcklkOiBzdHJpbmc7XG4gIGludml0ZWRCeU5hbWU6IHN0cmluZztcbiAgYWNjZXNzTGV2ZWw6ICdmdWxsX21hbmFnZW1lbnQnIHwgJ2NoZWNraW5fb25seSc7XG4gIHBlcm1pc3Npb25zOiBFdmVudFBlcm1pc3Npb25zO1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIHN0YXR1czogJ3BlbmRpbmcnIHwgJ2FjY2VwdGVkJyB8ICdkZWNsaW5lZCcgfCAnZXhwaXJlZCc7XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xuICByZXNwb25kZWRBdD86IHN0cmluZztcbiAgZXhwaXJlc0F0OiBzdHJpbmc7XG4gIHNob3dPbkV2ZW50UGFnZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIEV2ZW50Q29sbGFib3JhdGlvblNlY3VyaXR5IHtcbiAgXG4gIC8qKlxuICAgKiBFbmhhbmNlZCBpbnB1dCB2YWxpZGF0aW9uIHdpdGggbXVsdGlwbGUgbGF5ZXJzIG9mIHNlY3VyaXR5XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVVc2VybmFtZSh1c2VybmFtZTogc3RyaW5nKTogeyBpc1ZhbGlkOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9IHtcbiAgICBpZiAoIXVzZXJuYW1lIHx8IHR5cGVvZiB1c2VybmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogJ1VzZXJuYW1lIGlzIHJlcXVpcmVkJyB9O1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB0cmltbWVkID0gdXNlcm5hbWUudHJpbSgpO1xuICAgIFxuICAgIGlmICh0cmltbWVkLmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogJ1VzZXJuYW1lIG11c3QgYmUgYXQgbGVhc3QgMyBjaGFyYWN0ZXJzJyB9O1xuICAgIH1cbiAgICBcbiAgICBpZiAodHJpbW1lZC5sZW5ndGggPiAzMCkge1xuICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiAnVXNlcm5hbWUgbXVzdCBiZSBsZXNzIHRoYW4gMzAgY2hhcmFjdGVycycgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gTW9yZSByZXN0cmljdGl2ZSByZWdleCBmb3IgdXNlcm5hbWVzXG4gICAgY29uc3QgdXNlcm5hbWVSZWdleCA9IC9eW2EtekEtWjAtOV8uLV0rJC87XG4gICAgaWYgKCF1c2VybmFtZVJlZ2V4LnRlc3QodHJpbW1lZCkpIHtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogJ1VzZXJuYW1lIGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycywgdW5kZXJzY29yZXMsIGRvdHMsIGFuZCBoeXBoZW5zJyB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBTZWN1cml0eTogQ2hlY2sgZm9yIHN1c3BpY2lvdXMgcGF0dGVybnNcbiAgICBjb25zdCBzdXNwaWNpb3VzUGF0dGVybnMgPSBbXG4gICAgICAvYWRtaW4vaSwgL3Jvb3QvaSwgL3N5c3RlbS9pLCAvYXBpL2ksIC9udWxsL2ksIC91bmRlZmluZWQvaSxcbiAgICAgIC9zY3JpcHQvaSwgL2phdmFzY3JpcHQvaSwgL2V2YWwvaSwgL2FsZXJ0L2lcbiAgICBdO1xuICAgIFxuICAgIGlmIChzdXNwaWNpb3VzUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdCh0cmltbWVkKSkpIHtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogJ1VzZXJuYW1lIGNvbnRhaW5zIHJlc3RyaWN0ZWQgd29yZHMnIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbiAgfVxuICBcbiAgc3RhdGljIHZhbGlkYXRlUGhvbmVOdW1iZXIocGhvbmU6IHN0cmluZyk6IHsgaXNWYWxpZDogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfSB7XG4gICAgaWYgKCFwaG9uZSB8fCB0eXBlb2YgcGhvbmUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6ICdQaG9uZSBudW1iZXIgaXMgcmVxdWlyZWQnIH07XG4gICAgfVxuICAgIFxuICAgIC8vIFJlbW92ZSBhbGwgbm9uLWRpZ2l0IGNoYXJhY3RlcnMgZXhjZXB0ICtcbiAgICBjb25zdCBjbGVhblBob25lID0gcGhvbmUucmVwbGFjZSgvW15cXGQrXS9nLCAnJyk7XG4gICAgXG4gICAgaWYgKCFjbGVhblBob25lLnN0YXJ0c1dpdGgoJysnKSkge1xuICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiAnUGhvbmUgbnVtYmVyIG11c3Qgc3RhcnQgd2l0aCBjb3VudHJ5IGNvZGUgKCspJyB9O1xuICAgIH1cbiAgICBcbiAgICBpZiAoY2xlYW5QaG9uZS5sZW5ndGggPCAxMCB8fCBjbGVhblBob25lLmxlbmd0aCA+IDE1KSB7XG4gICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6ICdQaG9uZSBudW1iZXIgbXVzdCBiZSAxMC0xNSBkaWdpdHMgaW5jbHVkaW5nIGNvdW50cnkgY29kZScgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gSW50ZXJuYXRpb25hbCBwaG9uZSBudW1iZXIgcmVnZXhcbiAgICBjb25zdCBwaG9uZVJlZ2V4ID0gL15cXCtbMS05XVxcZHsxLDE0fSQvO1xuICAgIGlmICghcGhvbmVSZWdleC50ZXN0KGNsZWFuUGhvbmUpKSB7XG4gICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIHBob25lIG51bWJlciBmb3JtYXQnIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbiAgfVxuICBcbiAgc3RhdGljIHNhbml0aXplSW5wdXQoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSByZXR1cm4gJyc7XG4gICAgXG4gICAgcmV0dXJuIGlucHV0XG4gICAgICAudHJpbSgpXG4gICAgICAucmVwbGFjZSgvPHNjcmlwdFxcYltePF0qKD86KD8hPFxcL3NjcmlwdD4pPFtePF0qKSo8XFwvc2NyaXB0Pi9naSwgJycpIC8vIFJlbW92ZSBzY3JpcHRzXG4gICAgICAucmVwbGFjZSgvPFtePl0qPi9nLCAnJykgLy8gUmVtb3ZlIEhUTUwgdGFnc1xuICAgICAgLnJlcGxhY2UoL2phdmFzY3JpcHQ6L2dpLCAnJykgLy8gUmVtb3ZlIGphdmFzY3JpcHQ6IFVSTHNcbiAgICAgIC5yZXBsYWNlKC9vblxcdytcXHMqPS9naSwgJycpIC8vIFJlbW92ZSBldmVudCBoYW5kbGVyc1xuICAgICAgLnN1YnN0cmluZygwLCA1MDApOyAvLyBMaW1pdCBsZW5ndGhcbiAgfVxuICBcbiAgc3RhdGljIHZhbGlkYXRlTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiB7IGlzVmFsaWQ6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0ge1xuICAgIGlmICghbWVzc2FnZSkgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9OyAvLyBNZXNzYWdlIGlzIG9wdGlvbmFsXG4gICAgXG4gICAgaWYgKG1lc3NhZ2UubGVuZ3RoID4gNTAwKSB7XG4gICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6ICdNZXNzYWdlIG11c3QgYmUgbGVzcyB0aGFuIDUwMCBjaGFyYWN0ZXJzJyB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBmb3Igc3VzcGljaW91cyBjb250ZW50XG4gICAgY29uc3Qgc3VzcGljaW91c1BhdHRlcm5zID0gW1xuICAgICAgLzxzY3JpcHQvaSwgL2phdmFzY3JpcHQ6L2ksIC9vblxcdytcXHMqPS9pLCAvZXZhbFxcKC9pLCAvYWxlcnRcXCgvaVxuICAgIF07XG4gICAgXG4gICAgaWYgKHN1c3BpY2lvdXNQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcGF0dGVybi50ZXN0KG1lc3NhZ2UpKSkge1xuICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiAnTWVzc2FnZSBjb250YWlucyBwb3RlbnRpYWxseSBoYXJtZnVsIGNvbnRlbnQnIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJhdGUgbGltaXRpbmcgZm9yIGV2ZW50IGNvbGxhYm9yYXRpb24gaW52aXRhdGlvbnNcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGludml0YXRpb25Db3VudHMgPSBuZXcgTWFwPHN0cmluZywgeyBjb3VudDogbnVtYmVyOyByZXNldFRpbWU6IG51bWJlciB9PigpO1xuICBcbiAgc3RhdGljIGNoZWNrSW52aXRhdGlvblJhdGVMaW1pdCh1c2VySWQ6IHN0cmluZyk6IHsgYWxsb3dlZDogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBob3VyTXMgPSA2MCAqIDYwICogMTAwMDtcbiAgICBjb25zdCBkYWlseU1zID0gMjQgKiBob3VyTXM7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgb2xkIGVudHJpZXMgLSBGaXggVHlwZVNjcmlwdCBpdGVyYXRvciBpc3N1ZVxuICAgIGNvbnN0IGVudHJpZXNUb0RlbGV0ZTogc3RyaW5nW10gPSBbXTtcbiAgICB0aGlzLmludml0YXRpb25Db3VudHMuZm9yRWFjaCgoZGF0YSwga2V5KSA9PiB7XG4gICAgICBpZiAobm93ID4gZGF0YS5yZXNldFRpbWUpIHtcbiAgICAgICAgZW50cmllc1RvRGVsZXRlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlbnRyaWVzVG9EZWxldGUuZm9yRWFjaChrZXkgPT4gdGhpcy5pbnZpdGF0aW9uQ291bnRzLmRlbGV0ZShrZXkpKTtcbiAgICBcbiAgICAvLyBDaGVjayBob3VybHkgbGltaXQgKDE1IGludml0YXRpb25zIHBlciBob3VyKVxuICAgIGNvbnN0IGhvdXJseUtleSA9IGAke3VzZXJJZH1faG91cmx5YDtcbiAgICBjb25zdCBob3VybHlEYXRhID0gdGhpcy5pbnZpdGF0aW9uQ291bnRzLmdldChob3VybHlLZXkpO1xuICAgIFxuICAgIGlmIChob3VybHlEYXRhICYmIGhvdXJseURhdGEuY291bnQgPj0gMTUpIHtcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBhbGxvd2VkOiBmYWxzZSwgXG4gICAgICAgIGVycm9yOiAnUmF0ZSBsaW1pdCBleGNlZWRlZC4gWW91IGNhbiBzZW5kIHVwIHRvIDE1IGludml0YXRpb25zIHBlciBob3VyLicgXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBkYWlseSBsaW1pdCAoMTAwIGludml0YXRpb25zIHBlciBkYXkpXG4gICAgY29uc3QgZGFpbHlLZXkgPSBgJHt1c2VySWR9X2RhaWx5YDtcbiAgICBjb25zdCBkYWlseURhdGEgPSB0aGlzLmludml0YXRpb25Db3VudHMuZ2V0KGRhaWx5S2V5KTtcbiAgICBcbiAgICBpZiAoZGFpbHlEYXRhICYmIGRhaWx5RGF0YS5jb3VudCA+PSAxMDApIHtcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBhbGxvd2VkOiBmYWxzZSwgXG4gICAgICAgIGVycm9yOiAnRGFpbHkgbGltaXQgZXhjZWVkZWQuIFlvdSBjYW4gc2VuZCB1cCB0byAxMDAgaW52aXRhdGlvbnMgcGVyIGRheS4nIFxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIGNvdW50ZXJzXG4gICAgdGhpcy5pbnZpdGF0aW9uQ291bnRzLnNldChob3VybHlLZXksIHtcbiAgICAgIGNvdW50OiAoaG91cmx5RGF0YT8uY291bnQgfHwgMCkgKyAxLFxuICAgICAgcmVzZXRUaW1lOiBob3VybHlEYXRhPy5yZXNldFRpbWUgfHwgKG5vdyArIGhvdXJNcylcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLmludml0YXRpb25Db3VudHMuc2V0KGRhaWx5S2V5LCB7XG4gICAgICBjb3VudDogKGRhaWx5RGF0YT8uY291bnQgfHwgMCkgKyAxLFxuICAgICAgcmVzZXRUaW1lOiBkYWlseURhdGE/LnJlc2V0VGltZSB8fCAobm93ICsgZGFpbHlNcylcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4geyBhbGxvd2VkOiB0cnVlIH07XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXNvdXJjZSBsaW1pdHMgdG8gcHJldmVudCBhYnVzZVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNoZWNrUmVzb3VyY2VMaW1pdHMoZXZlbnRJZDogc3RyaW5nLCBpbnZpdGVySWQ6IHN0cmluZyk6IFByb21pc2U8eyBhbGxvd2VkOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIG1heGltdW0gY29sbGFib3JhdG9ycyBwZXIgZXZlbnQgKDUwKVxuICAgICAgY29uc3QgY29sbGFib3JhdG9yc1F1ZXJ5ID0gcXVlcnkoXG4gICAgICAgIGNvbGxlY3Rpb24oZGIoKSwgJ2V2ZW50Q29sbGFib3JhdGlvbicpLFxuICAgICAgICB3aGVyZSgnZXZlbnRJZCcsICc9PScsIGV2ZW50SWQpLFxuICAgICAgICB3aGVyZSgnaXNBY3RpdmUnLCAnPT0nLCB0cnVlKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGNvbGxhYm9yYXRvcnNRdWVyeSk7XG4gICAgICBcbiAgICAgIGlmIChzbmFwc2hvdC5zaXplID49IDUwKSB7XG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgIGFsbG93ZWQ6IGZhbHNlLCBcbiAgICAgICAgICBlcnJvcjogJ01heGltdW0gY29sbGFib3JhdG9ycyBsaW1pdCByZWFjaGVkICg1MCBwZXIgZXZlbnQpJyBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgbWF4aW11bSBldmVudHMgc2hhcmVkIGJ5IHVzZXIgKDUwMClcbiAgICAgIGNvbnN0IHVzZXJFdmVudHNRdWVyeSA9IHF1ZXJ5KFxuICAgICAgICBjb2xsZWN0aW9uKGRiKCksICdldmVudENvbGxhYm9yYXRpb24nKSxcbiAgICAgICAgd2hlcmUoJ2Fzc2lnbmVkQnknLCAnPT0nLCBpbnZpdGVySWQpLFxuICAgICAgICB3aGVyZSgnaXNBY3RpdmUnLCAnPT0nLCB0cnVlKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3QgdXNlclNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyh1c2VyRXZlbnRzUXVlcnkpO1xuICAgICAgXG4gICAgICBpZiAodXNlclNuYXBzaG90LnNpemUgPj0gNTAwKSB7XG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgIGFsbG93ZWQ6IGZhbHNlLCBcbiAgICAgICAgICBlcnJvcjogJ1lvdSBoYXZlIHJlYWNoZWQgdGhlIG1heGltdW0gbGltaXQgb2Ygc2hhcmVkIGV2ZW50cyAoNTAwKScgXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7IGFsbG93ZWQ6IHRydWUgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgcmVzb3VyY2UgbGltaXRzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IGFsbG93ZWQ6IGZhbHNlLCBlcnJvcjogJ0ZhaWxlZCB0byB2ZXJpZnkgcmVzb3VyY2UgbGltaXRzJyB9O1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFBlcm1pc3Npb24gdGVtcGxhdGVzIGZvciBkaWZmZXJlbnQgYWNjZXNzIGxldmVsc1xuICAgKi9cbiAgc3RhdGljIGdldFBlcm1pc3Npb25UZW1wbGF0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZ1bGxfbWFuYWdlbWVudDoge1xuICAgICAgICBjYW5WaWV3OiB0cnVlLFxuICAgICAgICBjYW5DaGVja0luOiB0cnVlLFxuICAgICAgICBjYW5NYW5hZ2VBdHRlbmRlZXM6IHRydWUsXG4gICAgICAgIGNhblZpZXdGaW5hbmNpYWxzOiB0cnVlLFxuICAgICAgICBjYW5FZGl0RXZlbnQ6IHRydWUsXG4gICAgICAgIGNhblZpZXdSZXBvcnRzOiB0cnVlLFxuICAgICAgICBjYW5TZW5kQ29tbXVuaWNhdGlvbnM6IHRydWUsXG4gICAgICAgIHJvbGU6ICdmdWxsX21hbmFnZXInIGFzIGNvbnN0XG4gICAgICB9LFxuICAgICAgY2hlY2tpbl9vbmx5OiB7XG4gICAgICAgIGNhblZpZXc6IHRydWUsXG4gICAgICAgIGNhbkNoZWNrSW46IHRydWUsXG4gICAgICAgIGNhbk1hbmFnZUF0dGVuZGVlczogZmFsc2UsXG4gICAgICAgIGNhblZpZXdGaW5hbmNpYWxzOiBmYWxzZSxcbiAgICAgICAgY2FuRWRpdEV2ZW50OiBmYWxzZSxcbiAgICAgICAgY2FuVmlld1JlcG9ydHM6IGZhbHNlLFxuICAgICAgICBjYW5TZW5kQ29tbXVuaWNhdGlvbnM6IGZhbHNlLFxuICAgICAgICByb2xlOiAnY2hlY2tpbl9zdGFmZicgYXMgY29uc3RcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIFxuICAvKipcbiAgICogRmluZCBwYWdlIGJ5IHVzZXJuYW1lIGFjcm9zcyBhbGwgcGFnZSB0eXBlc1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZpbmRQYWdlQnlVc2VybmFtZSh1c2VybmFtZTogc3RyaW5nKTogUHJvbWlzZTx7XG4gICAgZm91bmQ6IGJvb2xlYW47XG4gICAgcGFnZVR5cGU/OiAnYXJ0aXN0JyB8ICdvcmdhbml6YXRpb24nIHwgJ3ZlbnVlJztcbiAgICBwYWdlSWQ/OiBzdHJpbmc7XG4gICAgcGFnZU5hbWU/OiBzdHJpbmc7XG4gICAgb3duZXJJZD86IHN0cmluZztcbiAgICBlcnJvcj86IHN0cmluZztcbiAgfT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkVXNlcm5hbWUgPSB1c2VybmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgIFxuICAgICAgLy8gU2VhcmNoIGFsbCBwYWdlIGNvbGxlY3Rpb25zXG4gICAgICBjb25zdCBbYXJ0aXN0c1F1ZXJ5LCBvcmdhbml6YXRpb25zUXVlcnksIHZlbnVlc1F1ZXJ5XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0RG9jcyhxdWVyeShjb2xsZWN0aW9uKGRiKCksICdBcnRpc3RzJyksIHdoZXJlKCd1c2VybmFtZScsICc9PScsIG5vcm1hbGl6ZWRVc2VybmFtZSkpKSxcbiAgICAgICAgZ2V0RG9jcyhxdWVyeShjb2xsZWN0aW9uKGRiKCksICdPcmdhbmlzYXRpb25zJyksIHdoZXJlKCd1c2VybmFtZScsICc9PScsIG5vcm1hbGl6ZWRVc2VybmFtZSkpKSxcbiAgICAgICAgZ2V0RG9jcyhxdWVyeShjb2xsZWN0aW9uKGRiKCksICdWZW51ZXMnKSwgd2hlcmUoJ3VzZXJuYW1lJywgJz09Jywgbm9ybWFsaXplZFVzZXJuYW1lKSkpXG4gICAgICBdKTtcbiAgICAgIFxuICAgICAgaWYgKCFhcnRpc3RzUXVlcnkuZW1wdHkpIHtcbiAgICAgICAgY29uc3QgZG9jID0gYXJ0aXN0c1F1ZXJ5LmRvY3NbMF07XG4gICAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZvdW5kOiB0cnVlLFxuICAgICAgICAgIHBhZ2VUeXBlOiAnYXJ0aXN0JyxcbiAgICAgICAgICBwYWdlSWQ6IGRvYy5pZCxcbiAgICAgICAgICBwYWdlTmFtZTogZGF0YS5uYW1lLFxuICAgICAgICAgIG93bmVySWQ6IGRhdGEub3duZXJJZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIW9yZ2FuaXphdGlvbnNRdWVyeS5lbXB0eSkge1xuICAgICAgICBjb25zdCBkb2MgPSBvcmdhbml6YXRpb25zUXVlcnkuZG9jc1swXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm91bmQ6IHRydWUsXG4gICAgICAgICAgcGFnZVR5cGU6ICdvcmdhbml6YXRpb24nLFxuICAgICAgICAgIHBhZ2VJZDogZG9jLmlkLFxuICAgICAgICAgIHBhZ2VOYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgICAgb3duZXJJZDogZGF0YS5vd25lcklkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghdmVudWVzUXVlcnkuZW1wdHkpIHtcbiAgICAgICAgY29uc3QgZG9jID0gdmVudWVzUXVlcnkuZG9jc1swXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm91bmQ6IHRydWUsXG4gICAgICAgICAgcGFnZVR5cGU6ICd2ZW51ZScsXG4gICAgICAgICAgcGFnZUlkOiBkb2MuaWQsXG4gICAgICAgICAgcGFnZU5hbWU6IGRhdGEubmFtZSxcbiAgICAgICAgICBvd25lcklkOiBkYXRhLm93bmVySWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHsgZm91bmQ6IGZhbHNlLCBlcnJvcjogJ1BhZ2Ugbm90IGZvdW5kIHdpdGggdGhpcyB1c2VybmFtZScgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmluZGluZyBwYWdlIGJ5IHVzZXJuYW1lOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IGZvdW5kOiBmYWxzZSwgZXJyb3I6ICdGYWlsZWQgdG8gc2VhcmNoIGZvciBwYWdlJyB9O1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEZpbmQgdXNlciBieSBwaG9uZSBudW1iZXJcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaW5kVXNlckJ5UGhvbmUocGhvbmU6IHN0cmluZyk6IFByb21pc2U8eyB1aWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nIH0gfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFNlYXJjaGluZyBmb3IgdXNlciB3aXRoIHBob25lOiBcIiR7cGhvbmV9XCJgKTtcbiAgICAgIFxuICAgICAgLy8g8J+aqCBERUJVRzogTGV0J3MgYWxzbyBzZWFyY2ggZm9yIGEgYnJvYWRlciByYW5nZSBvZiBwaG9uZSBmb3JtYXRzXG4gICAgICBjb25zdCBwaG9uZVZhcmlhdGlvbnMgPSBbXG4gICAgICAgIHBob25lLCAvLyBPcmlnaW5hbFxuICAgICAgICBwaG9uZS5yZXBsYWNlKC9cXHMvZywgJycpLCAvLyBSZW1vdmUgc3BhY2VzXG4gICAgICAgIHBob25lLnJlcGxhY2UoL1teXFxkK10vZywgJycpLCAvLyBLZWVwIG9ubHkgZGlnaXRzIGFuZCArXG4gICAgICBdO1xuICAgICAgXG4gICAgICAvLyBBZGQgY29tbW9uIEluZGlhbiB2YXJpYXRpb25zXG4gICAgICBpZiAocGhvbmUuc3RhcnRzV2l0aCgnKzkxJykpIHtcbiAgICAgICAgcGhvbmVWYXJpYXRpb25zLnB1c2gocGhvbmUuc3Vic3RyaW5nKDMpKTsgLy8gV2l0aG91dCArOTFcbiAgICAgICAgcGhvbmVWYXJpYXRpb25zLnB1c2goJzkxJyArIHBob25lLnN1YnN0cmluZygzKSk7IC8vIFdpdGggOTEgcHJlZml4XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFNlYXJjaGluZyBwaG9uZSB2YXJpYXRpb25zOmAsIHBob25lVmFyaWF0aW9ucyk7XG4gICAgICBcbiAgICAgIC8vIPCfmqggRklYOiBTZWFyY2ggZm9yIGJvdGggcG9zc2libGUgcGhvbmUgZmllbGQgbmFtZXNcbiAgICAgIC8vIFVzZXJzIG1pZ2h0IGhhdmUgcGhvbmUgc3RvcmVkIGFzICdwaG9uZScgb3IgJ3Bob25lTnVtYmVyJ1xuICAgICAgY29uc3QgdXNlcnNRdWVyeUJ5UGhvbmUgPSBxdWVyeShcbiAgICAgICAgY29sbGVjdGlvbihkYigpLCAnVXNlcnMnKSxcbiAgICAgICAgd2hlcmUoJ3Bob25lJywgJz09JywgcGhvbmUpXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zdCB1c2Vyc1F1ZXJ5QnlQaG9uZU51bWJlciA9IHF1ZXJ5KFxuICAgICAgICBjb2xsZWN0aW9uKGRiKCksICdVc2VycycpLFxuICAgICAgICB3aGVyZSgncGhvbmVOdW1iZXInLCAnPT0nLCBwaG9uZSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEV4ZWN1dGluZyBwYXJhbGxlbCBxdWVyaWVzIGZvciBwaG9uZSBmaWVsZHMuLi5gKTtcbiAgICAgIGNvbnN0IFtwaG9uZVNuYXBzaG90LCBwaG9uZU51bWJlclNuYXBzaG90XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0RG9jcyh1c2Vyc1F1ZXJ5QnlQaG9uZSksXG4gICAgICAgIGdldERvY3ModXNlcnNRdWVyeUJ5UGhvbmVOdW1iZXIpXG4gICAgICBdKTtcbiAgICAgIFxuICAgICAgbGV0IHVzZXJEYXRhID0gbnVsbDtcbiAgICAgIGxldCB1c2VySWQgPSBudWxsO1xuICAgICAgbGV0IGZvdW5kRmllbGQgPSBudWxsO1xuICAgICAgXG4gICAgICBpZiAoIXBob25lU25hcHNob3QuZW1wdHkpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCB1c2VyIGJ5ICdwaG9uZScgZmllbGRgKTtcbiAgICAgICAgdXNlckRhdGEgPSBwaG9uZVNuYXBzaG90LmRvY3NbMF0uZGF0YSgpO1xuICAgICAgICB1c2VySWQgPSBwaG9uZVNuYXBzaG90LmRvY3NbMF0uaWQ7XG4gICAgICAgIGZvdW5kRmllbGQgPSAncGhvbmUnO1xuICAgICAgfSBlbHNlIGlmICghcGhvbmVOdW1iZXJTbmFwc2hvdC5lbXB0eSkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIHVzZXIgYnkgJ3Bob25lTnVtYmVyJyBmaWVsZGApO1xuICAgICAgICB1c2VyRGF0YSA9IHBob25lTnVtYmVyU25hcHNob3QuZG9jc1swXS5kYXRhKCk7XG4gICAgICAgIHVzZXJJZCA9IHBob25lTnVtYmVyU25hcHNob3QuZG9jc1swXS5pZDtcbiAgICAgICAgZm91bmRGaWVsZCA9ICdwaG9uZU51bWJlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhg4p2MIE5vIHVzZXIgZm91bmQgd2l0aCBleGFjdCBwaG9uZTogJHtwaG9uZX1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIPCfmqggREVCVUc6IExldCdzIGNoZWNrIHdoYXQgcGhvbmUgbnVtYmVycyBhY3R1YWxseSBleGlzdCBpbiB0aGUgZGF0YWJhc2VcbiAgICAgICAgY29uc29sZS5sb2coYPCflI0gQ2hlY2tpbmcgd2hhdCBwaG9uZSBudW1iZXJzIGV4aXN0IGZvciBkZWJ1Z2dpbmcuLi5gKTtcbiAgICAgICAgY29uc3QgYWxsVXNlcnNRdWVyeSA9IHF1ZXJ5KGNvbGxlY3Rpb24oZGIoKSwgJ1VzZXJzJykpO1xuICAgICAgICBjb25zdCBhbGxVc2Vyc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhhbGxVc2Vyc1F1ZXJ5KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEZvdW5kICR7YWxsVXNlcnNTbmFwc2hvdC5zaXplfSB0b3RhbCB1c2VycyBpbiBkYXRhYmFzZWApO1xuICAgICAgICBhbGxVc2Vyc1NuYXBzaG90LmRvY3MuZm9yRWFjaCgoZG9jLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xuICAgICAgICAgIGlmIChpbmRleCA8IDUpIHsgLy8gT25seSBzaG93IGZpcnN0IDUgZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflI0gVXNlciAke2luZGV4ICsgMX06YCwge1xuICAgICAgICAgICAgICBpZDogZG9jLmlkLFxuICAgICAgICAgICAgICBwaG9uZTogZGF0YS5waG9uZSxcbiAgICAgICAgICAgICAgcGhvbmVOdW1iZXI6IGRhdGEucGhvbmVOdW1iZXIsXG4gICAgICAgICAgICAgIG5hbWU6IGRhdGEubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHVpZDogdXNlcklkLFxuICAgICAgICBuYW1lOiB1c2VyRGF0YS5uYW1lIHx8IHVzZXJEYXRhLmRpc3BsYXlOYW1lIHx8ICdVbmtub3duIFVzZXInXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFVzZXIgZm91bmQgdmlhICcke2ZvdW5kRmllbGR9JyBmaWVsZDpgLCByZXN1bHQpO1xuICAgICAgY29uc29sZS5sb2coYPCflI0gVXNlcidzIHN0b3JlZCBwaG9uZSBkYXRhOmAsIHtcbiAgICAgICAgcGhvbmU6IHVzZXJEYXRhLnBob25lLFxuICAgICAgICBwaG9uZU51bWJlcjogdXNlckRhdGEucGhvbmVOdW1iZXJcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZpbmRpbmcgdXNlciBieSBwaG9uZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBWZXJpZnkgaWYgdXNlciBoYXMgT1dORVItbGV2ZWwgYWNjZXNzIHRvIGV2ZW50IChmb3IgZ3JhbnRpbmcgYWNjZXNzIHRvIG90aGVycylcbiAgICovXG4gIHN0YXRpYyBhc3luYyB2ZXJpZnlFdmVudE93bmVyc2hpcEFjY2VzcyhldmVudElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50RG9jID0gYXdhaXQgZ2V0RG9jKGRvYyhkYigpLCAnZXZlbnRzJywgZXZlbnRJZCkpO1xuICAgICAgaWYgKCFldmVudERvYy5leGlzdHMoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgXG4gICAgICBjb25zdCBldmVudERhdGEgPSBldmVudERvYy5kYXRhKCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgZGlyZWN0IGV2ZW50IG93bmVyXG4gICAgICBpZiAoZXZlbnREYXRhLm9yZ2FuaXphdGlvbklkID09PSB1c2VySWQpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGV2ZW50RGF0YS5jcmVhdG9yICYmIGV2ZW50RGF0YS5jcmVhdG9yLnVzZXJJZCA9PT0gdXNlcklkKSByZXR1cm4gdHJ1ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdXNlciBpcyBPV05FUiBvZiB0aGUgcGFnZSB0aGF0IGNyZWF0ZWQgdGhpcyBldmVudFxuICAgICAgaWYgKGV2ZW50RGF0YS5jcmVhdG9yICYmIGV2ZW50RGF0YS5jcmVhdG9yLmNvbnRlbnRUeXBlICYmIGV2ZW50RGF0YS5jcmVhdG9yLmNvbnRlbnRJZCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRUeXBlLCBjb250ZW50SWQgfSA9IGV2ZW50RGF0YS5jcmVhdG9yO1xuICAgICAgICBcbiAgICAgICAgICAgICAgLy8gSW1wb3J0IENvbnRlbnRTaGFyaW5nU2VjdXJpdHkgbG9jYWxseSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5XG4gICAgICBjb25zdCB7IENvbnRlbnRTaGFyaW5nU2VjdXJpdHkgfSA9IGF3YWl0IGltcG9ydCgnQC9zaGFyZWQvdXRpbHMvc2VjdXJpdHkvY29udGVudFNoYXJpbmdTZWN1cml0eScpO1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IGF3YWl0IENvbnRlbnRTaGFyaW5nU2VjdXJpdHkudmVyaWZ5Q29udGVudEFjY2Vzcyhjb250ZW50VHlwZSwgY29udGVudElkLCB1c2VySWQpO1xuICAgICAgICBcbiAgICAgICAgLy8gT25seSBvd25lcnMgb2YgdGhlIGNyZWF0aW5nIHBhZ2UgY2FuIGdyYW50IGFjY2Vzc1xuICAgICAgICByZXR1cm4gcGVybWlzc2lvbnMucm9sZSA9PT0gJ293bmVyJztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgZXZlbnQgb3duZXJzaGlwIGFjY2VzczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBpZiB1c2VyIGNhbiBtYW5hZ2UgZXZlbnQgY29sbGFib3JhdGlvblxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHZlcmlmeUV2ZW50TWFuYWdlbWVudEFjY2VzcyhldmVudElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50RG9jID0gYXdhaXQgZ2V0RG9jKGRvYyhkYigpLCAnZXZlbnRzJywgZXZlbnRJZCkpO1xuICAgICAgaWYgKCFldmVudERvYy5leGlzdHMoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgXG4gICAgICBjb25zdCBldmVudERhdGEgPSBldmVudERvYy5kYXRhKCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgZXZlbnQgb3duZXJcbiAgICAgIGlmIChldmVudERhdGEub3JnYW5pemF0aW9uSWQgPT09IHVzZXJJZCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoZXZlbnREYXRhLmNyZWF0b3IgJiYgZXZlbnREYXRhLmNyZWF0b3IudXNlcklkID09PSB1c2VySWQpIHJldHVybiB0cnVlO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB1c2VyIGhhcyBmdWxsIG1hbmFnZW1lbnQgYWNjZXNzIHRocm91Z2ggY29sbGFib3JhdGlvblxuICAgICAgY29uc3QgY29sbGFib3JhdGlvblF1ZXJ5ID0gcXVlcnkoXG4gICAgICAgIGNvbGxlY3Rpb24oZGIoKSwgJ2V2ZW50Q29sbGFib3JhdGlvbicpLFxuICAgICAgICB3aGVyZSgnZXZlbnRJZCcsICc9PScsIGV2ZW50SWQpLFxuICAgICAgICB3aGVyZSgnaXNBY3RpdmUnLCAnPT0nLCB0cnVlKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGNvbGxhYm9yYXRpb25RdWVyeSk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgZG9jU25hcCBvZiBzbmFwc2hvdC5kb2NzKSB7XG4gICAgICAgIGNvbnN0IGFzc2lnbm1lbnQgPSBkb2NTbmFwLmRhdGEoKSBhcyBFdmVudENvbGxhYm9yYXRpb25Bc3NpZ25tZW50O1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgZXhwaXJlZFxuICAgICAgICBpZiAoYXNzaWdubWVudC5leHBpcmVzQXQgJiYgbmV3IERhdGUoYXNzaWdubWVudC5leHBpcmVzQXQpIDwgbmV3IERhdGUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGFzc2lnbm1lbnQgZ2l2ZXMgdGhlIHVzZXIgbWFuYWdlbWVudCBhY2Nlc3NcbiAgICAgICAgaWYgKGFzc2lnbm1lbnQuY29sbGFib3JhdG9yVHlwZSA9PT0gJ3BhZ2UnICYmIGFzc2lnbm1lbnQucGFnZU93bmVySWQgPT09IHVzZXJJZCkge1xuICAgICAgICAgIHJldHVybiBhc3NpZ25tZW50LmFjY2Vzc0xldmVsID09PSAnZnVsbF9tYW5hZ2VtZW50JztcbiAgICAgICAgfSBlbHNlIGlmIChhc3NpZ25tZW50LmNvbGxhYm9yYXRvclR5cGUgPT09ICd1c2VyJyAmJiBhc3NpZ25tZW50LnVzZXJJZCA9PT0gdXNlcklkKSB7XG4gICAgICAgICAgcmV0dXJuIGFzc2lnbm1lbnQuYWNjZXNzTGV2ZWwgPT09ICdmdWxsX21hbmFnZW1lbnQnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGV2ZW50IG1hbmFnZW1lbnQgYWNjZXNzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTaGFyZSBzZXNzaW9uIHdpdGggcGFnZSBvciB1c2VyXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgc2hhcmVTZXNzaW9uKFxuICAgIGV2ZW50SWQ6IHN0cmluZyxcbiAgICBzZXNzaW9uSWQ6IHN0cmluZyxcbiAgICBzZXNzaW9uTmFtZTogc3RyaW5nLFxuICAgIGNvbGxhYm9yYXRvclR5cGU6ICdwYWdlJyB8ICd1c2VyJyxcbiAgICBjb2xsYWJvcmF0b3JJZGVudGlmaWVyOiBzdHJpbmcsIC8vIHVzZXJuYW1lIGZvciBwYWdlcywgcGhvbmUgZm9yIHVzZXJzXG4gICAgYWNjZXNzTGV2ZWw6ICdmdWxsX21hbmFnZW1lbnQnIHwgJ2NoZWNraW5fb25seScsXG4gICAgaW52aXRlcklkOiBzdHJpbmcsXG4gICAgaW52aXRlck5hbWU6IHN0cmluZyxcbiAgICBleHBpcmVzSW5Ib3Vycz86IG51bWJlcixcbiAgICBtZXNzYWdlPzogc3RyaW5nLFxuICAgIHNob3dPbkV2ZW50UGFnZTogYm9vbGVhbiA9IGZhbHNlXG4gICk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBhc3NpZ25tZW50SWQ/OiBzdHJpbmc7IGludml0YXRpb25JZD86IHN0cmluZzsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyDwn5qoIEVOSEFOQ0VEOiBWZXJpZnkgaW52aXRlciBoYXMgT1dORVItbGV2ZWwgbWFuYWdlbWVudCBhY2Nlc3MgKG5vdCBqdXN0IG1hbmFnZW1lbnQgYWNjZXNzKVxuICAgICAgY29uc3QgaGFzQWNjZXNzID0gYXdhaXQgdGhpcy52ZXJpZnlFdmVudE93bmVyc2hpcEFjY2VzcyhldmVudElkLCBpbnZpdGVySWQpO1xuICAgICAgaWYgKCFoYXNBY2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnT25seSBldmVudCBvd25lcnMgY2FuIGdyYW50IGNoZWNrLWluIGFjY2VzcyB0byBvdGhlcnMnIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJhdGUgbGltaXRpbmdcbiAgICAgIGNvbnN0IHJhdGVMaW1pdENoZWNrID0gdGhpcy5jaGVja0ludml0YXRpb25SYXRlTGltaXQoaW52aXRlcklkKTtcbiAgICAgIGlmICghcmF0ZUxpbWl0Q2hlY2suYWxsb3dlZCkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHJhdGVMaW1pdENoZWNrLmVycm9yIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlc291cmNlIGxpbWl0c1xuICAgICAgY29uc3QgcmVzb3VyY2VDaGVjayA9IGF3YWl0IHRoaXMuY2hlY2tSZXNvdXJjZUxpbWl0cyhldmVudElkLCBpbnZpdGVySWQpO1xuICAgICAgaWYgKCFyZXNvdXJjZUNoZWNrLmFsbG93ZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXNvdXJjZUNoZWNrLmVycm9yIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCBldmVudCBkYXRhXG4gICAgICBjb25zdCBldmVudERvYyA9IGF3YWl0IGdldERvYyhkb2MoZGIoKSwgJ2V2ZW50cycsIGV2ZW50SWQpKTtcbiAgICAgIGlmICghZXZlbnREb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnRXZlbnQgbm90IGZvdW5kJyB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBldmVudERhdGEgPSBldmVudERvYy5kYXRhKCk7XG4gICAgICBjb25zdCBldmVudFRpdGxlID0gZXZlbnREYXRhLnRpdGxlIHx8ICdVbnRpdGxlZCBFdmVudCc7XG4gICAgICBjb25zdCBzYW5pdGl6ZWRNZXNzYWdlID0gdGhpcy5zYW5pdGl6ZUlucHV0KG1lc3NhZ2UgfHwgJycpO1xuICAgICAgXG4gICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHRoaXMuZ2V0UGVybWlzc2lvblRlbXBsYXRlcygpW2FjY2Vzc0xldmVsXTtcbiAgICAgIFxuICAgICAgaWYgKGNvbGxhYm9yYXRvclR5cGUgPT09ICdwYWdlJykge1xuICAgICAgICAvLyBWYWxpZGF0ZSB1c2VybmFtZVxuICAgICAgICBjb25zdCB1c2VybmFtZVZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlVXNlcm5hbWUoY29sbGFib3JhdG9ySWRlbnRpZmllcik7XG4gICAgICAgIGlmICghdXNlcm5hbWVWYWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHVzZXJuYW1lVmFsaWRhdGlvbi5lcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGaW5kIHBhZ2VcbiAgICAgICAgY29uc3QgcGFnZVJlc3VsdCA9IGF3YWl0IHRoaXMuZmluZFBhZ2VCeVVzZXJuYW1lKGNvbGxhYm9yYXRvcklkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIXBhZ2VSZXN1bHQuZm91bmQpIHtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHBhZ2VSZXN1bHQuZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIGFzc2lnbm1lbnRzIGFuZCBpbnZpdGF0aW9ucyBmb3IgdGhpcyBwYWdlXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQXNzaWdubWVudFF1ZXJ5ID0gcXVlcnkoXG4gICAgICAgICAgY29sbGVjdGlvbihkYigpLCAnZXZlbnRDb2xsYWJvcmF0aW9uJyksXG4gICAgICAgICAgd2hlcmUoJ2V2ZW50SWQnLCAnPT0nLCBldmVudElkKSxcbiAgICAgICAgICB3aGVyZSgncGFnZUlkJywgJz09JywgcGFnZVJlc3VsdC5wYWdlSWQpLFxuICAgICAgICAgIHdoZXJlKCdpc0FjdGl2ZScsICc9PScsIHRydWUpXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBleGlzdGluZ0ludml0YXRpb25RdWVyeSA9IHF1ZXJ5KFxuICAgICAgICAgIGNvbGxlY3Rpb24oZGIoKSwgJ2V2ZW50SW52aXRhdGlvbnMnKSxcbiAgICAgICAgICB3aGVyZSgnZXZlbnRJZCcsICc9PScsIGV2ZW50SWQpLFxuICAgICAgICAgIHdoZXJlKCdwYWdlSWQnLCAnPT0nLCBwYWdlUmVzdWx0LnBhZ2VJZCksXG4gICAgICAgICAgd2hlcmUoJ3N0YXR1cycsICc9PScsICdwZW5kaW5nJylcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IFtleGlzdGluZ1NuYXBzaG90LCBpbnZpdGF0aW9uU25hcHNob3RdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIGdldERvY3MoZXhpc3RpbmdBc3NpZ25tZW50UXVlcnkpLFxuICAgICAgICAgIGdldERvY3MoZXhpc3RpbmdJbnZpdGF0aW9uUXVlcnkpXG4gICAgICAgIF0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFleGlzdGluZ1NuYXBzaG90LmVtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnVGhpcyBwYWdlIGFscmVhZHkgaGFzIGFjY2VzcyB0byB0aGUgZXZlbnQnIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICghaW52aXRhdGlvblNuYXBzaG90LmVtcHR5KSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflI0gRm91bmQgZXhpc3RpbmcgaW52aXRhdGlvbi4gRGVidWcgaW5mbzonKTtcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0ludml0YXRpb24gPSBpbnZpdGF0aW9uU25hcHNob3QuZG9jc1swXS5kYXRhKCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflI0gRXhpc3RpbmcgaW52aXRhdGlvbjonLCB7XG4gICAgICAgICAgICBwaG9uZTogZXhpc3RpbmdJbnZpdGF0aW9uLmludml0ZWRQaG9uZSxcbiAgICAgICAgICAgIHN0YXR1czogZXhpc3RpbmdJbnZpdGF0aW9uLnN0YXR1cyxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogZXhpc3RpbmdJbnZpdGF0aW9uLmNyZWF0ZWRBdCxcbiAgICAgICAgICAgIGV2ZW50VGl0bGU6IGV4aXN0aW5nSW52aXRhdGlvbi5ldmVudFRpdGxlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8g8J+aqCBERUJVRzogTGV0J3Mgc3RpbGwgcnVuIHRoZSB1c2VyIHNlYXJjaCB0byBzZWUgd2h5IGl0IGZhaWxlZFxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFJ1bm5pbmcgdXNlciBzZWFyY2ggZGVidWcgZXZlbiB0aG91Z2ggaW52aXRhdGlvbiBleGlzdHMuLi4nKTtcbiAgICAgICAgICBjb25zdCBkZWJ1Z1VzZXJTZWFyY2ggPSBhd2FpdCB0aGlzLmZpbmRVc2VyQnlQaG9uZShjb2xsYWJvcmF0b3JJZGVudGlmaWVyKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBEZWJ1ZyB1c2VyIHNlYXJjaCByZXN1bHQ6JywgZGVidWdVc2VyU2VhcmNoKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdUaGlzIHBhZ2UgYWxyZWFkeSBoYXMgYSBwZW5kaW5nIGludml0YXRpb24gZm9yIHRoaXMgZXZlbnQnIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBpbnZpdGF0aW9uIGZvciBwYWdlXG4gICAgICAgIGNvbnN0IGludml0YXRpb246IEV2ZW50SW52aXRhdGlvbiA9IHtcbiAgICAgICAgICBldmVudElkLFxuICAgICAgICAgIGV2ZW50VGl0bGUsXG4gICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgIHNlc3Npb25OYW1lLFxuICAgICAgICAgIGNvbGxhYm9yYXRvclR5cGU6ICdwYWdlJyxcbiAgICAgICAgICBwYWdlVHlwZTogcGFnZVJlc3VsdC5wYWdlVHlwZSxcbiAgICAgICAgICBwYWdlVXNlcm5hbWU6IGNvbGxhYm9yYXRvcklkZW50aWZpZXIsXG4gICAgICAgICAgcGFnZUlkOiBwYWdlUmVzdWx0LnBhZ2VJZCxcbiAgICAgICAgICBwYWdlTmFtZTogcGFnZVJlc3VsdC5wYWdlTmFtZSxcbiAgICAgICAgICBpbnZpdGVkQnlVc2VySWQ6IGludml0ZXJJZCxcbiAgICAgICAgICBpbnZpdGVkQnlOYW1lOiBpbnZpdGVyTmFtZSxcbiAgICAgICAgICBhY2Nlc3NMZXZlbCxcbiAgICAgICAgICBwZXJtaXNzaW9ucyxcbiAgICAgICAgICBtZXNzYWdlOiBzYW5pdGl6ZWRNZXNzYWdlLFxuICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLCAvLyA3IGRheXNcbiAgICAgICAgICBzaG93T25FdmVudFBhZ2VcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiKCksICdldmVudEludml0YXRpb25zJyksIHtcbiAgICAgICAgICAuLi5pbnZpdGF0aW9uLFxuICAgICAgICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCB0aGlzLmxvZ1NlY3VyaXR5RXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdldmVudF9jb2xsYWJvcmF0aW9uJyxcbiAgICAgICAgICB1c2VySWQ6IGludml0ZXJJZCxcbiAgICAgICAgICBldmVudElkLFxuICAgICAgICAgIGFjdGlvbjogJ3BhZ2VfaW52aXRhdGlvbl9zZW50JyxcbiAgICAgICAgICByZXN1bHQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICBkZXRhaWxzOiB7IFxuICAgICAgICAgICAgcGFnZUlkOiBwYWdlUmVzdWx0LnBhZ2VJZCwgXG4gICAgICAgICAgICBwYWdlVHlwZTogcGFnZVJlc3VsdC5wYWdlVHlwZSxcbiAgICAgICAgICAgIGFjY2Vzc0xldmVsLFxuICAgICAgICAgICAgc2hvd09uRXZlbnRQYWdlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGludml0YXRpb25JZDogZG9jUmVmLmlkIH07XG4gICAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8g8J+aqCBGSVg6IERpcmVjdCBhc3NpZ25tZW50IGZvciB1c2VyIGNvbGxhYm9yYXRvcnMgLSBubyBpbnZpdGF0aW9uIG5lZWRlZFxuICAgICAgICBjb25zdCBwaG9uZVZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlUGhvbmVOdW1iZXIoY29sbGFib3JhdG9ySWRlbnRpZmllcik7XG4gICAgICAgIGlmICghcGhvbmVWYWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHBob25lVmFsaWRhdGlvbi5lcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzYW5pdGl6ZWRQaG9uZSA9IHBob25lVmFsaWRhdGlvbi5pc1ZhbGlkID8gY29sbGFib3JhdG9ySWRlbnRpZmllci5yZXBsYWNlKC9bXlxcZCtdL2csICcnKSA6ICcnO1xuICAgICAgICBcbiAgICAgICAgLy8gT25seSBhbGxvdyBjaGVja2luX29ubHkgYWNjZXNzIGZvciB1c2VyIGNvbGxhYm9yYXRvcnMgKHNlY3VyaXR5IG1lYXN1cmUpXG4gICAgICAgIGlmIChhY2Nlc3NMZXZlbCAhPT0gJ2NoZWNraW5fb25seScpIHtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdVc2VyIGNvbGxhYm9yYXRvcnMgY2FuIG9ubHkgaGF2ZSBjaGVjay1pbiBhY2Nlc3MnIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIExvb2tpbmcgZm9yIGV4aXN0aW5nIHVzZXIgd2l0aCBwaG9uZTogJHtzYW5pdGl6ZWRQaG9uZX1gKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdVc2VyID0gYXdhaXQgdGhpcy5maW5kVXNlckJ5UGhvbmUoc2FuaXRpemVkUGhvbmUpO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBmaW5kVXNlckJ5UGhvbmUgcmVzdWx0OmAsIGV4aXN0aW5nVXNlcik7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXhpc3RpbmdVc2VyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBVc2VyIGZvdW5kLCBjcmVhdGluZyBkaXJlY3QgYXNzaWdubWVudCBmb3IgY2hlY2staW4gYWNjZXNzJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIGFzc2lnbm1lbnRzIGZvciB0aGlzIHVzZXJcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0Fzc2lnbm1lbnRRdWVyeSA9IHF1ZXJ5KFxuICAgICAgICAgICAgY29sbGVjdGlvbihkYigpLCAnZXZlbnRDb2xsYWJvcmF0aW9uJyksXG4gICAgICAgICAgICB3aGVyZSgnZXZlbnRJZCcsICc9PScsIGV2ZW50SWQpLFxuICAgICAgICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIGV4aXN0aW5nVXNlci51aWQpLFxuICAgICAgICAgICAgd2hlcmUoJ2lzQWN0aXZlJywgJz09JywgdHJ1ZSlcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGV4aXN0aW5nQXNzaWdubWVudFF1ZXJ5KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWV4aXN0aW5nU25hcHNob3QuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1RoaXMgdXNlciBhbHJlYWR5IGhhcyBhY2Nlc3MgdG8gdGhlIGV2ZW50JyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyDwn5qoIEZJWDogQ3JlYXRlIGRpcmVjdCBhc3NpZ25tZW50IC0gbm8gaW52aXRhdGlvbiBuZWVkZWQhXG4gICAgICAgICAgY29uc3QgYXNzaWdubWVudDogRXZlbnRDb2xsYWJvcmF0aW9uQXNzaWdubWVudCA9IHtcbiAgICAgICAgICAgIGV2ZW50SWQsXG4gICAgICAgICAgICBldmVudFRpdGxlLFxuICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgc2Vzc2lvbk5hbWUsXG4gICAgICAgICAgICBjb2xsYWJvcmF0b3JUeXBlOiAndXNlcicsXG4gICAgICAgICAgICB1c2VyUGhvbmU6IHNhbml0aXplZFBob25lLFxuICAgICAgICAgICAgdXNlcklkOiBleGlzdGluZ1VzZXIudWlkLFxuICAgICAgICAgICAgdXNlck5hbWU6IGV4aXN0aW5nVXNlci5uYW1lLFxuICAgICAgICAgICAgcGVybWlzc2lvbnMsXG4gICAgICAgICAgICBhY2Nlc3NMZXZlbCxcbiAgICAgICAgICAgIGFzc2lnbmVkQnk6IGludml0ZXJJZCxcbiAgICAgICAgICAgIGFzc2lnbmVkQnlOYW1lOiBpbnZpdGVyTmFtZSxcbiAgICAgICAgICAgIGFzc2lnbmVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgICAgIG5vdGVzOiBgRGlyZWN0IGNoZWNrLWluIGFjY2VzcyBncmFudGVkIHRvIHJlZ2lzdGVyZWQgdXNlcmAsXG4gICAgICAgICAgICBpbnZpdGF0aW9uTWVzc2FnZTogc2FuaXRpemVkTWVzc2FnZSxcbiAgICAgICAgICAgIHNob3dPbkV2ZW50UGFnZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBPbmx5IGFkZCBleHBpcmVzQXQgaWYgdGhlcmUncyBhbiBleHBpcnkgdGltZSAoRmlyZXN0b3JlIGRvZXNuJ3QgYWNjZXB0IHVuZGVmaW5lZClcbiAgICAgICAgICBpZiAoZXhwaXJlc0luSG91cnMpIHtcbiAgICAgICAgICAgIGFzc2lnbm1lbnQuZXhwaXJlc0F0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIGV4cGlyZXNJbkhvdXJzICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiKCksICdldmVudENvbGxhYm9yYXRpb24nKSwge1xuICAgICAgICAgICAgLi4uYXNzaWdubWVudCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBhd2FpdCB0aGlzLmxvZ1NlY3VyaXR5RXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ2V2ZW50X2NvbGxhYm9yYXRpb24nLFxuICAgICAgICAgICAgdXNlcklkOiBpbnZpdGVySWQsXG4gICAgICAgICAgICBldmVudElkLFxuICAgICAgICAgICAgYWN0aW9uOiAndXNlcl9kaXJlY3RfYWNjZXNzX2dyYW50ZWQnLFxuICAgICAgICAgICAgcmVzdWx0OiAnc3VjY2VzcycsXG4gICAgICAgICAgICBkZXRhaWxzOiB7IFxuICAgICAgICAgICAgICB0YXJnZXRVc2VySWQ6IGV4aXN0aW5nVXNlci51aWQsIFxuICAgICAgICAgICAgICBhY2Nlc3NMZXZlbCxcbiAgICAgICAgICAgICAgc2hvd09uRXZlbnRQYWdlLFxuICAgICAgICAgICAgICBtZXRob2Q6ICdkaXJlY3RfYXNzaWdubWVudCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIERpcmVjdCBjaGVjay1pbiBhY2Nlc3MgZ3JhbnRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBhc3NpZ25tZW50SWQ6IGRvY1JlZi5pZCB9O1xuICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfihLnvuI8gVXNlciBub3QgZm91bmQsIGNyZWF0aW5nIGludml0YXRpb24gZm9yIHVucmVnaXN0ZXJlZCB1c2VyJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIGludml0YXRpb25zIGZvciB0aGlzIHBob25lXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdJbnZpdGF0aW9uUXVlcnkgPSBxdWVyeShcbiAgICAgICAgICAgIGNvbGxlY3Rpb24oZGIoKSwgJ2V2ZW50SW52aXRhdGlvbnMnKSxcbiAgICAgICAgICAgIHdoZXJlKCdldmVudElkJywgJz09JywgZXZlbnRJZCksXG4gICAgICAgICAgICB3aGVyZSgnaW52aXRlZFBob25lJywgJz09Jywgc2FuaXRpemVkUGhvbmUpLFxuICAgICAgICAgICAgd2hlcmUoJ3N0YXR1cycsICc9PScsICdwZW5kaW5nJylcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGludml0YXRpb25TbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoZXhpc3RpbmdJbnZpdGF0aW9uUXVlcnkpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghaW52aXRhdGlvblNuYXBzaG90LmVtcHR5KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBGb3VuZCBleGlzdGluZyBpbnZpdGF0aW9uLiBEZWJ1ZyBpbmZvOicpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdJbnZpdGF0aW9uID0gaW52aXRhdGlvblNuYXBzaG90LmRvY3NbMF0uZGF0YSgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflI0gRXhpc3RpbmcgaW52aXRhdGlvbjonLCB7XG4gICAgICAgICAgICAgIHBob25lOiBleGlzdGluZ0ludml0YXRpb24uaW52aXRlZFBob25lLFxuICAgICAgICAgICAgICBzdGF0dXM6IGV4aXN0aW5nSW52aXRhdGlvbi5zdGF0dXMsXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogZXhpc3RpbmdJbnZpdGF0aW9uLmNyZWF0ZWRBdCxcbiAgICAgICAgICAgICAgZXZlbnRUaXRsZTogZXhpc3RpbmdJbnZpdGF0aW9uLmV2ZW50VGl0bGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyDwn5qoIERFQlVHOiBMZXQncyBzdGlsbCBydW4gdGhlIHVzZXIgc2VhcmNoIHRvIHNlZSB3aHkgaXQgZmFpbGVkXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBSdW5uaW5nIHVzZXIgc2VhcmNoIGRlYnVnIGV2ZW4gdGhvdWdoIGludml0YXRpb24gZXhpc3RzLi4uJyk7XG4gICAgICAgICAgICBjb25zdCBkZWJ1Z1VzZXJTZWFyY2ggPSBhd2FpdCB0aGlzLmZpbmRVc2VyQnlQaG9uZShjb2xsYWJvcmF0b3JJZGVudGlmaWVyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIERlYnVnIHVzZXIgc2VhcmNoIHJlc3VsdDonLCBkZWJ1Z1VzZXJTZWFyY2gpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdUaGlzIHVzZXIgYWxyZWFkeSBoYXMgYSBwZW5kaW5nIGludml0YXRpb24gZm9yIHRoaXMgZXZlbnQnIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBpbnZpdGF0aW9uIGZvciB1bnJlZ2lzdGVyZWQgdXNlciAodGhleSdsbCBnZXQgZGlyZWN0IGFjY2VzcyB3aGVuIHRoZXkgcmVnaXN0ZXIpXG4gICAgICAgICAgY29uc3QgaW52aXRhdGlvbjogRXZlbnRJbnZpdGF0aW9uID0ge1xuICAgICAgICAgICAgZXZlbnRJZCxcbiAgICAgICAgICAgIGV2ZW50VGl0bGUsXG4gICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICBzZXNzaW9uTmFtZSxcbiAgICAgICAgICAgIGNvbGxhYm9yYXRvclR5cGU6ICd1c2VyJyxcbiAgICAgICAgICAgIGludml0ZWRQaG9uZTogc2FuaXRpemVkUGhvbmUsXG4gICAgICAgICAgICBpbnZpdGVkQnlVc2VySWQ6IGludml0ZXJJZCxcbiAgICAgICAgICAgIGludml0ZWRCeU5hbWU6IGludml0ZXJOYW1lLFxuICAgICAgICAgICAgYWNjZXNzTGV2ZWwsXG4gICAgICAgICAgICBwZXJtaXNzaW9ucyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHNhbml0aXplZE1lc3NhZ2UsXG4gICAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLCAvLyAzMCBkYXlzIGZvciB1c2VyIGludml0YXRpb25zXG4gICAgICAgICAgICBzaG93T25FdmVudFBhZ2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiKCksICdldmVudEludml0YXRpb25zJyksIHtcbiAgICAgICAgICAgIC4uLmludml0YXRpb24sXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgYXdhaXQgdGhpcy5sb2dTZWN1cml0eUV2ZW50KHtcbiAgICAgICAgICAgIHR5cGU6ICdldmVudF9jb2xsYWJvcmF0aW9uJyxcbiAgICAgICAgICAgIHVzZXJJZDogaW52aXRlcklkLFxuICAgICAgICAgICAgZXZlbnRJZCxcbiAgICAgICAgICAgIGFjdGlvbjogJ3VzZXJfaW52aXRhdGlvbl9zZW50JyxcbiAgICAgICAgICAgIHJlc3VsdDogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgZGV0YWlsczogeyBcbiAgICAgICAgICAgICAgaW52aXRlZFBob25lOiBzYW5pdGl6ZWRQaG9uZSwgXG4gICAgICAgICAgICAgIGFjY2Vzc0xldmVsLFxuICAgICAgICAgICAgICBzaG93T25FdmVudFBhZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEludml0YXRpb24gY3JlYXRlZCBmb3IgdW5yZWdpc3RlcmVkIHVzZXInKTtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBpbnZpdGF0aW9uSWQ6IGRvY1JlZi5pZCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNoYXJpbmcgZXZlbnQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnRmFpbGVkIHRvIHNoYXJlIGV2ZW50JyB9O1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlbW92ZSBzZXNzaW9uIGNvbGxhYm9yYXRpb25cbiAgICovXG4gIHN0YXRpYyBhc3luYyByZW1vdmVTZXNzaW9uQWNjZXNzKFxuICAgIGV2ZW50SWQ6IHN0cmluZyxcbiAgICBzZXNzaW9uSWQ6IHN0cmluZyxcbiAgICBhc3NpZ25tZW50SWQ6IHN0cmluZyxcbiAgICByZW1vdmVkQnlVc2VySWQ6IHN0cmluZ1xuICApOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoYXNBY2Nlc3MgPSBhd2FpdCB0aGlzLnZlcmlmeUV2ZW50TWFuYWdlbWVudEFjY2VzcyhldmVudElkLCByZW1vdmVkQnlVc2VySWQpO1xuICAgICAgaWYgKCFoYXNBY2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gcmVtb3ZlIGFjY2VzcycgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgYXNzaWdubWVudERvYyA9IGF3YWl0IGdldERvYyhkb2MoZGIoKSwgJ2V2ZW50Q29sbGFib3JhdGlvbicsIGFzc2lnbm1lbnRJZCkpO1xuICAgICAgaWYgKCFhc3NpZ25tZW50RG9jLmV4aXN0cygpKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0Fzc2lnbm1lbnQgbm90IGZvdW5kJyB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBhd2FpdCB1cGRhdGVEb2MoZG9jKGRiKCksICdldmVudENvbGxhYm9yYXRpb24nLCBhc3NpZ25tZW50SWQpLCB7XG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgc3RhdHVzOiAnZXhwaXJlZCcsXG4gICAgICAgIHJlbW92ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICAgIHJlbW92ZWRCeTogcmVtb3ZlZEJ5VXNlcklkXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgYXdhaXQgdGhpcy5sb2dTZWN1cml0eUV2ZW50KHtcbiAgICAgICAgdHlwZTogJ2V2ZW50X2NvbGxhYm9yYXRpb24nLFxuICAgICAgICB1c2VySWQ6IHJlbW92ZWRCeVVzZXJJZCxcbiAgICAgICAgZXZlbnRJZCxcbiAgICAgICAgYWN0aW9uOiAnYWNjZXNzX3JlbW92ZWQnLFxuICAgICAgICByZXN1bHQ6ICdzdWNjZXNzJyxcbiAgICAgICAgZGV0YWlsczogeyBhc3NpZ25tZW50SWQgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgZXZlbnQgYWNjZXNzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0ZhaWxlZCB0byByZW1vdmUgYWNjZXNzJyB9O1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBzZXNzaW9uIGNvbGxhYm9yYXRvcnNcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRTZXNzaW9uQ29sbGFib3JhdG9ycyhldmVudElkOiBzdHJpbmcsIHNlc3Npb25JZD86IHN0cmluZyk6IFByb21pc2U8RXZlbnRDb2xsYWJvcmF0aW9uQXNzaWdubWVudFtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb2xsYWJvcmF0b3JzUXVlcnk7XG4gICAgICBpZiAoc2Vzc2lvbklkKSB7XG4gICAgICAgIGNvbGxhYm9yYXRvcnNRdWVyeSA9IHF1ZXJ5KFxuICAgICAgICAgIGNvbGxlY3Rpb24oZGIoKSwgJ2V2ZW50Q29sbGFib3JhdGlvbicpLFxuICAgICAgICAgIHdoZXJlKCdldmVudElkJywgJz09JywgZXZlbnRJZCksXG4gICAgICAgICAgd2hlcmUoJ3Nlc3Npb25JZCcsICc9PScsIHNlc3Npb25JZCksXG4gICAgICAgICAgd2hlcmUoJ2lzQWN0aXZlJywgJz09JywgdHJ1ZSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbGxhYm9yYXRvcnNRdWVyeSA9IHF1ZXJ5KFxuICAgICAgICAgIGNvbGxlY3Rpb24oZGIoKSwgJ2V2ZW50Q29sbGFib3JhdGlvbicpLFxuICAgICAgICAgIHdoZXJlKCdldmVudElkJywgJz09JywgZXZlbnRJZCksXG4gICAgICAgICAgd2hlcmUoJ2lzQWN0aXZlJywgJz09JywgdHJ1ZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGNvbGxhYm9yYXRvcnNRdWVyeSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGFzc2lnbm1lbnRzID0gc25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XG4gICAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAgIC4uLmRvYy5kYXRhKClcbiAgICAgIH0gYXMgRXZlbnRDb2xsYWJvcmF0aW9uQXNzaWdubWVudCkpO1xuICAgICAgXG4gICAgICAvLyBEZWR1cGxpY2F0ZSBhbmQgZmlsdGVyIGV4cGlyZWRcbiAgICAgIGNvbnN0IGNvbGxhYm9yYXRvck1hcCA9IG5ldyBNYXA8c3RyaW5nLCBFdmVudENvbGxhYm9yYXRpb25Bc3NpZ25tZW50PigpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGFzc2lnbm1lbnQgb2YgYXNzaWdubWVudHMpIHtcbiAgICAgICAgLy8gU2tpcCBleHBpcmVkIGFzc2lnbm1lbnRzXG4gICAgICAgIGlmIChhc3NpZ25tZW50LmV4cGlyZXNBdCAmJiBuZXcgRGF0ZShhc3NpZ25tZW50LmV4cGlyZXNBdCkgPCBuZXcgRGF0ZSgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGtleSA9IGFzc2lnbm1lbnQuY29sbGFib3JhdG9yVHlwZSA9PT0gJ3BhZ2UnIFxuICAgICAgICAgID8gYHBhZ2VfJHthc3NpZ25tZW50LnBhZ2VJZH1gIFxuICAgICAgICAgIDogYHVzZXJfJHthc3NpZ25tZW50LnVzZXJJZH1gO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBjb2xsYWJvcmF0b3JNYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghZXhpc3RpbmcgfHwgbmV3IERhdGUoYXNzaWdubWVudC5hc3NpZ25lZEF0KSA+IG5ldyBEYXRlKGV4aXN0aW5nLmFzc2lnbmVkQXQpKSB7XG4gICAgICAgICAgY29sbGFib3JhdG9yTWFwLnNldChrZXksIGFzc2lnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGNvbGxhYm9yYXRvck1hcC52YWx1ZXMoKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGV2ZW50IGNvbGxhYm9yYXRvcnM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBldmVudHMgc2hhcmVkIHdpdGggdXNlclxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdldFVzZXJTaGFyZWRFdmVudHModXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPHtcbiAgICBtYW5hZ2VkRXZlbnRzOiBBcnJheTx7IGV2ZW50SWQ6IHN0cmluZzsgZXZlbnRUaXRsZTogc3RyaW5nOyByb2xlOiBzdHJpbmc7IGFjY2Vzc0xldmVsOiBzdHJpbmcgfT47XG4gICAgY2hlY2tpbkV2ZW50czogQXJyYXk8eyBldmVudElkOiBzdHJpbmc7IGV2ZW50VGl0bGU6IHN0cmluZzsgcm9sZTogc3RyaW5nOyBhY2Nlc3NMZXZlbDogc3RyaW5nIH0+O1xuICB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIGdldFVzZXJTaGFyZWRFdmVudHMgY2FsbGVkIGZvciB1c2VySWQ6ICR7dXNlcklkLnN1YnN0cmluZygwLCA4KX0uLi5gKTtcbiAgICAgIFxuICAgICAgLy8g8J+aqCBDUklUSUNBTCBGSVg6IEFkZCBwcm9wZXIgdXNlciBmaWx0ZXJpbmcgdG8gcHJldmVudCBkb3dubG9hZGluZyBBTEwgY29sbGFib3JhdGlvbnNcbiAgICAgIGNvbnN0IHNoYXJlZFF1ZXJ5ID0gcXVlcnkoXG4gICAgICAgIGNvbGxlY3Rpb24oZGIoKSwgJ2V2ZW50Q29sbGFib3JhdGlvbicpLFxuICAgICAgICB3aGVyZSgnaXNBY3RpdmUnLCAnPT0nLCB0cnVlKSxcbiAgICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZCkgLy8gRGlyZWN0IHVzZXIgY29sbGFib3JhdGlvbnNcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEFsc28gbmVlZCB0byBjaGVjayBwYWdlLWJhc2VkIGNvbGxhYm9yYXRpb25zIHdoZXJlIHVzZXIgb3ducyB0aGUgcGFnZVxuICAgICAgY29uc3QgcGFnZUJhc2VkUXVlcnkgPSBxdWVyeShcbiAgICAgICAgY29sbGVjdGlvbihkYigpLCAnZXZlbnRDb2xsYWJvcmF0aW9uJyksXG4gICAgICAgIHdoZXJlKCdpc0FjdGl2ZScsICc9PScsIHRydWUpLFxuICAgICAgICB3aGVyZSgncGFnZU93bmVySWQnLCAnPT0nLCB1c2VySWQpIC8vIFBhZ2UgY29sbGFib3JhdGlvbnMgd2hlcmUgdXNlciBvd25zIHRoZSBwYWdlXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBFeGVjdXRpbmcgRmlyZXN0b3JlIHF1ZXJpZXMuLi4nKTtcbiAgICAgIGNvbnN0IFt1c2VyU25hcHNob3QsIHBhZ2VTbmFwc2hvdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldERvY3Moc2hhcmVkUXVlcnkpLFxuICAgICAgICBnZXREb2NzKHBhZ2VCYXNlZFF1ZXJ5KVxuICAgICAgXSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFF1ZXJ5IHJlc3VsdHM6ICR7dXNlclNuYXBzaG90LnNpemV9IHVzZXIgY29sbGFib3JhdGlvbnMsICR7cGFnZVNuYXBzaG90LnNpemV9IHBhZ2UgY29sbGFib3JhdGlvbnNgKTtcbiAgICAgIFxuICAgICAgY29uc3QgbWFuYWdlZEV2ZW50cyA9IFtdO1xuICAgICAgY29uc3QgY2hlY2tpbkV2ZW50cyA9IFtdO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGRpcmVjdCB1c2VyIGNvbGxhYm9yYXRpb25zXG4gICAgICBmb3IgKGNvbnN0IGRvY1NuYXAgb2YgdXNlclNuYXBzaG90LmRvY3MpIHtcbiAgICAgICAgY29uc3QgYXNzaWdubWVudCA9IGRvY1NuYXAuZGF0YSgpIGFzIEV2ZW50Q29sbGFib3JhdGlvbkFzc2lnbm1lbnQ7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBQcm9jZXNzaW5nIHVzZXIgY29sbGFib3JhdGlvbjogJHthc3NpZ25tZW50LmV2ZW50VGl0bGV9ICgke2Fzc2lnbm1lbnQuYWNjZXNzTGV2ZWx9KWApO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgZXhwaXJlZFxuICAgICAgICBpZiAoYXNzaWdubWVudC5leHBpcmVzQXQgJiYgbmV3IERhdGUoYXNzaWdubWVudC5leHBpcmVzQXQpIDwgbmV3IERhdGUoKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDij7AgQXNzaWdubWVudCBleHBpcmVkOiAke2Fzc2lnbm1lbnQuZXZlbnRUaXRsZX0gKGV4cGlyZWQgYXQgJHthc3NpZ25tZW50LmV4cGlyZXNBdH0pYCk7XG4gICAgICAgICAgLy8gTWFyayBhcyBleHBpcmVkIGluIGRhdGFiYXNlXG4gICAgICAgICAgYXdhaXQgdXBkYXRlRG9jKGRvY1NuYXAucmVmLCB7XG4gICAgICAgICAgICBpc0FjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBzdGF0dXM6ICdleHBpcmVkJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBldmVudEluZm8gPSB7XG4gICAgICAgICAgZXZlbnRJZDogYXNzaWdubWVudC5ldmVudElkLFxuICAgICAgICAgIGV2ZW50VGl0bGU6IGFzc2lnbm1lbnQuZXZlbnRUaXRsZSxcbiAgICAgICAgICByb2xlOiBhc3NpZ25tZW50LnBlcm1pc3Npb25zLnJvbGUsXG4gICAgICAgICAgYWNjZXNzTGV2ZWw6IGFzc2lnbm1lbnQuYWNjZXNzTGV2ZWxcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGlmIChhc3NpZ25tZW50LmFjY2Vzc0xldmVsID09PSAnZnVsbF9tYW5hZ2VtZW50Jykge1xuICAgICAgICAgIG1hbmFnZWRFdmVudHMucHVzaChldmVudEluZm8pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgQWRkZWQgdG8gbWFuYWdlZCBldmVudHM6ICR7YXNzaWdubWVudC5ldmVudFRpdGxlfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNraW5FdmVudHMucHVzaChldmVudEluZm8pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgQWRkZWQgdG8gY2hlY2tpbiBldmVudHM6ICR7YXNzaWdubWVudC5ldmVudFRpdGxlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgcGFnZS1iYXNlZCBjb2xsYWJvcmF0aW9uc1xuICAgICAgZm9yIChjb25zdCBkb2NTbmFwIG9mIHBhZ2VTbmFwc2hvdC5kb2NzKSB7XG4gICAgICAgIGNvbnN0IGFzc2lnbm1lbnQgPSBkb2NTbmFwLmRhdGEoKSBhcyBFdmVudENvbGxhYm9yYXRpb25Bc3NpZ25tZW50O1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYPCflI0gUHJvY2Vzc2luZyBwYWdlIGNvbGxhYm9yYXRpb246ICR7YXNzaWdubWVudC5ldmVudFRpdGxlfSAoJHthc3NpZ25tZW50LmFjY2Vzc0xldmVsfSkgdmlhIHBhZ2UgJHthc3NpZ25tZW50LnBhZ2VOYW1lfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgZXhwaXJlZFxuICAgICAgICBpZiAoYXNzaWdubWVudC5leHBpcmVzQXQgJiYgbmV3IERhdGUoYXNzaWdubWVudC5leHBpcmVzQXQpIDwgbmV3IERhdGUoKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDij7AgUGFnZSBhc3NpZ25tZW50IGV4cGlyZWQ6ICR7YXNzaWdubWVudC5ldmVudFRpdGxlfSAoZXhwaXJlZCBhdCAke2Fzc2lnbm1lbnQuZXhwaXJlc0F0fSlgKTtcbiAgICAgICAgICAvLyBNYXJrIGFzIGV4cGlyZWQgaW4gZGF0YWJhc2VcbiAgICAgICAgICBhd2FpdCB1cGRhdGVEb2MoZG9jU25hcC5yZWYsIHtcbiAgICAgICAgICAgIGlzQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXR1czogJ2V4cGlyZWQnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGV2ZW50SW5mbyA9IHtcbiAgICAgICAgICBldmVudElkOiBhc3NpZ25tZW50LmV2ZW50SWQsXG4gICAgICAgICAgZXZlbnRUaXRsZTogYXNzaWdubWVudC5ldmVudFRpdGxlLFxuICAgICAgICAgIHJvbGU6IGFzc2lnbm1lbnQucGVybWlzc2lvbnMucm9sZSxcbiAgICAgICAgICBhY2Nlc3NMZXZlbDogYXNzaWdubWVudC5hY2Nlc3NMZXZlbFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgaWYgKGFzc2lnbm1lbnQuYWNjZXNzTGV2ZWwgPT09ICdmdWxsX21hbmFnZW1lbnQnKSB7XG4gICAgICAgICAgbWFuYWdlZEV2ZW50cy5wdXNoKGV2ZW50SW5mbyk7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBBZGRlZCBwYWdlIGV2ZW50IHRvIG1hbmFnZWQgZXZlbnRzOiAke2Fzc2lnbm1lbnQuZXZlbnRUaXRsZX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVja2luRXZlbnRzLnB1c2goZXZlbnRJbmZvKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEFkZGVkIHBhZ2UgZXZlbnQgdG8gY2hlY2tpbiBldmVudHM6ICR7YXNzaWdubWVudC5ldmVudFRpdGxlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzIChpbiBjYXNlIHVzZXIgaGFzIGJvdGggZGlyZWN0IGFuZCBwYWdlIGFjY2VzcyB0byBzYW1lIGV2ZW50KVxuICAgICAgY29uc3QgdW5pcXVlTWFuYWdlZCA9IEFycmF5LmZyb20oXG4gICAgICAgIG5ldyBNYXAobWFuYWdlZEV2ZW50cy5tYXAoZXZlbnQgPT4gW2V2ZW50LmV2ZW50SWQsIGV2ZW50XSkpLnZhbHVlcygpXG4gICAgICApO1xuICAgICAgY29uc3QgdW5pcXVlQ2hlY2tpbiA9IEFycmF5LmZyb20oXG4gICAgICAgIG5ldyBNYXAoY2hlY2tpbkV2ZW50cy5tYXAoZXZlbnQgPT4gW2V2ZW50LmV2ZW50SWQsIGV2ZW50XSkpLnZhbHVlcygpXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBGaW5hbCByZXN1bHRzOiAke3VuaXF1ZU1hbmFnZWQubGVuZ3RofSBtYW5hZ2VkIGV2ZW50cywgJHt1bmlxdWVDaGVja2luLmxlbmd0aH0gY2hlY2tpbiBldmVudHNgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHsgbWFuYWdlZEV2ZW50czogdW5pcXVlTWFuYWdlZCwgY2hlY2tpbkV2ZW50czogdW5pcXVlQ2hlY2tpbiB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgdXNlciBzaGFyZWQgZXZlbnRzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IG1hbmFnZWRFdmVudHM6IFtdLCBjaGVja2luRXZlbnRzOiBbXSB9O1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEFjY2VwdCBldmVudCBpbnZpdGF0aW9uXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgYWNjZXB0RXZlbnRJbnZpdGF0aW9uKFxuICAgIGludml0YXRpb25JZDogc3RyaW5nLFxuICAgIHVzZXJJZDogc3RyaW5nLFxuICAgIHVzZXJOYW1lOiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaW52aXRhdGlvbkRvYyA9IGF3YWl0IGdldERvYyhkb2MoZGIoKSwgJ2V2ZW50SW52aXRhdGlvbnMnLCBpbnZpdGF0aW9uSWQpKTtcbiAgICAgIGlmICghaW52aXRhdGlvbkRvYy5leGlzdHMoKSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdJbnZpdGF0aW9uIG5vdCBmb3VuZCcgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgaW52aXRhdGlvbiA9IGludml0YXRpb25Eb2MuZGF0YSgpIGFzIEV2ZW50SW52aXRhdGlvbjtcbiAgICAgIFxuICAgICAgaWYgKGludml0YXRpb24uc3RhdHVzICE9PSAncGVuZGluZycgfHwgbmV3IERhdGUoaW52aXRhdGlvbi5leHBpcmVzQXQpIDwgbmV3IERhdGUoKSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdJbnZpdGF0aW9uIGhhcyBleHBpcmVkIG9yIGFscmVhZHkgYmVlbiByZXNwb25kZWQgdG8nIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGFzc2lnbm1lbnQ6IEV2ZW50Q29sbGFib3JhdGlvbkFzc2lnbm1lbnQgPSB7XG4gICAgICAgIGV2ZW50SWQ6IGludml0YXRpb24uZXZlbnRJZCxcbiAgICAgICAgZXZlbnRUaXRsZTogaW52aXRhdGlvbi5ldmVudFRpdGxlLFxuICAgICAgICBzZXNzaW9uSWQ6IGludml0YXRpb24uc2Vzc2lvbklkLFxuICAgICAgICBzZXNzaW9uTmFtZTogaW52aXRhdGlvbi5zZXNzaW9uTmFtZSxcbiAgICAgICAgY29sbGFib3JhdG9yVHlwZTogaW52aXRhdGlvbi5jb2xsYWJvcmF0b3JUeXBlLFxuICAgICAgICB1c2VyUGhvbmU6IGludml0YXRpb24uaW52aXRlZFBob25lLFxuICAgICAgICB1c2VySWQsXG4gICAgICAgIHVzZXJOYW1lLFxuICAgICAgICBwZXJtaXNzaW9uczogaW52aXRhdGlvbi5wZXJtaXNzaW9ucyxcbiAgICAgICAgYWNjZXNzTGV2ZWw6IGludml0YXRpb24uYWNjZXNzTGV2ZWwsXG4gICAgICAgIGFzc2lnbmVkQnk6IGludml0YXRpb24uaW52aXRlZEJ5VXNlcklkLFxuICAgICAgICBhc3NpZ25lZEJ5TmFtZTogaW52aXRhdGlvbi5pbnZpdGVkQnlOYW1lLFxuICAgICAgICBhc3NpZ25lZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICBub3RlczogYEFjY2VwdGVkIGludml0YXRpb246ICR7aW52aXRhdGlvbi5tZXNzYWdlfWAsXG4gICAgICAgIGludml0YXRpb25NZXNzYWdlOiBpbnZpdGF0aW9uLm1lc3NhZ2UsXG4gICAgICAgIHNob3dPbkV2ZW50UGFnZTogaW52aXRhdGlvbi5zaG93T25FdmVudFBhZ2VcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGJhdGNoID0gd3JpdGVCYXRjaChkYigpKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGludml0YXRpb24gc3RhdHVzXG4gICAgICBiYXRjaC51cGRhdGUoZG9jKGRiKCksICdldmVudEludml0YXRpb25zJywgaW52aXRhdGlvbklkKSwge1xuICAgICAgICBzdGF0dXM6ICdhY2NlcHRlZCcsXG4gICAgICAgIHJlc3BvbmRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgICAgaW52aXRlZFVzZXJJZDogdXNlcklkXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGNvbGxhYm9yYXRpb24gYXNzaWdubWVudFxuICAgICAgY29uc3QgYXNzaWdubWVudFJlZiA9IGRvYyhjb2xsZWN0aW9uKGRiKCksICdldmVudENvbGxhYm9yYXRpb24nKSk7XG4gICAgICBiYXRjaC5zZXQoYXNzaWdubWVudFJlZiwge1xuICAgICAgICAuLi5hc3NpZ25tZW50LFxuICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgYXdhaXQgYmF0Y2guY29tbWl0KCk7XG4gICAgICBcbiAgICAgIGF3YWl0IHRoaXMubG9nU2VjdXJpdHlFdmVudCh7XG4gICAgICAgIHR5cGU6ICdldmVudF9jb2xsYWJvcmF0aW9uJyxcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBldmVudElkOiBpbnZpdGF0aW9uLmV2ZW50SWQsXG4gICAgICAgIGFjdGlvbjogJ2ludml0YXRpb25fYWNjZXB0ZWQnLFxuICAgICAgICByZXN1bHQ6ICdzdWNjZXNzJyxcbiAgICAgICAgZGV0YWlsczogeyBpbnZpdGF0aW9uSWQsIGFjY2Vzc0xldmVsOiBpbnZpdGF0aW9uLmFjY2Vzc0xldmVsIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFjY2VwdGluZyBpbnZpdGF0aW9uOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0ZhaWxlZCB0byBhY2NlcHQgaW52aXRhdGlvbicgfTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBWZXJpZnkgZXZlbnQgYWNjZXNzIGZvciB1c2VyXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdmVyaWZ5RXZlbnRBY2Nlc3MoZXZlbnRJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8RXZlbnRQZXJtaXNzaW9ucz4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSB2ZXJpZnlFdmVudEFjY2VzczogQ2hlY2tpbmcgYWNjZXNzIGZvciB1c2VyICR7dXNlcklkLnN1YnN0cmluZygwLCA4KX0uLi4gdG8gZXZlbnQgJHtldmVudElkfWApO1xuICAgICAgXG4gICAgICAvLyBHZXQgZXZlbnQgZGF0YVxuICAgICAgY29uc3QgZXZlbnREb2MgPSBhd2FpdCBnZXREb2MoZG9jKGRiKCksICdldmVudHMnLCBldmVudElkKSk7XG4gICAgICBpZiAoIWV2ZW50RG9jLmV4aXN0cygpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDinYwgdmVyaWZ5RXZlbnRBY2Nlc3M6IEV2ZW50ICR7ZXZlbnRJZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIHJldHVybiB0aGlzLnVuYXV0aG9yaXplZFBlcm1pc3Npb25zKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IGV2ZW50RG9jLmRhdGEoKTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OFIHZlcmlmeUV2ZW50QWNjZXNzOiBFdmVudCBmb3VuZCAtICR7ZXZlbnREYXRhLnRpdGxlfWApO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB1c2VyIGlzIGV2ZW50IG93bmVyXG4gICAgICBpZiAoZXZlbnREYXRhLm9yZ2FuaXphdGlvbklkID09PSB1c2VySWQgfHwgXG4gICAgICAgICAgKGV2ZW50RGF0YS5jcmVhdG9yICYmIGV2ZW50RGF0YS5jcmVhdG9yLnVzZXJJZCA9PT0gdXNlcklkKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIHZlcmlmeUV2ZW50QWNjZXNzOiBVc2VyIGlzIGV2ZW50IG93bmVyYCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FuVmlldzogdHJ1ZSxcbiAgICAgICAgICBjYW5DaGVja0luOiB0cnVlLFxuICAgICAgICAgIGNhbk1hbmFnZUF0dGVuZGVlczogdHJ1ZSxcbiAgICAgICAgICBjYW5WaWV3RmluYW5jaWFsczogdHJ1ZSxcbiAgICAgICAgICBjYW5FZGl0RXZlbnQ6IHRydWUsXG4gICAgICAgICAgY2FuVmlld1JlcG9ydHM6IHRydWUsXG4gICAgICAgICAgY2FuU2VuZENvbW11bmljYXRpb25zOiB0cnVlLFxuICAgICAgICAgIHJvbGU6ICdldmVudF9vd25lcidcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgY29sbGFib3JhdGlvbiBwZXJtaXNzaW9uc1xuICAgICAgY29uc29sZS5sb2coYPCflI0gdmVyaWZ5RXZlbnRBY2Nlc3M6IENoZWNraW5nIGNvbGxhYm9yYXRpb24gcGVybWlzc2lvbnMuLi5gKTtcbiAgICAgIGNvbnN0IGNvbGxhYm9yYXRpb25RdWVyeSA9IHF1ZXJ5KFxuICAgICAgICBjb2xsZWN0aW9uKGRiKCksICdldmVudENvbGxhYm9yYXRpb24nKSxcbiAgICAgICAgd2hlcmUoJ2V2ZW50SWQnLCAnPT0nLCBldmVudElkKSxcbiAgICAgICAgd2hlcmUoJ2lzQWN0aXZlJywgJz09JywgdHJ1ZSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhjb2xsYWJvcmF0aW9uUXVlcnkpO1xuICAgICAgY29uc29sZS5sb2coYPCflI0gdmVyaWZ5RXZlbnRBY2Nlc3M6IEZvdW5kICR7c25hcHNob3Quc2l6ZX0gY29sbGFib3JhdGlvbiByZWNvcmRzYCk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgZG9jU25hcCBvZiBzbmFwc2hvdC5kb2NzKSB7XG4gICAgICAgIGNvbnN0IGFzc2lnbm1lbnQgPSBkb2NTbmFwLmRhdGEoKSBhcyBFdmVudENvbGxhYm9yYXRpb25Bc3NpZ25tZW50O1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSB2ZXJpZnlFdmVudEFjY2VzczogQ2hlY2tpbmcgYXNzaWdubWVudDpgLCB7XG4gICAgICAgICAgY29sbGFib3JhdG9yVHlwZTogYXNzaWdubWVudC5jb2xsYWJvcmF0b3JUeXBlLFxuICAgICAgICAgIHVzZXJJZDogYXNzaWdubWVudC51c2VySWQ/LnN1YnN0cmluZygwLCA4KSxcbiAgICAgICAgICBwYWdlT3duZXJJZDogYXNzaWdubWVudC5wYWdlT3duZXJJZD8uc3Vic3RyaW5nKDAsIDgpLFxuICAgICAgICAgIGFjY2Vzc0xldmVsOiBhc3NpZ25tZW50LmFjY2Vzc0xldmVsLFxuICAgICAgICAgIGlzQWN0aXZlOiBhc3NpZ25tZW50LmlzQWN0aXZlLFxuICAgICAgICAgIGV4cGlyZXNBdDogYXNzaWdubWVudC5leHBpcmVzQXRcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBleHBpcmVkXG4gICAgICAgIGlmIChhc3NpZ25tZW50LmV4cGlyZXNBdCAmJiBuZXcgRGF0ZShhc3NpZ25tZW50LmV4cGlyZXNBdCkgPCBuZXcgRGF0ZSgpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKPsCB2ZXJpZnlFdmVudEFjY2VzczogQXNzaWdubWVudCBleHBpcmVkIGF0ICR7YXNzaWdubWVudC5leHBpcmVzQXR9YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgYXNzaWdubWVudCBnaXZlcyB0aGUgdXNlciBhY2Nlc3NcbiAgICAgICAgaWYgKGFzc2lnbm1lbnQuY29sbGFib3JhdG9yVHlwZSA9PT0gJ3BhZ2UnICYmIGFzc2lnbm1lbnQucGFnZU93bmVySWQgPT09IHVzZXJJZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgdmVyaWZ5RXZlbnRBY2Nlc3M6IEZvdW5kIHBhZ2UtYmFzZWQgYWNjZXNzIGZvciB1c2VyYCk7XG4gICAgICAgICAgcmV0dXJuIGFzc2lnbm1lbnQucGVybWlzc2lvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoYXNzaWdubWVudC5jb2xsYWJvcmF0b3JUeXBlID09PSAndXNlcicgJiYgYXNzaWdubWVudC51c2VySWQgPT09IHVzZXJJZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgdmVyaWZ5RXZlbnRBY2Nlc3M6IEZvdW5kIGRpcmVjdCB1c2VyIGFjY2Vzc2ApO1xuICAgICAgICAgIHJldHVybiBhc3NpZ25tZW50LnBlcm1pc3Npb25zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDinYwgdmVyaWZ5RXZlbnRBY2Nlc3M6IE5vIGNvbGxhYm9yYXRpb24gYWNjZXNzIGZvdW5kIGZvciB1c2VyICR7dXNlcklkLnN1YnN0cmluZygwLCA4KX0uLi5gKTtcbiAgICAgIHJldHVybiB0aGlzLnVuYXV0aG9yaXplZFBlcm1pc3Npb25zKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCB2ZXJpZnlFdmVudEFjY2VzczogRXJyb3IgdmVyaWZ5aW5nIGV2ZW50IGFjY2VzczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gdGhpcy51bmF1dGhvcml6ZWRQZXJtaXNzaW9ucygpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBwZW5kaW5nIGludml0YXRpb25zIGZvciB1c2VyIHBob25lXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0VXNlclBlbmRpbmdJbnZpdGF0aW9ucyh1c2VyUGhvbmU6IHN0cmluZyk6IFByb21pc2U8RXZlbnRJbnZpdGF0aW9uW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaW52aXRhdGlvbnNRdWVyeSA9IHF1ZXJ5KFxuICAgICAgICBjb2xsZWN0aW9uKGRiKCksICdldmVudEludml0YXRpb25zJyksXG4gICAgICAgIHdoZXJlKCdpbnZpdGVkUGhvbmUnLCAnPT0nLCB1c2VyUGhvbmUpLFxuICAgICAgICB3aGVyZSgnc3RhdHVzJywgJz09JywgJ3BlbmRpbmcnKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGludml0YXRpb25zUXVlcnkpO1xuICAgICAgXG4gICAgICByZXR1cm4gc25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XG4gICAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAgIC4uLmRvYy5kYXRhKClcbiAgICAgIH0gYXMgRXZlbnRJbnZpdGF0aW9uKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHBlbmRpbmcgaW52aXRhdGlvbnM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFNlY3VyaXR5IGxvZ2dpbmdcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIGxvZ1NlY3VyaXR5RXZlbnQoZXZlbnQ6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYigpLCAnc2VjdXJpdHlFdmVudHMnKSwge1xuICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgdGltZXN0YW1wOiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgICAgc291cmNlOiAnZXZlbnRfY29sbGFib3JhdGlvbl9zZWN1cml0eSdcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2dnaW5nIHNlY3VyaXR5IGV2ZW50OicsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgc3RhdGljIHVuYXV0aG9yaXplZFBlcm1pc3Npb25zKCk6IEV2ZW50UGVybWlzc2lvbnMge1xuICAgIHJldHVybiB7XG4gICAgICBjYW5WaWV3OiBmYWxzZSxcbiAgICAgIGNhbkNoZWNrSW46IGZhbHNlLFxuICAgICAgY2FuTWFuYWdlQXR0ZW5kZWVzOiBmYWxzZSxcbiAgICAgIGNhblZpZXdGaW5hbmNpYWxzOiBmYWxzZSxcbiAgICAgIGNhbkVkaXRFdmVudDogZmFsc2UsXG4gICAgICBjYW5WaWV3UmVwb3J0czogZmFsc2UsXG4gICAgICBjYW5TZW5kQ29tbXVuaWNhdGlvbnM6IGZhbHNlLFxuICAgICAgcm9sZTogJ3VuYXV0aG9yaXplZCdcbiAgICB9O1xuICB9XG59ICJdLCJuYW1lcyI6WyJjb2xsZWN0aW9uIiwiZG9jIiwiZ2V0RG9jIiwiZ2V0RG9jcyIsImFkZERvYyIsInVwZGF0ZURvYyIsIndyaXRlQmF0Y2giLCJxdWVyeSIsIndoZXJlIiwic2VydmVyVGltZXN0YW1wIiwiZGIiLCJFdmVudENvbGxhYm9yYXRpb25TZWN1cml0eSIsInZhbGlkYXRlVXNlcm5hbWUiLCJ1c2VybmFtZSIsImlzVmFsaWQiLCJlcnJvciIsInRyaW1tZWQiLCJ0cmltIiwibGVuZ3RoIiwidXNlcm5hbWVSZWdleCIsInRlc3QiLCJzdXNwaWNpb3VzUGF0dGVybnMiLCJzb21lIiwicGF0dGVybiIsInZhbGlkYXRlUGhvbmVOdW1iZXIiLCJwaG9uZSIsImNsZWFuUGhvbmUiLCJyZXBsYWNlIiwic3RhcnRzV2l0aCIsInBob25lUmVnZXgiLCJzYW5pdGl6ZUlucHV0IiwiaW5wdXQiLCJzdWJzdHJpbmciLCJ2YWxpZGF0ZU1lc3NhZ2UiLCJtZXNzYWdlIiwiY2hlY2tJbnZpdGF0aW9uUmF0ZUxpbWl0IiwidXNlcklkIiwibm93IiwiRGF0ZSIsImhvdXJNcyIsImRhaWx5TXMiLCJlbnRyaWVzVG9EZWxldGUiLCJpbnZpdGF0aW9uQ291bnRzIiwiZm9yRWFjaCIsImRhdGEiLCJrZXkiLCJyZXNldFRpbWUiLCJwdXNoIiwiZGVsZXRlIiwiaG91cmx5S2V5IiwiaG91cmx5RGF0YSIsImdldCIsImNvdW50IiwiYWxsb3dlZCIsImRhaWx5S2V5IiwiZGFpbHlEYXRhIiwic2V0IiwiY2hlY2tSZXNvdXJjZUxpbWl0cyIsImV2ZW50SWQiLCJpbnZpdGVySWQiLCJjb2xsYWJvcmF0b3JzUXVlcnkiLCJzbmFwc2hvdCIsInNpemUiLCJ1c2VyRXZlbnRzUXVlcnkiLCJ1c2VyU25hcHNob3QiLCJjb25zb2xlIiwiZ2V0UGVybWlzc2lvblRlbXBsYXRlcyIsImZ1bGxfbWFuYWdlbWVudCIsImNhblZpZXciLCJjYW5DaGVja0luIiwiY2FuTWFuYWdlQXR0ZW5kZWVzIiwiY2FuVmlld0ZpbmFuY2lhbHMiLCJjYW5FZGl0RXZlbnQiLCJjYW5WaWV3UmVwb3J0cyIsImNhblNlbmRDb21tdW5pY2F0aW9ucyIsInJvbGUiLCJjaGVja2luX29ubHkiLCJmaW5kUGFnZUJ5VXNlcm5hbWUiLCJub3JtYWxpemVkVXNlcm5hbWUiLCJ0b0xvd2VyQ2FzZSIsImFydGlzdHNRdWVyeSIsIm9yZ2FuaXphdGlvbnNRdWVyeSIsInZlbnVlc1F1ZXJ5IiwiUHJvbWlzZSIsImFsbCIsImVtcHR5IiwiZG9jcyIsImZvdW5kIiwicGFnZVR5cGUiLCJwYWdlSWQiLCJpZCIsInBhZ2VOYW1lIiwibmFtZSIsIm93bmVySWQiLCJmaW5kVXNlckJ5UGhvbmUiLCJsb2ciLCJwaG9uZVZhcmlhdGlvbnMiLCJ1c2Vyc1F1ZXJ5QnlQaG9uZSIsInVzZXJzUXVlcnlCeVBob25lTnVtYmVyIiwicGhvbmVTbmFwc2hvdCIsInBob25lTnVtYmVyU25hcHNob3QiLCJ1c2VyRGF0YSIsImZvdW5kRmllbGQiLCJhbGxVc2Vyc1F1ZXJ5IiwiYWxsVXNlcnNTbmFwc2hvdCIsImluZGV4IiwicGhvbmVOdW1iZXIiLCJyZXN1bHQiLCJ1aWQiLCJkaXNwbGF5TmFtZSIsInZlcmlmeUV2ZW50T3duZXJzaGlwQWNjZXNzIiwiZXZlbnREb2MiLCJleGlzdHMiLCJldmVudERhdGEiLCJvcmdhbml6YXRpb25JZCIsImNyZWF0b3IiLCJjb250ZW50VHlwZSIsImNvbnRlbnRJZCIsIkNvbnRlbnRTaGFyaW5nU2VjdXJpdHkiLCJwZXJtaXNzaW9ucyIsInZlcmlmeUNvbnRlbnRBY2Nlc3MiLCJ2ZXJpZnlFdmVudE1hbmFnZW1lbnRBY2Nlc3MiLCJjb2xsYWJvcmF0aW9uUXVlcnkiLCJkb2NTbmFwIiwiYXNzaWdubWVudCIsImV4cGlyZXNBdCIsImNvbGxhYm9yYXRvclR5cGUiLCJwYWdlT3duZXJJZCIsImFjY2Vzc0xldmVsIiwic2hhcmVTZXNzaW9uIiwic2Vzc2lvbklkIiwic2Vzc2lvbk5hbWUiLCJjb2xsYWJvcmF0b3JJZGVudGlmaWVyIiwiaW52aXRlck5hbWUiLCJleHBpcmVzSW5Ib3VycyIsInNob3dPbkV2ZW50UGFnZSIsImhhc0FjY2VzcyIsInN1Y2Nlc3MiLCJyYXRlTGltaXRDaGVjayIsInJlc291cmNlQ2hlY2siLCJldmVudFRpdGxlIiwidGl0bGUiLCJzYW5pdGl6ZWRNZXNzYWdlIiwidXNlcm5hbWVWYWxpZGF0aW9uIiwicGFnZVJlc3VsdCIsImV4aXN0aW5nQXNzaWdubWVudFF1ZXJ5IiwiZXhpc3RpbmdJbnZpdGF0aW9uUXVlcnkiLCJleGlzdGluZ1NuYXBzaG90IiwiaW52aXRhdGlvblNuYXBzaG90IiwiZXhpc3RpbmdJbnZpdGF0aW9uIiwiaW52aXRlZFBob25lIiwic3RhdHVzIiwiY3JlYXRlZEF0IiwiZGVidWdVc2VyU2VhcmNoIiwiaW52aXRhdGlvbiIsInBhZ2VVc2VybmFtZSIsImludml0ZWRCeVVzZXJJZCIsImludml0ZWRCeU5hbWUiLCJ0b0lTT1N0cmluZyIsImRvY1JlZiIsImxvZ1NlY3VyaXR5RXZlbnQiLCJ0eXBlIiwiYWN0aW9uIiwiZGV0YWlscyIsImludml0YXRpb25JZCIsInBob25lVmFsaWRhdGlvbiIsInNhbml0aXplZFBob25lIiwiZXhpc3RpbmdVc2VyIiwidXNlclBob25lIiwidXNlck5hbWUiLCJhc3NpZ25lZEJ5IiwiYXNzaWduZWRCeU5hbWUiLCJhc3NpZ25lZEF0IiwiaXNBY3RpdmUiLCJub3RlcyIsImludml0YXRpb25NZXNzYWdlIiwidGFyZ2V0VXNlcklkIiwibWV0aG9kIiwiYXNzaWdubWVudElkIiwicmVtb3ZlU2Vzc2lvbkFjY2VzcyIsInJlbW92ZWRCeVVzZXJJZCIsImFzc2lnbm1lbnREb2MiLCJyZW1vdmVkQXQiLCJyZW1vdmVkQnkiLCJnZXRTZXNzaW9uQ29sbGFib3JhdG9ycyIsImFzc2lnbm1lbnRzIiwibWFwIiwiY29sbGFib3JhdG9yTWFwIiwiTWFwIiwiZXhpc3RpbmciLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJnZXRVc2VyU2hhcmVkRXZlbnRzIiwic2hhcmVkUXVlcnkiLCJwYWdlQmFzZWRRdWVyeSIsInBhZ2VTbmFwc2hvdCIsIm1hbmFnZWRFdmVudHMiLCJjaGVja2luRXZlbnRzIiwicmVmIiwiZXZlbnRJbmZvIiwidW5pcXVlTWFuYWdlZCIsImV2ZW50IiwidW5pcXVlQ2hlY2tpbiIsImFjY2VwdEV2ZW50SW52aXRhdGlvbiIsImludml0YXRpb25Eb2MiLCJiYXRjaCIsInVwZGF0ZSIsInJlc3BvbmRlZEF0IiwiaW52aXRlZFVzZXJJZCIsImFzc2lnbm1lbnRSZWYiLCJjb21taXQiLCJ2ZXJpZnlFdmVudEFjY2VzcyIsInVuYXV0aG9yaXplZFBlcm1pc3Npb25zIiwiZ2V0VXNlclBlbmRpbmdJbnZpdGF0aW9ucyIsImludml0YXRpb25zUXVlcnkiLCJ0aW1lc3RhbXAiLCJzb3VyY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/domains/events/services/collaboration.service.ts\n"));

/***/ })

}]);